(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/react/cjs/react.production.js
  var require_react_production = __commonJS({
    "node_modules/react/cjs/react.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      };
      var assign = Object.assign;
      var emptyObject = {};
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      var isArrayImpl = Array.isArray;
      var ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, self, source, owner, props) {
        self = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== self ? self : null,
          props
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(
          oldElement.type,
          newKey,
          void 0,
          void 0,
          void 0,
          oldElement.props
        );
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
      }
      function noop$1() {
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback)
          return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + invokeCallback
          )), array.push(callback)), 1;
        invokeCallback = 0;
        var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      function noop() {
      }
      exports.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size) {
          return ReactSharedInternals.H.useMemoCache(size);
        }
      };
      exports.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key, owner = void 0;
        if (null != config)
          for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          for (var childArray = Array(propName), i = 0; i < propName; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, void 0, void 0, owner, props);
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        return defaultValue;
      };
      exports.createElement = function(type, config, children) {
        var propName, props = {}, key = null;
        if (null != config)
          for (propName in void 0 !== config.key && (key = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) props.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, void 0, void 0, null, props);
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render };
      };
      exports.isValidElement = isValidElement;
      exports.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports.memo = function(type, compare) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      exports.use = function(usable) {
        return ReactSharedInternals.H.use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState, permalink);
      };
      exports.useCallback = function(callback, deps) {
        return ReactSharedInternals.H.useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        return ReactSharedInternals.H.useContext(Context);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create, createDeps, update) {
        var dispatcher = ReactSharedInternals.H;
        if ("function" === typeof update)
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return dispatcher.useEffect(create, createDeps);
      };
      exports.useId = function() {
        return ReactSharedInternals.H.useId();
      };
      exports.useImperativeHandle = function(ref, create, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function(create, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function(create, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create, deps);
      };
      exports.useMemo = function(create, deps) {
        return ReactSharedInternals.H.useMemo(create, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init) {
        return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
      };
      exports.useRef = function(initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return ReactSharedInternals.H.useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return ReactSharedInternals.H.useTransition();
      };
      exports.version = "19.1.1";
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.production.js
  var require_scheduler_production = __commonJS({
    "node_modules/scheduler/cjs/scheduler.production.js"(exports) {
      "use strict";
      function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for (; 0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node))
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
            else if (rightIndex < length && 0 > compare(right, last))
              heap[index] = right, heap[rightIndex] = last, index = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare(a, b2) {
        var diff = a.sortIndex - b2.sortIndex;
        return 0 !== diff ? diff : a.id - b2.id;
      }
      exports.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var localPerformance;
      var localDate;
      var initialTime;
      var taskQueue = [];
      var timerQueue = [];
      var taskIdCounter = 1;
      var currentTask = null;
      var currentPriorityLevel = 3;
      var isPerformingWork = false;
      var isHostCallbackScheduled = false;
      var isHostTimeoutScheduled = false;
      var needsPaint = false;
      var localSetTimeout = "function" === typeof setTimeout ? setTimeout : null;
      var localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null;
      var localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      var isMessageLoopRunning = false;
      var taskTimeoutID = -1;
      var frameInterval = 5;
      var startTime = -1;
      function shouldYieldToHost() {
        return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
      }
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ("function" === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      var channel;
      var port;
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_scheduler_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.production.js
  var require_react_dom_production = __commonJS({
    "node_modules/react-dom/cjs/react-dom.production.js"(exports) {
      "use strict";
      var React12 = require_react();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function noop() {
      }
      var Internals = {
        d: {
          f: noop,
          r: function() {
            throw Error(formatProdErrorMessage(522));
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      };
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var ReactSharedInternals = React12.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function(children, container) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
          throw Error(formatProdErrorMessage(299));
        return createPortal$1(children, container, null, key);
      };
      exports.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
        }
      };
      exports.preconnect = function(href, options) {
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports.prefetchDNS = function(href) {
        "string" === typeof href && Internals.d.D(href);
      };
      exports.preinit = function(href, options) {
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports.preinitModule = function(href, options) {
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as) {
              var crossOrigin = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              );
              Internals.d.M(href, {
                crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
            }
          } else null == options && Internals.d.M(href);
      };
      exports.preload = function(href, options) {
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
          Internals.d.L(href, as, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports.preloadModule = function(href, options) {
        if ("string" === typeof href)
          if (options) {
            var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
            Internals.d.m(href, {
              as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0
            });
          } else Internals.d.m(href);
      };
      exports.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      exports.useFormState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useFormState(action, initialState, permalink);
      };
      exports.useFormStatus = function() {
        return ReactSharedInternals.H.useHostTransitionStatus();
      };
      exports.version = "19.1.1";
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-client.production.js
  var require_react_dom_client_production = __commonJS({
    "node_modules/react-dom/cjs/react-dom-client.production.js"(exports) {
      "use strict";
      var Scheduler = require_scheduler();
      var React12 = require_react();
      var ReactDOM2 = require_react_dom();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function isValidContainer(node) {
        return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate) for (; node.return; ) node = node.return;
        else {
          fiber = node;
          do
            node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
          var suspenseState = fiber.memoizedState;
          null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
          if (null !== suspenseState) return suspenseState.dehydrated;
        }
        return null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error(formatProdErrorMessage(188));
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate) throw Error(formatProdErrorMessage(188));
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b2 = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b2 = parentA.return;
            if (null !== b2) {
              a = b2;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a) return assertIsMounted(parentA), fiber;
              if (parentB === b2) return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error(formatProdErrorMessage(188));
          }
          if (a.return !== b2.return) a = parentA, b2 = parentB;
          else {
            for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentA;
                b2 = parentB;
                break;
              }
              if (child$0 === b2) {
                didFindChild = true;
                b2 = parentA;
                a = parentB;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) {
              for (child$0 = parentB.child; child$0; ) {
                if (child$0 === a) {
                  didFindChild = true;
                  a = parentB;
                  b2 = parentA;
                  break;
                }
                if (child$0 === b2) {
                  didFindChild = true;
                  b2 = parentB;
                  a = parentA;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild) throw Error(formatProdErrorMessage(189));
            }
          }
          if (a.alternate !== b2) throw Error(formatProdErrorMessage(190));
        }
        if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag) return tag;
          node = node.sibling;
        }
        return null;
      }
      var assign = Object.assign;
      var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.tracing_marker");
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
      Symbol.for("react.view_transition");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x3) {
              }
          }
        return null;
      }
      var isArrayImpl = Array.isArray;
      var ReactSharedInternals = React12.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      var ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      var sharedNotPendingObject = {
        pending: false,
        data: null,
        method: null,
        action: null
      };
      var valueStack = [];
      var index = -1;
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor) {
        0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
      }
      function push(cursor, value) {
        index++;
        valueStack[index] = cursor.current;
        cursor.current = value;
      }
      var contextStackCursor = createCursor(null);
      var contextFiberStackCursor = createCursor(null);
      var rootInstanceStackCursor = createCursor(null);
      var hostTransitionProviderCursor = createCursor(null);
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance);
        push(contextFiberStackCursor, fiber);
        push(contextStackCursor, null);
        switch (nextRootInstance.nodeType) {
          case 9:
          case 11:
            fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
            break;
          default:
            if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
              nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
            else
              switch (fiber) {
                case "svg":
                  fiber = 1;
                  break;
                case "math":
                  fiber = 2;
                  break;
                default:
                  fiber = 0;
              }
        }
        pop(contextStackCursor);
        push(contextStackCursor, fiber);
      }
      function popHostContainer() {
        pop(contextStackCursor);
        pop(contextFiberStackCursor);
        pop(rootInstanceStackCursor);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
        var context = contextStackCursor.current;
        var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
        context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;
      var cancelCallback$1 = Scheduler.unstable_cancelCallback;
      var shouldYield = Scheduler.unstable_shouldYield;
      var requestPaint = Scheduler.unstable_requestPaint;
      var now = Scheduler.unstable_now;
      var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
      var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
      var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
      var NormalPriority$1 = Scheduler.unstable_NormalPriority;
      var LowPriority = Scheduler.unstable_LowPriority;
      var IdlePriority = Scheduler.unstable_IdlePriority;
      var log$1 = Scheduler.log;
      var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
      var rendererID = null;
      var injectedHook = null;
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
          }
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x3) {
        x3 >>>= 0;
        return 0 === x3 ? 32 : 31 - (log(x3) / LN2 | 0) | 0;
      }
      var nextTransitionLane = 256;
      var nextRetryLane = 4194304;
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 4194048;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return lanes;
        }
      }
      function getNextLanes(root3, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root3.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
        root3 = root3.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root3, renderLanes2) {
        return 0 === (root3.pendingLanes & ~(root3.suspendedLanes & ~root3.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
        return lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root3, updateLane) {
        root3.pendingLanes |= updateLane;
        268435456 !== updateLane && (root3.suspendedLanes = 0, root3.pingedLanes = 0, root3.warmLanes = 0);
      }
      function markRootFinished(root3, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root3.pendingLanes;
        root3.pendingLanes = remainingLanes;
        root3.suspendedLanes = 0;
        root3.pingedLanes = 0;
        root3.warmLanes = 0;
        root3.expiredLanes &= remainingLanes;
        root3.entangledLanes &= remainingLanes;
        root3.errorRecoveryDisabledLanes &= remainingLanes;
        root3.shellSuspendCounter = 0;
        var entanglements = root3.entanglements, expirationTimes = root3.expirationTimes, hiddenUpdates = root3.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
          entanglements[index$5] = 0;
          expirationTimes[index$5] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index$5];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
              var update = hiddenUpdatesForLane[index$5];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root3.tag && (root3.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root3, spawnedLane, entangledLanes) {
        root3.pendingLanes |= spawnedLane;
        root3.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root3.entangledLanes |= spawnedLane;
        root3.entanglements[spawnedLaneIndex] = root3.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
      }
      function markRootEntangled(root3, entangledLanes) {
        var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
        for (root3 = root3.entanglements; rootEntangledLanes; ) {
          var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
          lane & entangledLanes | root3[index$6] & entangledLanes && (root3[index$6] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
      }
      function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority) return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
      }
      function runWithPriority(priority, fn) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          return ReactDOMSharedInternals.p = priority, fn();
        } finally {
          ReactDOMSharedInternals.p = previousPriority;
        }
      }
      var randomKey = Math.random().toString(36).slice(2);
      var internalInstanceKey = "__reactFiber$" + randomKey;
      var internalPropsKey = "__reactProps$" + randomKey;
      var internalContainerInstanceKey = "__reactContainer$" + randomKey;
      var internalEventHandlersKey = "__reactEvents$" + randomKey;
      var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
      var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
      var internalRootNodeResourcesKey = "__reactResources$" + randomKey;
      var internalHoistableMarker = "__reactMarker$" + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
            parentNode = targetInst.alternate;
            if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
              for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
                if (parentNode = targetNode[internalInstanceKey]) return parentNode;
                targetNode = getParentSuspenseInstance(targetNode);
              }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
          var tag = node.tag;
          if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
            return node;
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
        throw Error(formatProdErrorMessage(33));
      }
      function getResourcesFromRoot(root3) {
        var resources = root3[internalRootNodeResourcesKey];
        resources || (resources = root3[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
        return resources;
      }
      function markNodeAsHoistable(node) {
        node[internalHoistableMarker] = true;
      }
      var allNativeEvents = /* @__PURE__ */ new Set();
      var registrationNameDependencies = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] = dependencies;
        for (registrationName = 0; registrationName < dependencies.length; registrationName++)
          allNativeEvents.add(dependencies[registrationName]);
      }
      var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      );
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        return false;
      }
      function setValueForAttribute(node, name, value) {
        if (isAttributeNameSafe(name))
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                node.removeAttribute(name);
                return;
              case "boolean":
                var prefix$8 = name.toLowerCase().slice(0, 5);
                if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
                  node.removeAttribute(name);
                  return;
                }
            }
            node.setAttribute(name, "" + value);
          }
      }
      function setValueForKnownAttribute(node, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttribute(name, "" + value);
        }
      }
      function setValueForNamespacedAttribute(node, namespace, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttributeNS(namespace, name, "" + value);
        }
      }
      var prefix;
      var suffix;
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x3) {
            var match = x3.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x3.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x3.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      var reentry = false;
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x3) {
                      var control = x3;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$9) {
                      control = x$9;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$10) {
                    control = x$10;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
              RunInRootFrame++;
            for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
              for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
                namePropDescriptor--;
            for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
              if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                  do
                    if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                      var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                      fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                      return frame;
                    }
                  while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                }
                break;
              }
          }
        } finally {
          reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
        }
        return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
      }
      function describeFiber(fiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "";
          do
            info += describeFiber(workInProgress2), workInProgress2 = workInProgress2.return;
          while (workInProgress2);
          return info;
        } catch (x3) {
          return "\nError generating stack: " + x3.message + "\n" + x3.stack;
        }
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            return value;
          default:
            return "";
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
      }
      function trackValueOnNode(node) {
        var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        ), currentValue = "" + node[valueField];
        if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
          var get = descriptor.get, set = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get.call(this);
            },
            set: function(value) {
              currentValue = "" + value;
              set.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          return {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              currentValue = "" + value;
            },
            stopTracking: function() {
              node._valueTracker = null;
              delete node[valueField];
            }
          };
        }
      }
      function track(node) {
        node._valueTracker || (node._valueTracker = trackValueOnNode(node));
      }
      function updateValueIfChanged(node) {
        if (!node) return false;
        var tracker = node._valueTracker;
        if (!tracker) return true;
        var lastValue = tracker.getValue();
        var value = "";
        node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
        node = value;
        return node !== lastValue ? (tracker.setValue(node), true) : false;
      }
      function getActiveElement(doc) {
        doc = doc || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof doc) return null;
        try {
          return doc.activeElement || doc.body;
        } catch (e) {
          return doc.body;
        }
      }
      var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
      function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(
          escapeSelectorAttributeValueInsideDoubleQuotesRegex,
          function(ch) {
            return "\\" + ch.charCodeAt(0).toString(16) + " ";
          }
        );
      }
      function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
        element.name = "";
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
        if (null != value)
          if ("number" === type) {
            if (0 === value && "" === element.value || element.value != value)
              element.value = "" + getToStringValue(value);
          } else
            element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
        else
          "submit" !== type && "reset" !== type || element.removeAttribute("value");
        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
      }
      function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
        if (null != value || null != defaultValue) {
          if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
            return;
          defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
          value = null != value ? "" + getToStringValue(value) : defaultValue;
          isHydrating2 || value === element.value || (element.value = value);
          element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
        element.checked = isHydrating2 ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
      }
      function setDefaultValue(node, type, value) {
        "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        node = node.options;
        if (multiple) {
          multiple = {};
          for (var i = 0; i < propValue.length; i++)
            multiple["$" + propValue[i]] = true;
          for (propValue = 0; propValue < node.length; propValue++)
            i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
        } else {
          propValue = "" + getToStringValue(propValue);
          multiple = null;
          for (i = 0; i < node.length; i++) {
            if (node[i].value === propValue) {
              node[i].selected = true;
              setDefaultSelected && (node[i].defaultSelected = true);
              return;
            }
            null !== multiple || node[i].disabled || (multiple = node[i]);
          }
          null !== multiple && (multiple.selected = true);
        }
      }
      function updateTextarea(element, value, defaultValue) {
        if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
          element.defaultValue !== value && (element.defaultValue = value);
          return;
        }
        element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      }
      function initTextarea(element, value, defaultValue, children) {
        if (null == value) {
          if (null != children) {
            if (null != defaultValue) throw Error(formatProdErrorMessage(92));
            if (isArrayImpl(children)) {
              if (1 < children.length) throw Error(formatProdErrorMessage(93));
              children = children[0];
            }
            defaultValue = children;
          }
          null == defaultValue && (defaultValue = "");
          value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children = element.textContent;
        children === defaultValue && "" !== children && null !== children && (element.value = children);
      }
      function setTextContent(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      }
      var unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      );
      function setValueForStyle(style2, styleName, value) {
        var isCustomProperty = 0 === styleName.indexOf("--");
        null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
      }
      function setValueForStyles(node, styles, prevStyles) {
        if (null != styles && "object" !== typeof styles)
          throw Error(formatProdErrorMessage(62));
        node = node.style;
        if (null != prevStyles) {
          for (var styleName in prevStyles)
            !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
          for (var styleName$16 in styles)
            styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
        } else
          for (var styleName$17 in styles)
            styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
      }
      function isCustomElement(tagName) {
        if (-1 === tagName.indexOf("-")) return false;
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]);
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      var currentReplayingEvent = null;
      function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
      }
      var restoreTarget = null;
      var restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
          var props = target[internalPropsKey] || null;
          a: switch (target = internalInstance.stateNode, internalInstance.type) {
            case "input":
              updateInput(
                target,
                props.value,
                props.defaultValue,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name
              );
              internalInstance = props.name;
              if ("radio" === props.type && null != internalInstance) {
                for (props = target; props.parentNode; ) props = props.parentNode;
                props = props.querySelectorAll(
                  'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) + '"][type="radio"]'
                );
                for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                  var otherNode = props[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    var otherProps = otherNode[internalPropsKey] || null;
                    if (!otherProps) throw Error(formatProdErrorMessage(90));
                    updateInput(
                      otherNode,
                      otherProps.value,
                      otherProps.defaultValue,
                      otherProps.defaultValue,
                      otherProps.checked,
                      otherProps.defaultChecked,
                      otherProps.type,
                      otherProps.name
                    );
                  }
                }
                for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                  otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
              }
              break a;
            case "textarea":
              updateTextarea(target, props.value, props.defaultValue);
              break a;
            case "select":
              internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
          }
        }
      }
      var isInsideEventHandler = false;
      function batchedUpdates$1(fn, a, b2) {
        if (isInsideEventHandler) return fn(a, b2);
        isInsideEventHandler = true;
        try {
          var JSCompiler_inline_result = fn(a);
          return JSCompiler_inline_result;
        } finally {
          if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
            if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
              for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
          }
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode) return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props) return null;
        stateNode = props[registrationName];
        a: switch (registrationName) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
            inst = !props;
            break a;
          default:
            inst = false;
        }
        if (inst) return null;
        if (stateNode && "function" !== typeof stateNode)
          throw Error(
            formatProdErrorMessage(231, registrationName, typeof stateNode)
          );
        return stateNode;
      }
      var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var passiveBrowserEventsSupported = false;
      if (canUseDOM)
        try {
          options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      var options;
      var root2 = null;
      var startText = null;
      var fallbackText = null;
      function getData() {
        if (fallbackText) return fallbackText;
        var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root2 ? root2.value : root2.textContent, endLength = endValue.length;
        for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
        return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
      }
      function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var propName in Interface)
            Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
          this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
          },
          persist: function() {
          },
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      };
      var SyntheticEvent = createSyntheticEvent(EventInterface);
      var UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 });
      var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
      var lastMovementX;
      var lastMovementY;
      var lastMouseEvent;
      var MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function(event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      });
      var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
      var DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 });
      var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
      var FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 });
      var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
      var AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
      var ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      });
      var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
      var CompositionEventInterface = assign({}, EventInterface, { data: 0 });
      var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
      var normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
      }
      function getEventModifierState() {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      });
      var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
      var PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      });
      var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
      var TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      });
      var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
      var TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
      var WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
      var ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      });
      var SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface);
      var END_KEYCODES = [9, 13, 27, 32];
      var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
      var documentMode = null;
      canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
      var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode);
      var SPACEBAR_CHAR = String.fromCharCode(32);
      var hasSpaceKeypress = false;
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
          case "keydown":
            return 229 !== nativeEvent.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
      }
      var isComposing = false;
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            if (32 !== nativeEvent.which) return null;
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing)
          return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root2 = null, isComposing = false, domEventName) : null;
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
              if (nativeEvent.char && 1 < nativeEvent.char.length)
                return nativeEvent.char;
              if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
        inst = accumulateTwoPhaseListeners(inst, "onChange");
        0 < inst.length && (nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
      }
      var activeElement$1 = null;
      var activeElementInst$1 = null;
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ("change" === domEventName) return targetInst;
      }
      var isInputEventSupported = false;
      if (canUseDOM) {
        if (canUseDOM) {
          isSupported$jscomp$inline_417 = "oninput" in document;
          if (!isSupported$jscomp$inline_417) {
            element$jscomp$inline_418 = document.createElement("div");
            element$jscomp$inline_418.setAttribute("oninput", "return;");
            isSupported$jscomp$inline_417 = "function" === typeof element$jscomp$inline_418.oninput;
          }
          JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
        } else JSCompiler_inline_result$jscomp$282 = false;
        isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode);
      }
      var JSCompiler_inline_result$jscomp$282;
      var isSupported$jscomp$inline_417;
      var element$jscomp$inline_418;
      function stopWatchingForValueChange() {
        activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
      }
      function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(
            dispatchQueue,
            activeElementInst$1,
            nativeEvent,
            getEventTarget(nativeEvent)
          );
          batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName) {
        if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
          return getInstIfValueChanged(activeElementInst$1);
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if ("click" === domEventName) return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ("input" === domEventName || "change" === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function is(x3, y) {
        return x3 === y && (0 !== x3 || 1 / x3 === 1 / y) || x3 !== x3 && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function getLeafNode(node) {
        for (; node && node.firstChild; ) node = node.firstChild;
        return node;
      }
      function getNodeForCharacterOffset(root3, offset) {
        var node = getLeafNode(root3);
        root3 = 0;
        for (var nodeEnd; node; ) {
          if (3 === node.nodeType) {
            nodeEnd = root3 + node.textContent.length;
            if (root3 <= offset && nodeEnd >= offset)
              return { node, offset: offset - root3 };
            root3 = nodeEnd;
          }
          a: {
            for (; node; ) {
              if (node.nextSibling) {
                node = node.nextSibling;
                break a;
              }
              node = node.parentNode;
            }
            node = void 0;
          }
          node = getLeafNode(node);
        }
      }
      function containsNode(outerNode, innerNode) {
        return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
      }
      function getActiveElementDeep(containerInfo) {
        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
        for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
          try {
            var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
          } catch (err) {
            JSCompiler_inline_result = false;
          }
          if (JSCompiler_inline_result) containerInfo = element.contentWindow;
          else break;
          element = getActiveElement(containerInfo.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode;
      var activeElement = null;
      var activeElementInst = null;
      var lastSelection = null;
      var mouseDown = false;
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
        mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes["Webkit" + styleProp] = "webkit" + eventName;
        prefixes["Moz" + styleProp] = "moz" + eventName;
        return prefixes;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      var prefixedEventNames = {};
      var style = {};
      canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName], styleProp;
        for (styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
            return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend");
      var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
      var ANIMATION_START = getVendorPrefixedEventName("animationstart");
      var TRANSITION_RUN = getVendorPrefixedEventName("transitionrun");
      var TRANSITION_START = getVendorPrefixedEventName("transitionstart");
      var TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel");
      var TRANSITION_END = getVendorPrefixedEventName("transitionend");
      var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
      var simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
      simpleEventPluginEvents.push("scrollEnd");
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      var CapturedStacks = /* @__PURE__ */ new WeakMap();
      function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source = {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      var concurrentQueues = [];
      var concurrentQueuesIndex = 0;
      var concurrentlyUpdatedLanes = 0;
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
          var fiber = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var queue = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var update = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var lane = concurrentQueues[i];
          concurrentQueues[i++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (50 < nestedUpdateCount)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
        for (var parent = sourceFiber.return; null !== parent; )
          sourceFiber = parent, parent = sourceFiber.return;
        return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
      }
      var emptyContextObject = {};
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function createFiberImplClass(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
      }
      function createWorkInProgress(current, pendingProps) {
        var workInProgress2 = current.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
        workInProgress2.flags = current.flags & 65011712;
        workInProgress2.childLanes = current.childLanes;
        workInProgress2.lanes = current.lanes;
        workInProgress2.child = current.child;
        workInProgress2.memoizedProps = current.memoizedProps;
        workInProgress2.memoizedState = current.memoizedState;
        workInProgress2.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
        workInProgress2.sibling = current.sibling;
        workInProgress2.index = current.index;
        workInProgress2.ref = current.ref;
        workInProgress2.refCleanup = current.refCleanup;
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current = workInProgress2.alternate;
        null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext
        });
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0;
        owner = type;
        if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
        else if ("string" === typeof type)
          fiberTag = isHostHoistableType(
            type,
            pendingProps,
            contextStackCursor.current
          ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_TYPE:
              return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_LIST_TYPE:
              return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
            default:
              if ("object" === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    owner = null;
                    break a;
                }
              fiberTag = 29;
              pendingProps = Error(
                formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
              );
              owner = null;
          }
        key = createFiberImplClass(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = owner;
        key.lanes = lanes;
        return key;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiberImplClass(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode, lanes) {
        content = createFiberImplClass(6, content, null, mode);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiberImplClass(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode;
      }
      var forkStack = [];
      var forkStackIndex = 0;
      var treeForkProvider = null;
      var treeForkCount = 0;
      var idStack = [];
      var idStackIndex = 0;
      var treeContextProvider = null;
      var treeContextId = 1;
      var treeContextOverflow = "";
      function pushTreeFork(workInProgress2, totalChildren) {
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index2) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index2 += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress2;
        } else
          treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;
      var hydrationErrors = null;
      var rootOrSingletonContext = false;
      var HydrationMismatchException = Error(formatProdErrorMessage(519));
      function throwOnHydrationMismatch(fiber) {
        var error = Error(formatProdErrorMessage(418, ""));
        queueHydrationError(createCapturedValueAtFiber(error, fiber));
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber) {
        var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
        instance[internalInstanceKey] = fiber;
        instance[internalPropsKey] = props;
        switch (type) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", instance);
            listenToNonDelegatedEvent("close", instance);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", instance);
            break;
          case "video":
          case "audio":
            for (type = 0; type < mediaEventTypes.length; type++)
              listenToNonDelegatedEvent(mediaEventTypes[type], instance);
            break;
          case "source":
            listenToNonDelegatedEvent("error", instance);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", instance);
            listenToNonDelegatedEvent("load", instance);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", instance);
            break;
          case "input":
            listenToNonDelegatedEvent("invalid", instance);
            initInput(
              instance,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              true
            );
            track(instance);
            break;
          case "select":
            listenToNonDelegatedEvent("invalid", instance);
            break;
          case "textarea":
            listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
        }
        type = props.children;
        "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
        instance || throwOnHydrationMismatch(fiber);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return false;
        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag, JSCompiler_temp;
        if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
          if (JSCompiler_temp = 5 === tag)
            JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
          JSCompiler_temp = !JSCompiler_temp;
        }
        JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
        popToNextHostParent(fiber);
        if (13 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          a: {
            fiber = fiber.nextSibling;
            for (tag = 0; fiber; ) {
              if (8 === fiber.nodeType)
                if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
                  if (0 === tag) {
                    nextHydratableInstance = getNextHydratable(fiber.nextSibling);
                    break a;
                  }
                  tag--;
                } else
                  "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || tag++;
              fiber = fiber.nextSibling;
            }
            nextHydratableInstance = null;
          }
        } else
          27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
        return true;
      }
      function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        isHydrating = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error) {
        null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
      }
      var valueCursor = createCursor(null);
      var currentlyRenderingFiber$1 = null;
      var lastContextDependency = null;
      function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue);
        context._currentValue = nextValue;
      }
      function popProvider(context) {
        context._currentValue = valueCursor.current;
        pop(valueCursor);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0; i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(
                    list.return,
                    renderLanes2,
                    workInProgress2
                  );
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber) throw Error(formatProdErrorMessage(341));
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144)) break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current && propagateContextChanges(
          workInProgress2,
          current,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          if (!objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer) throw Error(formatProdErrorMessage(308));
          lastContextDependency = context;
          consumer.dependencies = { lanes: 0, firstContext: context };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners.forEach(function(listener) {
            return listener();
          });
        };
      };
      var scheduleCallback$2 = Scheduler.unstable_scheduleCallback;
      var NormalPriority = Scheduler.unstable_NormalPriority;
      var CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      };
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      var currentEntangledListeners = null;
      var currentEntangledPendingCount = 0;
      var currentEntangledLane = 0;
      var currentEntangledActionThenable = null;
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve) {
            listeners.push(resolve);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
          },
          function(error) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error;
            for (error = 0; error < listeners.length; error++)
              (0, listeners[error])(void 0);
          }
        );
        return thenableWithOverride;
      }
      var prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition, returnValue) {
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor(null);
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
      }
      var SuspenseException = Error(formatProdErrorMessage(460));
      var SuspenseyCommitException = Error(formatProdErrorMessage(474));
      var SuspenseActionException = Error(formatProdErrorMessage(542));
      var noopSuspenseyCommitThenable = { then: function() {
      } };
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function noop$3() {
      }
      function trackUsedThenable(thenableState2, thenable, index2) {
        index2 = thenableState2[index2];
        void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$3, noop$3), thenable = index2);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      var suspendedThenable = null;
      function getSuspendedThenable() {
        if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(formatProdErrorMessage(483));
      }
      var hasForceUpdate = false;
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current, workInProgress2) {
        current = current.updateQueue;
        workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
      }
      function createUpdate(lane) {
        return { lane, tag: 0, payload: null, callback: null, next: null };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (0 !== (executionContext & 2)) {
          var pending = updateQueue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          updateQueue.pending = update;
          update = getRootForUpdatedFiber(fiber);
          markUpdateLaneFromFiberToRoot(fiber, null, lane);
          return update;
        }
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root3, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root3.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root3, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
        if (null !== current && (current = current.updateQueue, queue === current)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current.shared,
            callbacks: current.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      var didReadFromEntangledAsyncAction = false;
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress$jscomp$0.updateQueue;
        hasForceUpdate = false;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current = workInProgress$jscomp$0.alternate;
          null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current && (current = current.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
                updateLane = props;
                var instance = instance$jscomp$0;
                switch (update.tag) {
                  case 1:
                    workInProgress2 = update.payload;
                    if ("function" === typeof workInProgress2) {
                      newState = workInProgress2.call(instance, newState, updateLane);
                      break a;
                    }
                    newState = workInProgress2;
                    break a;
                  case 3:
                    workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                  case 0:
                    workInProgress2 = update.payload;
                    updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                    if (null === updateLane || void 0 === updateLane) break a;
                    newState = assign({}, newState, updateLane);
                    break a;
                  case 2:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress$jscomp$0.lanes = lastBaseUpdate;
          workInProgress$jscomp$0.memoizedState = newState;
        }
      }
      function callCallback(callback, context) {
        if ("function" !== typeof callback)
          throw Error(formatProdErrorMessage(191, callback));
        callback.call(context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
            callCallback(callbacks[updateQueue], context);
      }
      var currentTreeHiddenStackCursor = createCursor(null);
      var prevEntangledRenderLanesCursor = createCursor(0);
      function pushHiddenContext(fiber, context) {
        fiber = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, fiber);
        push(currentTreeHiddenStackCursor, context);
        entangledRenderLanes = fiber | context.baseLanes;
      }
      function reuseHiddenContextOnStack() {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
      }
      function popHiddenContext() {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor);
        pop(prevEntangledRenderLanesCursor);
      }
      var renderLanes = 0;
      var currentlyRenderingFiber = null;
      var currentHook = null;
      var workInProgressHook = null;
      var didScheduleRenderPhaseUpdate = false;
      var didScheduleRenderPhaseUpdateDuringThisPass = false;
      var shouldDoubleInvokeUserFnsInHooksDEV = false;
      var localIdCounter = 0;
      var thenableIndexCounter$1 = 0;
      var thenableState$1 = null;
      var globalClientIdCounter = 0;
      function throwInvalidHookError() {
        throw Error(formatProdErrorMessage(321));
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (null === prevDeps) return false;
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i])) return false;
        return true;
      }
      function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        nextRenderLanes = Component(props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
          workInProgress2,
          Component,
          props,
          secondArg
        ));
        finishRenderingHooks(current);
        return nextRenderLanes;
      }
      function finishRenderingHooks(current) {
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter$1 = 0;
        thenableState$1 = null;
        if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
      }
      function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
          thenableIndexCounter$1 = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
          numberOfReRenders += 1;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children = workInProgress2.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          ReactSharedInternals.H = HooksDispatcherOnRerender;
          children = Component(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current, workInProgress2, lanes) {
        workInProgress2.updateQueue = current.updateQueue;
        workInProgress2.flags &= -2053;
        current.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter$1 = localIdCounter = 0;
        thenableState$1 = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(formatProdErrorMessage(467));
            throw Error(formatProdErrorMessage(310));
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index2 = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = []);
        thenable = trackUsedThenable(thenableState$1, thenable, index2);
        index2 = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error(formatProdErrorMessage(438, String(usable)));
      }
      function useMemoCache(size) {
        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current = currentlyRenderingFiber.alternate;
          null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
            data: current.data.map(function(array) {
              return array.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue)
          for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
            updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current, reducer) {
        var queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$32 = false;
          do {
            var updateLane = update.lane & -536870913;
            if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update = update.next;
          } while (null !== update && update !== current);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$32 && (reducer = currentEntangledActionThenable, null !== reducer)))
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer(newState, update.action), update = update.next;
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else getServerSnapshot = getSnapshot();
        var snapshotChanged = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        );
        snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
        hook = hook.queue;
        var create = subscribeToStore.bind(null, fiber, hook, subscribe);
        updateEffectImpl(2048, 8, create, [subscribe]);
        if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root3 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
      }
      function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState) {
          var initialStateInitializer = initialState;
          initialState = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        return hook;
      }
      function updateOptimisticImpl(hook, current, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer ? reducer : basicStateReducer
        );
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error) {
            onActionError(actionQueue, node, error);
          } finally {
            ReactSharedInternals.T = prevTransition;
          }
        } else
          try {
            prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
          } catch (error$38) {
            onActionError(actionQueue, node, error$38);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
          },
          function(error) {
            return onActionError(actionQueue, node, error);
          }
        ) : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var JSCompiler_inline_result = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  b: {
                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                    for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                      if (!inRootOrSingleton) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                      JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling
                      );
                      if (null === JSCompiler_inline_result$jscomp$0) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                    }
                    inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                    JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                  }
                  if (JSCompiler_inline_result$jscomp$0) {
                    nextHydratableInstance = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                    break a;
                  }
                }
                throwOnHydrationMismatch(JSCompiler_inline_result);
              }
              JSCompiler_inline_result = false;
            }
            JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = JSCompiler_inline_result;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result
        );
        JSCompiler_inline_result.dispatch = ssrFormState;
        JSCompiler_inline_result = mountStateImpl(false);
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          JSCompiler_inline_result.queue
        );
        JSCompiler_inline_result = mountWorkInProgressHook();
        JSCompiler_inline_result$jscomp$0 = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result$jscomp$0,
          inRootOrSingleton,
          ssrFormState
        );
        JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
        JSCompiler_inline_result.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x3) {
            if (x3 === SuspenseException) throw SuspenseActionException;
            throw x3;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          9,
          createEffectInstance(),
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch, false];
      }
      function pushSimpleEffect(tag, inst, create, createDeps) {
        tag = { tag, create, deps: createDeps, inst, next: null };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create = inst.lastEffect;
        null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
        return tag;
      }
      function createEffectInstance() {
        return { destroy: void 0, resource: void 0 };
      }
      function updateRef() {
        return updateWorkInProgressHook().memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
        var hook = mountWorkInProgressHook();
        createDeps = void 0 === createDeps ? null : createDeps;
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          createEffectInstance(),
          create,
          createDeps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          inst,
          create,
          deps
        ));
      }
      function mountEffect(create, createDeps) {
        mountEffectImpl(8390656, 8, create, createDeps);
      }
      function updateEffect(create, createDeps) {
        updateEffectImpl(2048, 8, create, createDeps);
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(4, 2, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(4, 4, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if ("function" === typeof ref) {
          create = create();
          var refCleanup = ref(create);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return create = create(), ref.current = create, function() {
            ref.current = null;
          };
      }
      function updateImperativeHandle(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
      }
      function mountDebugValue() {
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        try {
          var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error },
            requestUpdateLane()
          );
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function noop$2() {
      }
      function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          sharedNotPendingObject,
          null === action ? noop$2 : function() {
            requestFormReset$1(formFiber);
            return action(formData);
          }
        );
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: sharedNotPendingObject,
          baseState: sharedNotPendingObject,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: sharedNotPendingObject
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function requestFormReset$1(formFiber) {
        var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
        dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function updateId() {
        return updateWorkInProgressHook().memoizedState;
      }
      function updateRefresh() {
        return updateWorkInProgressHook().memoizedState;
      }
      function refreshCache(fiber) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane();
              fiber = createUpdate(lane);
              var root$41 = enqueueUpdate(provider, fiber, lane);
              null !== root$41 && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane));
              provider = { cache: createCache() };
              fiber.payload = provider;
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var lane = requestUpdateLane();
        action = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
      }
      function dispatchSetState(fiber, queue, action) {
        var lane = requestUpdateLane();
        dispatchSetStateInternal(fiber, queue, action, lane);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update.hasEagerState = true;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error) {
            } finally {
            }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      function entangleTransitionUpdate(root3, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root3.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root3, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      };
      var HooksDispatcherOnMount = {
        readContext,
        use,
        useCallback: function(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function(ref, create, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          mountEffectImpl(
            4194308,
            4,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        },
        useLayoutEffect: function(create, deps) {
          return mountEffectImpl(4194308, 4, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          mountEffectImpl(4, 2, create, deps);
        },
        useMemo: function(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        },
        useReducer: function(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        },
        useRef: function(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        },
        useState: function(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        },
        useTransition: function() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else {
            getServerSnapshot = getSnapshot();
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          hook.memoizedState = getServerSnapshot;
          var inst = { value: getServerSnapshot, getSnapshot };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
            subscribe
          ]);
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              inst,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          return getServerSnapshot;
        },
        useId: function() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
            identifierPrefix = "«" + identifierPrefix + "R" + JSCompiler_inline_result;
            JSCompiler_inline_result = localIdCounter++;
            0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
            identifierPrefix += "»";
          } else
            JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "«" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "»";
          return hook.memoizedState = identifierPrefix;
        },
        useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        },
        useMemoCache,
        useCacheRefresh: function() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
      };
      var HooksDispatcherOnUpdate = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef,
        useState: function() {
          return updateReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      var HooksDispatcherOnRerender = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: rerenderReducer,
        useRef: updateRef,
        useState: function() {
          return rerenderReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: rerenderActionState,
        useActionState: rerenderActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      var thenableState = null;
      var thenableIndexCounter = 0;
      function unwrapThenable(thenable) {
        var index2 = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index2);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(formatProdErrorMessage(525));
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
          )
        );
      }
      function resolveLazy(lazyType) {
        var init = lazyType._init;
        return init(lazyType._payload);
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
          if (null === current || 6 !== current.tag)
            return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, textContent);
          current.return = returnFiber;
          return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            );
          if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
            return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
          current = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            null,
            returnFiber.mode,
            lanes
          );
          coerceRef(current, element);
          current.return = returnFiber;
          return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
          if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
            return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, portal.children || []);
          current.return = returnFiber;
          return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
          if (null === current || 7 !== current.tag)
            return current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current.return = returnFiber, current;
          current = useFiber(current, fragment);
          current.return = returnFiber;
          return current;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild;
              case REACT_LAZY_TYPE:
                var init = newChild._init;
                newChild = init(newChild._payload);
                return createChild(returnFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newChild = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), newChild.return = returnFiber, newChild;
            if ("function" === typeof newChild.then)
              return createChild(returnFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                var init = newChild._init;
                newChild = init(newChild._payload);
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren) throw Error(formatProdErrorMessage(151));
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
                }
                return placeSingleChild(returnFiber);
              case REACT_PORTAL_TYPE:
                a: {
                  for (key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.children || []);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild))
              return reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            if (getIteratorFn(newChild)) {
              key = getIteratorFn(newChild);
              if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
              newChild = key.call(newChild);
              return reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            }
            if ("function" === typeof newChild.then)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          try {
            thenableIndexCounter = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState = null;
            return firstChildFiber;
          } catch (x3) {
            if (x3 === SuspenseException || x3 === SuspenseActionException) throw x3;
            var fiber = createFiberImplClass(29, x3, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            return fiber;
          } finally {
          }
        };
      }
      var reconcileChildFibers = createChildReconciler(true);
      var mountChildFibers = createChildReconciler(false);
      var suspenseHandlerStackCursor = createCursor(null);
      var shellBoundary = null;
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & 1);
        push(suspenseHandlerStackCursor, handler);
        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
      }
      function pushOffscreenSuspenseHandler(fiber) {
        if (22 === fiber.tag) {
          if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
            var current = fiber.alternate;
            null !== current && null !== current.memoizedState && (shellBoundary = fiber);
          }
        } else reuseSuspenseHandlerOnStack(fiber);
      }
      function reuseSuspenseHandlerOnStack() {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor);
      }
      var suspenseStackCursor = createCursor(0);
      function findFirstSuspended(row) {
        for (var node = row; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || isSuspenseInstanceFallback(state)))
              return node;
          } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
            if (0 !== (node.flags & 128)) return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row) return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        ctor = workInProgress2.memoizedState;
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
        getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
        workInProgress2.memoizedState = getDerivedStateFromProps;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
      }
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 1;
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function(inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 2;
          void 0 !== callback && null !== callback && (update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        workInProgress2 = workInProgress2.stateNode;
        return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        workInProgress2 = instance.state;
        "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
      function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component = Component.defaultProps) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var propName$73 in Component)
            void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
        }
        return newProps;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      function defaultOnUncaughtError(error) {
        reportGlobalError(error);
      }
      function defaultOnCaughtError(error) {
        console.error(error);
      }
      function defaultOnRecoverableError(error) {
        reportGlobalError(error);
      }
      function logUncaughtError(root3, errorInfo) {
        try {
          var onUncaughtError = root3.onUncaughtError;
          onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
        } catch (e$74) {
          setTimeout(function() {
            throw e$74;
          });
        }
      }
      function logCaughtError(root3, boundary, errorInfo) {
        try {
          var onCaughtError = root3.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e$75) {
          setTimeout(function() {
            throw e$75;
          });
        }
      }
      function createRootErrorUpdate(root3, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        lane.payload = { element: null };
        lane.callback = function() {
          logUncaughtError(root3, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        return lane;
      }
      function initializeClassErrorUpdate(update, root3, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error);
          };
          update.callback = function() {
            logCaughtError(root3, fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
          logCaughtError(root3, fiber, errorInfo);
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          var stack = errorInfo.stack;
          this.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        });
      }
      function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root3, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root3, value, rootRenderLanes)), false;
            }
            throw Error(formatProdErrorMessage(435, sourceFiber.tag));
          }
          attachPingListener(root3, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root3 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root3, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
            cause: value
          }), queueHydrationError(
            createCapturedValueAtFiber(returnFiber, sourceFiber)
          )), root3 = root3.current.alternate, root3.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root3.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root3.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root3, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
        var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
        4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
        if (null === returnFiber) return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root3 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root3, root3 = createRootErrorUpdate(sourceFiber.stateNode, value, root3), enqueueCapturedUpdate(sourceFiber, root3), false;
            case 1:
              if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root3,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      var SelectiveHydrationException = Error(formatProdErrorMessage(461));
      var didReceiveUpdate = false;
      function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
        Component = Component.render;
        var ref = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        nextProps = renderWithHooks(
          current,
          workInProgress2,
          Component,
          propsWithoutRef,
          ref,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null === current) {
          var type = Component.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
            return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
              current,
              workInProgress2,
              type,
              nextProps,
              renderLanes2
            );
          current = createFiberFromTypeAndProps(
            Component.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current.ref = workInProgress2.ref;
          current.return = workInProgress2;
          return workInProgress2.child = current;
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component = Component.compare;
          Component = null !== Component ? Component : shallowEqual;
          if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        workInProgress2.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null !== current) {
          var prevProps = current.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
              0 !== (current.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current,
          workInProgress2,
          Component,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current) {
              nextChildren = workInProgress2.child = current.child;
              for (prevState = 0; null !== nextChildren; )
                prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
              workInProgress2.childLanes = prevState & ~nextProps;
            } else workInProgress2.childLanes = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              nextProps,
              renderLanes2
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress2));
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack();
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
        return null;
      }
      function markRef(current, workInProgress2) {
        var ref = workInProgress2.ref;
        if (null === ref)
          null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref && "object" !== typeof ref)
            throw Error(formatProdErrorMessage(284));
          if (null === current || current.ref !== ref)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        Component = renderWithHooks(
          current,
          workInProgress2,
          Component,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, Component, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current);
        Component = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && Component && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          var context = emptyContextObject, contextType = Component.contextType;
          "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
          context = new Component(nextProps, context);
          workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          context.updater = classComponentUpdater;
          workInProgress2.stateNode = context;
          context._reactInternals = workInProgress2;
          context = workInProgress2.stateNode;
          context.props = nextProps;
          context.state = workInProgress2.memoizedState;
          context.refs = {};
          initializeUpdateQueue(workInProgress2);
          contextType = Component.contextType;
          context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
          context.state = workInProgress2.memoizedState;
          contextType = Component.getDerivedStateFromProps;
          "function" === typeof contextType && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            contextType,
            nextProps
          ), context.state = workInProgress2.memoizedState);
          "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
          "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
          nextProps = true;
        } else if (null === current) {
          context = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
          context.props = oldProps;
          var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
          contextType = emptyContextObject;
          "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;
          contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            contextType
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            getDerivedStateFromProps,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
        } else {
          context = workInProgress2.stateNode;
          cloneUpdateQueue(current, workInProgress2);
          contextType = workInProgress2.memoizedProps;
          contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
          context.props = contextType$jscomp$0;
          getDerivedStateFromProps = workInProgress2.pendingProps;
          oldState = context.context;
          oldContext = Component.contextType;
          oldProps = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
          unresolvedOldProps = Component.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            oldProps
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            oldProps
          )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
        }
        context = nextProps;
        markRef(current, workInProgress2);
        nextProps = 0 !== (workInProgress2.flags & 128);
        context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          Component,
          renderLanes2
        )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress2,
          renderLanes2
        );
        return current;
      }
      function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
        current = null !== current ? current.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
      }
      function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
        JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
        JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current) {
          if (isHydrating) {
            showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
            if (isHydrating) {
              var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
              if (JSCompiler_temp$jscomp$0 = nextInstance) {
                c: {
                  JSCompiler_temp$jscomp$0 = nextInstance;
                  for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType; ) {
                    if (!nextInstance) {
                      nextInstance = null;
                      break c;
                    }
                    JSCompiler_temp$jscomp$0 = getNextHydratable(
                      JSCompiler_temp$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_temp$jscomp$0) {
                      nextInstance = null;
                      break c;
                    }
                  }
                  nextInstance = JSCompiler_temp$jscomp$0;
                }
                null !== nextInstance ? (workInProgress2.memoizedState = {
                  dehydrated: nextInstance,
                  treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                  retryLane: 536870912,
                  hydrationErrors: null
                }, JSCompiler_temp$jscomp$0 = createFiberImplClass(
                  18,
                  null,
                  null,
                  0
                ), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress2, workInProgress2.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
              }
              JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress2);
            }
            nextInstance = workInProgress2.memoizedState;
            if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
              return isSuspenseInstanceFallback(nextInstance) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
            popSuspenseHandler(workInProgress2);
          }
          nextInstance = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextInstance },
              showFallback
            ), nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes2,
              null
            ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
        }
        JSCompiler_temp$jscomp$0 = current.memoizedState;
        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              nextInstance
            ), showFallback = createFiberFromFragment(
              showFallback,
              nextInstance,
              renderLanes2,
              null
            ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
              workInProgress2,
              current.child,
              null,
              renderLanes2
            ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextInstance)) {
            JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
            if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
            JSCompiler_temp = digest;
            nextProps = Error(formatProdErrorMessage(419));
            nextProps.stack = "";
            nextProps.digest = JSCompiler_temp;
            queueHydrationError({ value: nextProps, source: null, stack: null });
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
            JSCompiler_temp = workInProgressRoot;
            if (null !== JSCompiler_temp && (nextProps = renderLanes2 & -renderLanes2, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane))
              throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
            "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            "$?" === nextInstance.data ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(
              nextInstance.nextSibling
            ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
              workInProgress2,
              nextProps.children
            ), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
        if (showFallback)
          return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
            mode: "hidden",
            children: nextProps.children
          }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(
            showFallback,
            nextInstance,
            renderLanes2,
            null
          ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? { parent: digest, pool: digest } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
            baseLanes: nextInstance.baseLanes | renderLanes2,
            cachePool: JSCompiler_temp$jscomp$0
          }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current.child;
        current = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: nextProps.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        offscreenProps.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        };
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current.flags |= 2;
        workInProgress2.memoizedState = null;
        return current;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
      }
      function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        reconcileChildren(current, workInProgress2, nextProps.children, renderLanes2);
        nextProps = suspenseStackCursor.current;
        if (0 !== (nextProps & 2))
          nextProps = nextProps & 1 | 2, workInProgress2.flags |= 128;
        else {
          if (null !== current && 0 !== (current.flags & 128))
            a: for (current = workInProgress2.child; null !== current; ) {
              if (13 === current.tag)
                null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (19 === current.tag)
                scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (null !== current.child) {
                current.child.return = current;
                current = current.child;
                continue;
              }
              if (current === workInProgress2) break a;
              for (; null === current.sibling; ) {
                if (null === current.return || current.return === workInProgress2)
                  break a;
                current = current.return;
              }
              current.sibling.return = current.return;
              current = current.sibling;
            }
          nextProps &= 1;
        }
        push(suspenseStackCursor, nextProps);
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode
            );
            break;
          case "backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current = revealOrder.alternate;
              if (null !== current && null === findFirstSuspended(current)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode
            );
            break;
          case "together":
            initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
        null !== current && (workInProgress2.dependencies = current.dependencies);
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current) {
            if (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else return null;
        if (null !== current && workInProgress2.child !== current.child)
          throw Error(formatProdErrorMessage(153));
        if (null !== workInProgress2.child) {
          current = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current, current.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current.sibling; )
            current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current, renderLanes2) {
        if (0 !== (current.lanes & renderLanes2)) return true;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 13:
            var state = workInProgress2.memoizedState;
            if (null !== state) {
              if (null !== state.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(current, workInProgress2, renderLanes2);
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              return null !== current ? current.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current.flags & 128);
            state = 0 !== (renderLanes2 & workInProgress2.childLanes);
            state || (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), state = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (state)
                return updateSuspenseListComponent(
                  current,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(suspenseStackCursor, suspenseStackCursor.current);
            if (state) break;
            else return null;
          case 22:
          case 23:
            return workInProgress2.lanes = 0, updateOffscreenComponent(current, workInProgress2, renderLanes2);
          case 24:
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      function beginWork(current, workInProgress2, renderLanes2) {
        if (null !== current)
          if (current.memoizedProps !== workInProgress2.pendingProps)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
          }
        else
          didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: {
              current = workInProgress2.pendingProps;
              var lazyComponent = workInProgress2.elementType, init = lazyComponent._init;
              lazyComponent = init(lazyComponent._payload);
              workInProgress2.type = lazyComponent;
              if ("function" === typeof lazyComponent)
                shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                ));
              else {
                if (void 0 !== lazyComponent && null !== lazyComponent) {
                  if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      lazyComponent,
                      current,
                      renderLanes2
                    );
                    break a;
                  } else if (init === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      lazyComponent,
                      current,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = getComponentNameFromType(lazyComponent) || lazyComponent;
                throw Error(formatProdErrorMessage(306, workInProgress2, ""));
              }
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return lazyComponent = workInProgress2.type, init = resolveClassComponentProps(
              lazyComponent,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current,
              workInProgress2,
              lazyComponent,
              init,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current) throw Error(formatProdErrorMessage(387));
              lazyComponent = workInProgress2.pendingProps;
              var prevState = workInProgress2.memoizedState;
              init = prevState.element;
              cloneUpdateQueue(current, workInProgress2);
              processUpdateQueue(workInProgress2, lazyComponent, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              lazyComponent = nextState.cache;
              pushProvider(workInProgress2, CacheContext, lazyComponent);
              lazyComponent !== prevState.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              lazyComponent = nextState.element;
              if (prevState.isDehydrated)
                if (prevState = {
                  element: lazyComponent,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    lazyComponent,
                    renderLanes2
                  );
                  break a;
                } else if (lazyComponent !== init) {
                  init = createCapturedValueAtFiber(
                    Error(formatProdErrorMessage(424)),
                    workInProgress2
                  );
                  queueHydrationError(init);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    lazyComponent,
                    renderLanes2
                  );
                  break a;
                } else {
                  current = workInProgress2.stateNode.containerInfo;
                  switch (current.nodeType) {
                    case 9:
                      current = current.body;
                      break;
                    default:
                      current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                  }
                  nextHydratableInstance = getNextHydratable(current.firstChild);
                  hydrationParentFiber = workInProgress2;
                  isHydrating = true;
                  hydrationErrors = null;
                  rootOrSingletonContext = true;
                  renderLanes2 = mountChildFibers(
                    workInProgress2,
                    null,
                    lazyComponent,
                    renderLanes2
                  );
                  for (workInProgress2.child = renderLanes2; renderLanes2; )
                    renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                }
              else {
                resetHydrationState();
                if (lazyComponent === init) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(
                  current,
                  workInProgress2,
                  lazyComponent,
                  renderLanes2
                );
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
              workInProgress2.type,
              null,
              workInProgress2.pendingProps,
              null
            )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            ).createElement(renderLanes2), lazyComponent[internalInstanceKey] = workInProgress2, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes2, current), markNodeAsHoistable(lazyComponent), workInProgress2.stateNode = lazyComponent) : workInProgress2.memoizedState = getResource(
              workInProgress2.type,
              current.memoizedProps,
              workInProgress2.pendingProps,
              current.memoizedState
            ), null;
          case 27:
            return pushHostContext(workInProgress2), null === current && isHydrating && (lazyComponent = workInProgress2.stateNode = resolveSingletonInstance(
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootInstanceStackCursor.current
            ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, init = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = init, nextHydratableInstance = getNextHydratable(
              lazyComponent.firstChild
            )) : nextHydratableInstance = init), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            if (null === current && isHydrating) {
              if (init = lazyComponent = nextHydratableInstance)
                lazyComponent = canHydrateInstance(
                  lazyComponent,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== lazyComponent ? (workInProgress2.stateNode = lazyComponent, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                  lazyComponent.firstChild
                ), rootOrSingletonContext = false, init = true) : init = false;
              init || throwOnHydrationMismatch(workInProgress2);
            }
            pushHostContext(workInProgress2);
            init = workInProgress2.type;
            prevState = workInProgress2.pendingProps;
            nextState = null !== current ? current.memoizedProps : null;
            lazyComponent = prevState.children;
            shouldSetTextContent(init, prevState) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress2.flags |= 32);
            null !== workInProgress2.memoizedState && (init = renderWithHooks(
              current,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), HostTransitionContext._currentValue = init);
            markRef(current, workInProgress2);
            reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2);
            return workInProgress2.child;
          case 6:
            if (null === current && isHydrating) {
              if (current = renderLanes2 = nextHydratableInstance)
                renderLanes2 = canHydrateTextInstance(
                  renderLanes2,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
              current || throwOnHydrationMismatch(workInProgress2);
            }
            return null;
          case 13:
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), lazyComponent = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              lazyComponent,
              renderLanes2
            ) : reconcileChildren(
              current,
              workInProgress2,
              lazyComponent,
              renderLanes2
            ), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return lazyComponent = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, lazyComponent.value), reconcileChildren(
              current,
              workInProgress2,
              lazyComponent.children,
              renderLanes2
            ), workInProgress2.child;
          case 9:
            return init = workInProgress2.type._context, lazyComponent = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
          case 31:
            return lazyComponent = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, lazyComponent = {
              mode: lazyComponent.mode,
              children: lazyComponent.children
            }, null === current ? (renderLanes2 = mountWorkInProgressOffscreenFiber(
              lazyComponent,
              renderLanes2
            ), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2) : (renderLanes2 = createWorkInProgress(current.child, lazyComponent), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2), workInProgress2;
          case 22:
            return updateOffscreenComponent(current, workInProgress2, renderLanes2);
          case 24:
            return prepareToReadContext(workInProgress2), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, prevState = createCache(), init.pooledCache = prevState, prevState.refCount++, null !== prevState && (init.pooledCacheLanes |= renderLanes2), init = prevState), workInProgress2.memoizedState = {
              parent: lazyComponent,
              cache: init
            }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, init)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, prevState = workInProgress2.memoizedState, init.parent !== lazyComponent ? (init = { parent: lazyComponent, cache: lazyComponent }, workInProgress2.memoizedState = init, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = init), pushProvider(workInProgress2, CacheContext, lazyComponent)) : (lazyComponent = prevState.cache, pushProvider(workInProgress2, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
          workInProgress2.flags &= -16777217;
        else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
          resource = suspenseHandlerStackCursor.current;
          if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
          workInProgress2.flags |= 8192;
        }
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var lastTailNode$113 = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === lastTailNode$113 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$113.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          for (var child$114 = completedWork.child; null !== child$114; )
            newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags & 65011712, subtreeFlags |= child$114.flags & 65011712, child$114.return = completedWork, child$114 = child$114.sibling;
        else
          for (child$114 = completedWork.child; null !== child$114; )
            newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags, subtreeFlags |= child$114.flags, child$114.return = completedWork, child$114 = child$114.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 31:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current && (newProps = current.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext);
            popHostContainer();
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current || null === current.child)
              popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            return renderLanes2 = workInProgress2.memoizedState, null === current ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
          case 27:
            popHostContext(workInProgress2);
            renderLanes2 = rootInstanceStackCursor.current;
            var type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 5:
            popHostContext(workInProgress2);
            renderLanes2 = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              if (popHydrationState(workInProgress2))
                prepareToHydrateHostInstance(workInProgress2, current);
              else {
                type = getOwnerDocumentFromRootContainer(
                  rootInstanceStackCursor.current
                );
                switch (current) {
                  case 1:
                    current = type.createElementNS(
                      "http://www.w3.org/2000/svg",
                      renderLanes2
                    );
                    break;
                  case 2:
                    current = type.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      renderLanes2
                    );
                    break;
                  default:
                    switch (renderLanes2) {
                      case "svg":
                        current = type.createElementNS(
                          "http://www.w3.org/2000/svg",
                          renderLanes2
                        );
                        break;
                      case "math":
                        current = type.createElementNS(
                          "http://www.w3.org/1998/Math/MathML",
                          renderLanes2
                        );
                        break;
                      case "script":
                        current = type.createElement("div");
                        current.innerHTML = "<script><\/script>";
                        current = current.removeChild(current.firstChild);
                        break;
                      case "select":
                        current = "string" === typeof newProps.is ? type.createElement("select", { is: newProps.is }) : type.createElement("select");
                        newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
                        break;
                      default:
                        current = "string" === typeof newProps.is ? type.createElement(renderLanes2, { is: newProps.is }) : type.createElement(renderLanes2);
                    }
                }
                current[internalInstanceKey] = workInProgress2;
                current[internalPropsKey] = newProps;
                a: for (type = workInProgress2.child; null !== type; ) {
                  if (5 === type.tag || 6 === type.tag)
                    current.appendChild(type.stateNode);
                  else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
                    type.child.return = type;
                    type = type.child;
                    continue;
                  }
                  if (type === workInProgress2) break a;
                  for (; null === type.sibling; ) {
                    if (null === type.return || type.return === workInProgress2)
                      break a;
                    type = type.return;
                  }
                  type.sibling.return = type.return;
                  type = type.sibling;
                }
                workInProgress2.stateNode = current;
                a: switch (setInitialProperties(current, renderLanes2, newProps), renderLanes2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    current = !!newProps.autoFocus;
                    break a;
                  case "img":
                    current = true;
                    break a;
                  default:
                    current = false;
                }
                current && markUpdate(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            workInProgress2.flags &= -16777217;
            return null;
          case 6:
            if (current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              current = rootInstanceStackCursor.current;
              if (popHydrationState(workInProgress2)) {
                current = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                newProps = null;
                type = hydrationParentFiber;
                if (null !== type)
                  switch (type.tag) {
                    case 27:
                    case 5:
                      newProps = type.memoizedProps;
                  }
                current[internalInstanceKey] = workInProgress2;
                current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
                current || throwOnHydrationMismatch(workInProgress2);
              } else
                current = getOwnerDocumentFromRootContainer(current).createTextNode(
                  newProps
                ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
              type = popHydrationState(workInProgress2);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current) {
                  if (!type) throw Error(formatProdErrorMessage(318));
                  type = workInProgress2.memoizedState;
                  type = null !== type ? type.dehydrated : null;
                  if (!type) throw Error(formatProdErrorMessage(317));
                  type[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                type = false;
              } else
                type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
              if (!type) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, workInProgress2;
            renderLanes2 = null !== newProps;
            current = null !== current && null !== current.memoizedState;
            if (renderLanes2) {
              newProps = workInProgress2.child;
              type = null;
              null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
              var cache$127 = null;
              null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$127 = newProps.memoizedState.cachePool.pool);
              cache$127 !== type && (newProps.flags |= 2048);
            }
            renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            return null;
          case 4:
            return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor);
            type = workInProgress2.memoizedState;
            if (null === type) return bubbleProperties(workInProgress2), null;
            newProps = 0 !== (workInProgress2.flags & 128);
            cache$127 = type.rendering;
            if (null === cache$127)
              if (newProps) cutOffTailIfNeeded(type, false);
              else {
                if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                  for (current = workInProgress2.child; null !== current; ) {
                    cache$127 = findFirstSuspended(current);
                    if (null !== cache$127) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(type, false);
                      current = cache$127.updateQueue;
                      workInProgress2.updateQueue = current;
                      scheduleRetryEffect(workInProgress2, current);
                      workInProgress2.subtreeFlags = 0;
                      current = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & 1 | 2
                      );
                      return workInProgress2.child;
                    }
                    current = current.sibling;
                  }
                null !== type.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!newProps)
                if (current = findFirstSuspended(cache$127), null !== current) {
                  if (workInProgress2.flags |= 128, newProps = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !cache$127.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
              type.isBackwards ? (cache$127.sibling = workInProgress2.child, workInProgress2.child = cache$127) : (current = type.last, null !== current ? current.sibling = cache$127 : workInProgress2.child = cache$127, type.last = cache$127);
            }
            if (null !== type.tail)
              return workInProgress2 = type.tail, type.rendering = workInProgress2, type.tail = workInProgress2.sibling, type.renderingStartTime = now(), workInProgress2.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress2;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
          case 24:
            return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function unwindWork(current, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 3:
            return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current = workInProgress2.memoizedState;
            if (null !== current && null !== current.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor), null;
          case 4:
            return popHostContainer(), null;
          case 10:
            return popProvider(workInProgress2.type), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 24:
            return popProvider(CacheContext), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext);
            popHostContainer();
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer();
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor);
            break;
          case 10:
            popProvider(interruptedWork.type);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext();
            null !== current && pop(resumedCache);
            break;
          case 24:
            popProvider(CacheContext);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                lastEffect = void 0;
                var create = updateQueue.create, inst = updateQueue.inst;
                lastEffect = create();
                inst.destroy = lastEffect;
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst, destroy = inst.destroy;
                if (void 0 !== destroy) {
                  inst.destroy = void 0;
                  lastEffect = finishedWork;
                  var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                  try {
                    destroy_();
                  } catch (error) {
                    captureCommitPhaseError(
                      lastEffect,
                      nearestMountedAncestor,
                      error
                    );
                  }
                }
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance = finishedWork.stateNode;
          try {
            commitCallbacks(updateQueue, instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(
          current.type,
          current.memoizedProps
        );
        instance.state = current.memoizedState;
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyAttachRef(current, nearestMountedAncestor) {
        try {
          var ref = current.ref;
          if (null !== ref) {
            switch (current.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = current.stateNode;
                break;
              case 30:
                instanceToUse = current.stateNode;
                break;
              default:
                instanceToUse = current.stateNode;
            }
            "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
          }
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyDetachRef(current, nearestMountedAncestor) {
        var ref = current.ref, refCleanup = current.refCleanup;
        if (null !== ref)
          if ("function" === typeof refCleanup)
            try {
              refCleanup();
            } catch (error) {
              captureCommitPhaseError(current, nearestMountedAncestor, error);
            } finally {
              current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
            }
          else if ("function" === typeof ref)
            try {
              ref(null);
            } catch (error$143) {
              captureCommitPhaseError(current, nearestMountedAncestor, error$143);
            }
          else ref.current = null;
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
        try {
          a: switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              props.autoFocus && instance.focus();
              break a;
            case "img":
              props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          var domElement = finishedWork.stateNode;
          updateProperties(domElement, finishedWork.type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a: for (; ; ) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
          for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
          for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
            singleton.removeAttributeNode(attributes[0]);
          setInitialProperties(singleton, type, props);
          singleton[internalInstanceKey] = finishedWork;
          singleton[internalPropsKey] = props;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      var offscreenSubtreeIsHidden = false;
      var offscreenSubtreeWasHidden = false;
      var needsFormReset = false;
      var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
      var nextEffect = null;
      function commitBeforeMutationEffects(root3, firstChild) {
        root3 = root3.containerInfo;
        eventsEnabled = _enabled;
        root3 = getActiveElementDeep(root3);
        if (hasSelectionCapabilities(root3)) {
          if ("selectionStart" in root3)
            var JSCompiler_temp = {
              start: root3.selectionStart,
              end: root3.selectionEnd
            };
          else
            a: {
              JSCompiler_temp = (JSCompiler_temp = root3.ownerDocument) && JSCompiler_temp.defaultView || window;
              var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
              if (selection && 0 !== selection.rangeCount) {
                JSCompiler_temp = selection.anchorNode;
                var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                selection = selection.focusOffset;
                try {
                  JSCompiler_temp.nodeType, focusNode.nodeType;
                } catch (e$20) {
                  JSCompiler_temp = null;
                  break a;
                }
                var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root3, parentNode = null;
                b: for (; ; ) {
                  for (var next; ; ) {
                    node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                    node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                    3 === node.nodeType && (length += node.nodeValue.length);
                    if (null === (next = node.firstChild)) break;
                    parentNode = node;
                    node = next;
                  }
                  for (; ; ) {
                    if (node === root3) break b;
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                    parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                    if (null !== (next = node.nextSibling)) break;
                    node = parentNode;
                    parentNode = node.parentNode;
                  }
                  node = next;
                }
                JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
              } else JSCompiler_temp = null;
            }
          JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
        } else JSCompiler_temp = null;
        selectionInformation = { focusedElem: root3, selectionRange: JSCompiler_temp };
        _enabled = false;
        for (nextEffect = firstChild; null !== nextEffect; )
          if (firstChild = nextEffect, root3 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root3)
            root3.return = firstChild, nextEffect = root3;
          else
            for (; null !== nextEffect; ) {
              firstChild = nextEffect;
              focusNode = firstChild.alternate;
              root3 = firstChild.flags;
              switch (firstChild.tag) {
                case 0:
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if (0 !== (root3 & 1024) && null !== focusNode) {
                    root3 = void 0;
                    JSCompiler_temp = firstChild;
                    anchorOffset = focusNode.memoizedProps;
                    focusNode = focusNode.memoizedState;
                    selection = JSCompiler_temp.stateNode;
                    try {
                      var resolvedPrevProps = resolveClassComponentProps(
                        JSCompiler_temp.type,
                        anchorOffset,
                        JSCompiler_temp.elementType === JSCompiler_temp.type
                      );
                      root3 = selection.getSnapshotBeforeUpdate(
                        resolvedPrevProps,
                        focusNode
                      );
                      selection.__reactInternalSnapshotBeforeUpdate = root3;
                    } catch (error) {
                      captureCommitPhaseError(
                        JSCompiler_temp,
                        JSCompiler_temp.return,
                        error
                      );
                    }
                  }
                  break;
                case 3:
                  if (0 !== (root3 & 1024)) {
                    if (root3 = firstChild.stateNode.containerInfo, JSCompiler_temp = root3.nodeType, 9 === JSCompiler_temp)
                      clearContainerSparingly(root3);
                    else if (1 === JSCompiler_temp)
                      switch (root3.nodeName) {
                        case "HEAD":
                        case "HTML":
                        case "BODY":
                          clearContainerSparingly(root3);
                          break;
                        default:
                          root3.textContent = "";
                      }
                  }
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (root3 & 1024)) throw Error(formatProdErrorMessage(163));
              }
              root3 = firstChild.sibling;
              if (null !== root3) {
                root3.return = firstChild.return;
                nextEffect = root3;
                break;
              }
              nextEffect = firstChild.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookEffectListMount(5, finishedWork);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current.memoizedProps
                );
                current = current.memoizedState;
                try {
                  finishedRoot.componentDidUpdate(
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (error$142) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error$142
                  );
                }
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
              current = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    current = finishedWork.child.stateNode;
                    break;
                  case 1:
                    current = finishedWork.child.stateNode;
                }
              try {
                commitCallbacks(finishedRoot, current);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 27:
            null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      var hostParent = null;
      var hostParentIsContainer = false;
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {
          }
        switch (deletedFiber.tag) {
          case 26:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
            break;
          case 27:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            releaseSingletonInstance(deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            if (null !== hostParent)
              if (hostParentIsContainer)
                try {
                  (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
              else
                try {
                  hostParent.removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
            break;
          case 18:
            null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
              9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
              deletedFiber.stateNode
            ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo;
            hostParentIsContainer = true;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(formatProdErrorMessage(435, finishedWork.tag));
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i], root3 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
            a: for (; null !== parent; ) {
              switch (parent.tag) {
                case 27:
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  }
                  break;
                case 5:
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                case 3:
                case 4:
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break a;
              }
              parent = parent.return;
            }
            if (null === hostParent) throw Error(formatProdErrorMessage(160));
            commitDeletionEffectsOnFiber(root3, returnFiber, childToDelete);
            hostParent = null;
            hostParentIsContainer = false;
            root3 = childToDelete.alternate;
            null !== root3 && (root3.return = null);
            childToDelete.return = null;
          }
        if (parentFiber.subtreeFlags & 13878)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      var currentHoistableRoot = null;
      function commitMutationEffectsOnFiber(finishedWork, root3) {
        var current = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
            break;
          case 26:
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (flags & 4) {
              var currentResource = null !== current ? current.memoizedState : null;
              flags = finishedWork.memoizedState;
              if (null === current)
                if (null === flags)
                  if (null === finishedWork.stateNode) {
                    a: {
                      flags = finishedWork.type;
                      current = finishedWork.memoizedProps;
                      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                      b: switch (flags) {
                        case "title":
                          currentResource = hoistableRoot.getElementsByTagName("title")[0];
                          if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                            currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                              currentResource,
                              hoistableRoot.querySelector("head > title")
                            );
                          setInitialProperties(currentResource, flags, current);
                          currentResource[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(currentResource);
                          flags = currentResource;
                          break a;
                        case "link":
                          var maybeNodes = getHydratableHoistableCache(
                            "link",
                            "href",
                            hoistableRoot
                          ).get(flags + (current.href || ""));
                          if (maybeNodes) {
                            for (var i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        case "meta":
                          if (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            hoistableRoot
                          ).get(flags + (current.content || ""))) {
                            for (i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        default:
                          throw Error(formatProdErrorMessage(468, flags));
                      }
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                    }
                    finishedWork.stateNode = flags;
                  } else
                    mountHoistable(
                      hoistableRoot,
                      finishedWork.type,
                      finishedWork.stateNode
                    );
                else
                  finishedWork.stateNode = acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  );
              else
                currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current.memoizedProps
                );
            }
            break;
          case 27:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            null !== current && flags & 4 && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
            break;
          case 5:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (finishedWork.flags & 32) {
              hoistableRoot = finishedWork.stateNode;
              try {
                setTextContent(hoistableRoot, "");
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
              finishedWork,
              hoistableRoot,
              null !== current ? current.memoizedProps : hoistableRoot
            ));
            flags & 1024 && (needsFormReset = true);
            break;
          case 6:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (null === finishedWork.stateNode)
                throw Error(formatProdErrorMessage(162));
              flags = finishedWork.memoizedProps;
              current = finishedWork.stateNode;
              try {
                current.nodeValue = flags;
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 3:
            tagCaches = null;
            hoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root3.containerInfo);
            recursivelyTraverseMutationEffects(root3, finishedWork);
            currentHoistableRoot = hoistableRoot;
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
              try {
                retryIfBlockedOn(root3.containerInfo);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            break;
          case 4:
            flags = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            );
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            currentHoistableRoot = flags;
            break;
          case 12:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            break;
          case 13:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root3, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192)
              a: for (root3 = finishedWork.stateNode, root3._visibility = hoistableRoot ? root3._visibility & -2 : root3._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root3 = finishedWork; ; ) {
                if (5 === root3.tag || 26 === root3.tag) {
                  if (null === current) {
                    wasHidden = current = root3;
                    try {
                      if (currentResource = wasHidden.stateNode, hoistableRoot)
                        maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                      else {
                        i = wasHidden.stateNode;
                        var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                        i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                      }
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (6 === root3.tag) {
                  if (null === current) {
                    wasHidden = root3;
                    try {
                      wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if ((22 !== root3.tag && 23 !== root3.tag || null === root3.memoizedState || root3 === finishedWork) && null !== root3.child) {
                  root3.child.return = root3;
                  root3 = root3.child;
                  continue;
                }
                if (root3 === finishedWork) break a;
                for (; null === root3.sibling; ) {
                  if (null === root3.return || root3.return === finishedWork) break a;
                  current === root3 && (current = null);
                  root3 = root3.return;
                }
                current === root3 && (current = null);
                root3.sibling.return = root3.return;
                root3 = root3.sibling;
              }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root3, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
              if (isHostParent(parentFiber)) {
                hostParentFiber = parentFiber;
                break;
              }
              parentFiber = parentFiber.return;
            }
            if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
            switch (hostParentFiber.tag) {
              case 27:
                var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              case 5:
                var parent$144 = hostParentFiber.stateNode;
                hostParentFiber.flags & 32 && (setTextContent(parent$144, ""), hostParentFiber.flags &= -33);
                var before$145 = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
                break;
              case 3:
              case 4:
                var parent$146 = hostParentFiber.stateNode.containerInfo, before$147 = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  before$147,
                  parent$146
                );
                break;
              default:
                throw Error(formatProdErrorMessage(161));
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root3, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root3, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedWork = parentFiber;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              releaseSingletonInstance(finishedWork.stateNode);
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(4, finishedWork);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current = finishedWork;
              finishedRoot = current.stateNode;
              if ("function" === typeof finishedRoot.componentDidMount)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              current = finishedWork;
              finishedRoot = current.updateQueue;
              if (null !== finishedRoot) {
                var instance = current.stateNode;
                try {
                  var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                  if (null !== hiddenCallbacks)
                    for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                      callCallback(hiddenCallbacks[finishedRoot], instance);
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
      }
      function recursivelyTraversePassiveMountEffects(root3, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveMountOnFiber(
              root3,
              parentFiber,
              committedLanes,
              committedTransitions
            ), parentFiber = parentFiber.sibling;
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookEffectListMount(9, finishedWork);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
            break;
          case 12:
            if (flags & 2048) {
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              try {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                "function" === typeof onPostCommit && onPostCommit(
                  id,
                  null === finishedWork.alternate ? "mount" : "update",
                  finishedRoot.passiveEffectDuration,
                  -0
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            _finishedWork$memoize2 = finishedWork.stateNode;
            id = finishedWork.alternate;
            null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256)
            ));
            flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(8, finishedWork);
              break;
            case 23:
              break;
            case 22:
              var instance = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
      }
      var suspenseyCommitFlag = 8192;
      function recursivelyAccumulateSuspenseyCommit(parentFiber) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(fiber);
            fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(fiber);
            break;
          case 3:
          case 4:
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
            recursivelyAccumulateSuspenseyCommit(fiber);
            currentHoistableRoot = previousHoistableRoot;
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(fiber);
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 12:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          deletions = parentFiber;
          switch (deletions.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, deletions, deletions.return);
              recursivelyTraverseDisconnectPassiveEffects(deletions);
              break;
            case 22:
              i = deletions.stateNode;
              i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(deletions);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect;
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
              break;
            case 23:
            case 22:
              if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                var cache = fiber.memoizedState.cachePool.pool;
                null != cache && cache.refCount++;
              }
              break;
            case 24:
              releaseCache(fiber.memoizedState.cache);
          }
          cache = fiber.child;
          if (null !== cache) cache.return = fiber, nextEffect = cache;
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              cache = nextEffect;
              var sibling = cache.sibling, returnFiber = cache.return;
              detachFiberAfterEffects(cache);
              if (cache === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== sibling) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }
        }
      }
      var DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        }
      };
      var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
      var executionContext = 0;
      var workInProgressRoot = null;
      var workInProgress = null;
      var workInProgressRootRenderLanes = 0;
      var workInProgressSuspendedReason = 0;
      var workInProgressThrownValue = null;
      var workInProgressRootDidSkipSuspendedSiblings = false;
      var workInProgressRootIsPrerendering = false;
      var workInProgressRootDidAttachPingListener = false;
      var entangledRenderLanes = 0;
      var workInProgressRootExitStatus = 0;
      var workInProgressRootSkippedLanes = 0;
      var workInProgressRootInterleavedUpdatedLanes = 0;
      var workInProgressRootPingedLanes = 0;
      var workInProgressDeferredLane = 0;
      var workInProgressSuspendedRetryLanes = 0;
      var workInProgressRootConcurrentErrors = null;
      var workInProgressRootRecoverableErrors = null;
      var workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      var globalMostRecentFallbackTime = 0;
      var workInProgressRootRenderTargetTime = Infinity;
      var workInProgressTransitions = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var pendingEffectsStatus = 0;
      var pendingEffectsRoot = null;
      var pendingFinishedWork = null;
      var pendingEffectsLanes = 0;
      var pendingEffectsRemainingLanes = 0;
      var pendingPassiveTransitions = null;
      var pendingRecoverableErrors = null;
      var nestedUpdateCount = 0;
      var rootWithNestedUpdates = null;
      function requestUpdateLane() {
        if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
          return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
        if (null !== ReactSharedInternals.T) {
          var actionScopeLane = currentEntangledLane;
          return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
        }
        return resolveUpdatePriority();
      }
      function requestDeferredLane() {
        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
        var suspenseHandler = suspenseHandlerStackCursor.current;
        null !== suspenseHandler && (suspenseHandler.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root3, fiber, lane) {
        if (root3 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
          prepareFreshStack(root3, 0), markRootSuspended(
            root3,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root3, lane);
        if (0 === (executionContext & 2) || root3 !== workInProgressRoot)
          root3 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
            root3,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root3);
      }
      function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
        do {
          if (0 === exitStatus) {
            workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
            break;
          } else {
            forceSync = root$jscomp$0.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root$jscomp$0, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (2 === exitStatus) {
              renderWasConcurrent = lanes;
              if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                var JSCompiler_inline_result = 0;
              else
                JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
              if (0 !== JSCompiler_inline_result) {
                lanes = JSCompiler_inline_result;
                a: {
                  var root3 = root$jscomp$0;
                  exitStatus = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = root3.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(root3, JSCompiler_inline_result).flags |= 256);
                  JSCompiler_inline_result = renderRootSync(
                    root3,
                    JSCompiler_inline_result,
                    false
                  );
                  if (2 !== JSCompiler_inline_result) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      root3.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = 4;
                      break a;
                    }
                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = exitStatus;
                    null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
                  }
                  exitStatus = JSCompiler_inline_result;
                }
                renderWasConcurrent = false;
                if (2 !== exitStatus) continue;
              }
            }
            if (1 === exitStatus) {
              prepareFreshStack(root$jscomp$0, 0);
              markRootSuspended(root$jscomp$0, lanes, 0, true);
              break;
            }
            a: {
              shouldTimeSlice = root$jscomp$0;
              renderWasConcurrent = exitStatus;
              switch (renderWasConcurrent) {
                case 0:
                case 1:
                  throw Error(formatProdErrorMessage(345));
                case 4:
                  if ((lanes & 4194048) !== lanes) break;
                case 6:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case 2:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(formatProdErrorMessage(329));
              }
              if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    renderWasConcurrent,
                    2,
                    -0,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                0,
                -0,
                0
              );
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root$jscomp$0);
      }
      function commitRootWhenReady(root3, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root3.timeoutHandle = -1;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
          if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
            root3.cancelPendingCommit = suspendedCommitReason(
              commitRoot.bind(
                null,
                root3,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                1,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(root3, lanes, spawnedLane, !didSkipSuspendedSiblings);
            return;
          }
        }
        commitRoot(
          root3,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i = 0; i < tag.length; i++) {
              var check = tag[i], getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check)) return false;
              } catch (error) {
                return false;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag)
            tag.return = node, node = tag;
          else {
            if (node === finishedWork) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork) return true;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root3, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root3.suspendedLanes |= suspendedLanes;
        root3.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root3.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root3.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
          didAttemptEntireTree[index$4] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, suspendedLanes);
      }
      function flushSyncWork$1() {
        return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (0 === workInProgressSuspendedReason)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function prepareFreshStack(root3, lanes) {
        var timeoutHandle = root3.timeoutHandle;
        -1 !== timeoutHandle && (root3.timeoutHandle = -1, cancelTimeout(timeoutHandle));
        timeoutHandle = root3.cancelPendingCommit;
        null !== timeoutHandle && (root3.cancelPendingCommit = null, timeoutHandle());
        resetWorkInProgressStack();
        workInProgressRoot = root3;
        workInProgress = timeoutHandle = createWorkInProgress(root3.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = 0;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root3, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root3.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root3 = root3.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
            lanes |= root3[index$2];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        return timeoutHandle;
      }
      function handleThrow(root3, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
        workInProgressThrownValue = thrownValue;
        null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
          root3,
          createCapturedValueAtFiber(thrownValue, root3.current)
        ));
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = 4;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root3, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes)
          workInProgressTransitions = null, prepareFreshStack(root3, lanes);
        lanes = false;
        var exitStatus = workInProgressRootExitStatus;
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case 8:
                  resetWorkInProgressStack();
                  exitStatus = 6;
                  break a;
                case 3:
                case 2:
                case 9:
                case 6:
                  null === suspenseHandlerStackCursor.current && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    exitStatus = 0;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            exitStatus = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$167) {
            handleThrow(root3, thrownValue$167);
          }
        while (1);
        lanes && root3.shellSuspendCounter++;
        lastContextDependency = currentlyRenderingFiber$1 = null;
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return exitStatus;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root3, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root3, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root3,
          lanes
        );
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              lanes = workInProgress;
              var thrownValue = workInProgressThrownValue;
              b: switch (workInProgressSuspendedReason) {
                case 1:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root3, lanes, thrownValue, 1);
                  break;
                case 2:
                case 9:
                  if (isThenableResolved(thrownValue)) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function() {
                    2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root3 || (workInProgressSuspendedReason = 7);
                    ensureRootIsScheduled(root3);
                  };
                  thrownValue.then(lanes, lanes);
                  break a;
                case 3:
                  workInProgressSuspendedReason = 7;
                  break a;
                case 4:
                  workInProgressSuspendedReason = 5;
                  break a;
                case 7:
                  isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, lanes, thrownValue, 7));
                  break;
                case 5:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress;
                      if (resource ? preloadResource(resource) : 1) {
                        workInProgressSuspendedReason = 0;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                        }
                        break b;
                      }
                  }
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root3, lanes, thrownValue, 5);
                  break;
                case 6:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root3, lanes, thrownValue, 6);
                  break;
                case 8:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = 6;
                  break a;
                default:
                  throw Error(formatProdErrorMessage(462));
              }
            }
            workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$169) {
            handleThrow(root3, thrownValue$169);
          }
        while (1);
        lastContextDependency = currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return 0;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = unitOfWork;
        var current = next.alternate;
        switch (next.tag) {
          case 15:
          case 0:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type.render,
              next.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(next);
          default:
            unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
        }
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, suspendedReason) {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        resetHooksOnUnwind(unitOfWork);
        thenableState = null;
        thenableIndexCounter = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root3,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = 1;
            logUncaughtError(
              root3,
              createCapturedValueAtFiber(thrownValue, root3.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error) {
          if (null !== returnFiber) throw workInProgress = returnFiber, error;
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root3,
            createCapturedValueAtFiber(thrownValue, root3.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || 1 === suspendedReason) root3 = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root3 = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root3 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root3);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          unitOfWork = completedWork.return;
          var next = completeWork(
            completedWork.alternate,
            completedWork,
            entangledRenderLanes
          );
          if (null !== next) {
            workInProgress = next;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          next = unitOfWork.return;
          null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = 6;
        workInProgress = null;
      }
      function commitRoot(root3, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
        root3.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (0 !== pendingEffectsStatus);
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        if (null !== finishedWork) {
          if (finishedWork === root3.current) throw Error(formatProdErrorMessage(177));
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root3,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root3 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root3;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root3.callbackNode = null, root3.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
            flushPassiveEffects(true);
            return null;
          })) : (root3.callbackNode = null, root3.callbackPriority = 0);
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            spawnedLane = executionContext;
            executionContext |= 4;
            try {
              commitBeforeMutationEffects(root3, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = 1;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (1 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitMutationEffectsOnFiber(finishedWork, root3);
              var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root3.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
              if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                  var start = priorSelectionRange.start, end = priorSelectionRange.end;
                  void 0 === end && (end = start);
                  if ("selectionStart" in priorFocusedElem)
                    priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length
                    );
                  else {
                    var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                    if (win.getSelection) {
                      var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                      !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                      var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ), endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                      if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                        var range = doc.createRange();
                        range.setStart(startMarker.node, startMarker.offset);
                        selection.removeAllRanges();
                        start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                      }
                    }
                  }
                }
                doc = [];
                for (selection = priorFocusedElem; selection = selection.parentNode; )
                  1 === selection.nodeType && doc.push({
                    element: selection,
                    left: selection.scrollLeft,
                    top: selection.scrollTop
                  });
                "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                  var info = doc[priorFocusedElem];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
              _enabled = !!eventsEnabled;
              selectionInformation = eventsEnabled = null;
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root3.current = finishedWork;
          pendingEffectsStatus = 2;
        }
      }
      function flushLayoutEffects() {
        if (2 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitLayoutEffectOnFiber(root3, finishedWork.alternate, finishedWork);
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          pendingEffectsStatus = 3;
        }
      }
      function flushSpawnedWork() {
        if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          requestPaint();
          var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root3, root3.pendingLanes));
          var remainingLanes = root3.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                void 0,
                128 === (finishedWork.current.flags & 128)
              );
            } catch (err) {
            }
          if (null !== recoverableErrors) {
            finishedWork = ReactSharedInternals.T;
            remainingLanes = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            ReactSharedInternals.T = null;
            try {
              for (var onRecoverableError = root3.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                onRecoverableError(recoverableError.value, {
                  componentStack: recoverableError.stack
                });
              }
            } finally {
              ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root3);
          remainingLanes = root3.pendingLanes;
          0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root3 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root3) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0, false);
        }
      }
      function releaseRootPooledCache(root3, remainingLanes) {
        0 === (root3.pooledCacheLanes &= remainingLanes) && (remainingLanes = root3.pooledCache, null != remainingLanes && (root3.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects(wasDelayedCommit) {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects(wasDelayedCommit);
      }
      function flushPassiveEffects() {
        if (5 !== pendingEffectsStatus) return false;
        var root3 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
          ReactSharedInternals.T = null;
          renderPriority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
          pendingEffectsStatus = 0;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(
            root$jscomp$0,
            root$jscomp$0.current,
            lanes,
            renderPriority
          );
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, false);
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {
            }
          return true;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root3, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error
              );
              break;
            } else if (1 === nearestMountedAncestor.tag) {
              var instance = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                error = createClassErrorUpdate(2);
                instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                null !== instance && (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                break;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
      }
      function attachPingListener(root3, wakeable, lanes) {
        var pingCache = root3.pingCache;
        if (null === pingCache) {
          pingCache = root3.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root3 = pingSuspendedRoot.bind(null, root3, wakeable, lanes), wakeable.then(root3, root3));
      }
      function pingSuspendedRoot(root3, wakeable, pingedLanes) {
        var pingCache = root3.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
        root3.warmLanes &= ~pingedLanes;
        workInProgressRoot === root3 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root3, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root3);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(formatProdErrorMessage(314));
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function scheduleCallback$1(priorityLevel, callback) {
        return scheduleCallback$3(priorityLevel, callback);
      }
      var firstScheduledRoot = null;
      var lastScheduledRoot = null;
      var didScheduleMicrotask = false;
      var mightHavePendingSyncWork = false;
      var isFlushingWork = false;
      var currentEventTransitionLane = 0;
      function ensureRootIsScheduled(root3) {
        root3 !== lastScheduledRoot && null === root3.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root3 : lastScheduledRoot = lastScheduledRoot.next = root3);
        mightHavePendingSyncWork = true;
        didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root$174 = firstScheduledRoot; null !== root$174; ) {
              if (!onlyLegacy)
                if (0 !== syncTransitionLanes) {
                  var pendingLanes = root$174.pendingLanes;
                  if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                  else {
                    var suspendedLanes = root$174.suspendedLanes, pingedLanes = root$174.pingedLanes;
                    JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                    JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                    JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                  }
                  0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
                } else
                  JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                    root$174,
                    root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
                    null !== root$174.cancelPendingCommit || -1 !== root$174.timeoutHandle
                  ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
              root$174 = root$174.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
        for (var currentTime = now(), prev = null, root3 = firstScheduledRoot; null !== root3; ) {
          var next = root3.next, nextLanes = scheduleTaskForRootDuringMicrotask(root3, currentTime);
          if (0 === nextLanes)
            root3.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
          else if (prev = root3, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root3 = next;
        }
        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
      }
      function scheduleTaskForRootDuringMicrotask(root3, currentTime) {
        for (var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes, expirationTimes = root3.expirationTimes, lanes = root3.pendingLanes & -62914561; 0 < lanes; ) {
          var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root3.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root3,
          root3 === currentTime ? suspendedLanes : 0,
          null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
        );
        pingedLanes = root3.callbackNode;
        if (0 === suspendedLanes || root3 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
          return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root3.callbackNode = null, root3.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root3, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime === root3.callbackPriority) return currentTime;
          null !== pingedLanes && cancelCallback$1(pingedLanes);
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root3);
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root3.callbackPriority = currentTime;
          root3.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
        root3.callbackPriority = 2;
        root3.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root3, didTimeout) {
        if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
          return root3.callbackNode = null, root3.callbackPriority = 0, null;
        var originalCallbackNode = root3.callbackNode;
        if (flushPendingEffects(true) && root3.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root3,
          root3 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(root3, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root3, now());
        return null != root3.callbackNode && root3.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root3) : null;
      }
      function performSyncWorkOnRoot(root3, lanes) {
        if (flushPendingEffects()) return null;
        performWorkOnRoot(root3, lanes, true);
      }
      function scheduleImmediateRootScheduleTask() {
        scheduleMicrotask(function() {
          0 !== (executionContext & 6) ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        });
      }
      function requestTransitionLane() {
        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
        return currentEventTransitionLane;
      }
      function coerceFormActionProp(actionProp) {
        return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
      }
      function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement("input");
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute("form", form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
      }
      function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
        if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
          var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ), submitter = nativeEvent.submitter;
          submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
          var event = new SyntheticEvent(
            "action",
            "action",
            null,
            nativeEvent,
            nativeEventTarget
          );
          dispatchQueue.push({
            event,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (nativeEvent.defaultPrevented) {
                    if (0 !== currentEventTransitionLane) {
                      var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                      startHostTransition(
                        maybeTargetInst,
                        {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        },
                        null,
                        formData
                      );
                    }
                  } else
                    "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      action,
                      formData
                    ));
                },
                currentTarget: nativeEventTarget
              }
            ]
          });
        }
      }
      for (i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
        eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528], domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(), capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
        registerSimpleEvent(
          domEventName$jscomp$inline_1530,
          "on" + capitalizedEvent$jscomp$inline_1531
        );
      }
      var eventName$jscomp$inline_1529;
      var domEventName$jscomp$inline_1530;
      var capitalizedEvent$jscomp$inline_1531;
      var i$jscomp$inline_1528;
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
      registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
      registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
      registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      registerTwoPhaseEvent(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(" ")
      );
      registerTwoPhaseEvent(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      );
      registerTwoPhaseEvent("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      registerTwoPhaseEvent(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
      );
      var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      );
      var nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
      );
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for (var i = 0; i < dispatchQueue.length; i++) {
          var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          a: {
            var previousInstance = void 0;
            if (eventSystemFlags)
              for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
            else
              for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                instance = _dispatchListeners$i.instance;
                currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
          }
        }
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
        void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
        var listenerSetKey = domEventName + "__bubble";
        JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(
          target,
          domEventName,
          eventSystemFlags,
          isCapturePhaseListener
        );
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
          });
          var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
          null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
        switch (getEventPriority(domEventName)) {
          case 2:
            var listenerWrapper = dispatchDiscreteEvent;
            break;
          case 8:
            listenerWrapper = dispatchContinuousEvent;
            break;
          default:
            listenerWrapper = dispatchEvent;
        }
        eventSystemFlags = listenerWrapper.bind(
          null,
          domEventName,
          eventSystemFlags,
          targetContainer
        );
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: true,
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
        var ancestorInst = targetInst$jscomp$0;
        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
          a: for (; ; ) {
            if (null === targetInst$jscomp$0) return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (3 === nodeTag || 4 === nodeTag) {
              var container = targetInst$jscomp$0.stateNode.containerInfo;
              if (container === targetContainer) break;
              if (4 === nodeTag)
                for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                  var grandTag = nodeTag.tag;
                  if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                    return;
                  nodeTag = nodeTag.return;
                }
              for (; null !== container; ) {
                nodeTag = getClosestInstanceFromNode(container);
                if (null === nodeTag) return;
                grandTag = nodeTag.tag;
                if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container = container.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
        batchedUpdates$1(function() {
          var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
          a: {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (void 0 !== reactName) {
              var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
              switch (domEventName) {
                case "keypress":
                  if (0 === getEventCharCode(nativeEvent)) break a;
                case "keydown":
                case "keyup":
                  SyntheticEventCtor = SyntheticKeyboardEvent;
                  break;
                case "focusin":
                  reactEventType = "focus";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "focusout":
                  reactEventType = "blur";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "beforeblur":
                case "afterblur":
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "click":
                  if (2 === nativeEvent.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  SyntheticEventCtor = SyntheticMouseEvent;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  SyntheticEventCtor = SyntheticDragEvent;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  SyntheticEventCtor = SyntheticTouchEvent;
                  break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                  SyntheticEventCtor = SyntheticAnimationEvent;
                  break;
                case TRANSITION_END:
                  SyntheticEventCtor = SyntheticTransitionEvent;
                  break;
                case "scroll":
                case "scrollend":
                  SyntheticEventCtor = SyntheticUIEvent;
                  break;
                case "wheel":
                  SyntheticEventCtor = SyntheticWheelEvent;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  SyntheticEventCtor = SyntheticClipboardEvent;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  SyntheticEventCtor = SyntheticPointerEvent;
                  break;
                case "toggle":
                case "beforetoggle":
                  SyntheticEventCtor = SyntheticToggleEvent;
              }
              var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
              inCapturePhase = [];
              for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                var _instance = instance;
                lastHostComponent = _instance.stateNode;
                _instance = _instance.tag;
                5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                  createDispatchListener(instance, _instance, lastHostComponent)
                ));
                if (accumulateTargetOnly) break;
                instance = instance.return;
              }
              0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
            }
          }
          if (0 === (eventSystemFlags & 7)) {
            a: {
              reactName = "mouseover" === domEventName || "pointerover" === domEventName;
              SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
              if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                break a;
              if (SyntheticEventCtor || reactName) {
                reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                if (SyntheticEventCtor) {
                  if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                    reactEventType = null;
                } else SyntheticEventCtor = null, reactEventType = targetInst;
                if (SyntheticEventCtor !== reactEventType) {
                  inCapturePhase = SyntheticMouseEvent;
                  _instance = "onMouseLeave";
                  reactEventName = "onMouseEnter";
                  instance = "mouse";
                  if ("pointerout" === domEventName || "pointerover" === domEventName)
                    inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                  accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                  lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                  reactName = new inCapturePhase(
                    _instance,
                    instance + "leave",
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget
                  );
                  reactName.target = accumulateTargetOnly;
                  reactName.relatedTarget = lastHostComponent;
                  _instance = null;
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                  accumulateTargetOnly = _instance;
                  if (SyntheticEventCtor && reactEventType)
                    b: {
                      inCapturePhase = SyntheticEventCtor;
                      reactEventName = reactEventType;
                      instance = 0;
                      for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                        instance++;
                      lastHostComponent = 0;
                      for (_instance = reactEventName; _instance; _instance = getParent(_instance))
                        lastHostComponent++;
                      for (; 0 < instance - lastHostComponent; )
                        inCapturePhase = getParent(inCapturePhase), instance--;
                      for (; 0 < lastHostComponent - instance; )
                        reactEventName = getParent(reactEventName), lastHostComponent--;
                      for (; instance--; ) {
                        if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                          break b;
                        inCapturePhase = getParent(inCapturePhase);
                        reactEventName = getParent(reactEventName);
                      }
                      inCapturePhase = null;
                    }
                  else inCapturePhase = null;
                  null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    false
                  );
                  null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    true
                  );
                }
              }
            }
            a: {
              reactName = targetInst ? getNodeFromInstance(targetInst) : window;
              SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
              if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                var getTargetInstFunc = getTargetInstForChangeEvent;
              else if (isTextInputElement(reactName))
                if (isInputEventSupported)
                  getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  var handleEventFunc = handleEventsForInputEventPolyfill;
                }
              else
                SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
              if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  getTargetInstFunc,
                  nativeEvent,
                  nativeEventTarget
                );
                break a;
              }
              handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
              "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
            }
            handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                  activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                break;
              case "focusout":
                lastSelection = activeElementInst = activeElement = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) break;
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
            var fallbackData;
            if (canUseCompositionEvent)
              b: {
                switch (domEventName) {
                  case "compositionstart":
                    var eventType = "onCompositionStart";
                    break b;
                  case "compositionend":
                    eventType = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    eventType = "onCompositionUpdate";
                    break b;
                }
                eventType = void 0;
              }
            else
              isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
            eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root2 = nativeEventTarget, startText = "value" in root2 ? root2.value : root2.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
              eventType,
              domEventName,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
            if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
              eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
                "onBeforeInput",
                "beforeinput",
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: handleEventFunc,
                listeners: eventType
              }), handleEventFunc.data = fallbackData);
            extractEvents$1(
              dispatchQueue,
              domEventName,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
          }
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
          var _instance2 = targetFiber, stateNode = _instance2.stateNode;
          _instance2 = _instance2.tag;
          5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ));
          if (3 === targetFiber.tag) return listeners;
          targetFiber = targetFiber.return;
        }
        return [];
      }
      function getParent(inst) {
        if (null === inst) return null;
        do
          inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
          var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
          _instance3 = _instance3.tag;
          if (null !== alternate && alternate === common) break;
          5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
            createDispatchListener(target, stateNode, alternate)
          )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
            createDispatchListener(target, stateNode, alternate)
          )));
          target = target.return;
        }
        0 !== listeners.length && dispatchQueue.push({ event, listeners });
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
      var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
      }
      function noop$1() {
      }
      function setProp(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "children":
            "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
            break;
          case "className":
            setValueForKnownAttribute(domElement, "class", value);
            break;
          case "tabIndex":
            setValueForKnownAttribute(domElement, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            setValueForKnownAttribute(domElement, key, value);
            break;
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "data":
            if ("object" !== tag) {
              setValueForKnownAttribute(domElement, "data", value);
              break;
            }
          case "src":
          case "href":
            if ("" === value && ("a" !== tag || "href" !== key)) {
              domElement.removeAttribute(key);
              break;
            }
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "action":
          case "formAction":
            if ("function" === typeof value) {
              domElement.setAttribute(
                key,
                "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
              );
              break;
            } else
              "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
            if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "multiple":
            domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "muted":
            domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
              domElement.removeAttribute("xlink:href");
              break;
            }
            key = sanitizeURL("" + value);
            domElement.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              key
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
            break;
          case "inert":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
            break;
          case "capture":
          case "download":
            true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "rowSpan":
          case "start":
            null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
            break;
          case "popover":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            setValueForAttribute(domElement, "popover", value);
            break;
          case "xlinkActuate":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:actuate",
              value
            );
            break;
          case "xlinkArcrole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:arcrole",
              value
            );
            break;
          case "xlinkRole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:role",
              value
            );
            break;
          case "xlinkShow":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:show",
              value
            );
            break;
          case "xlinkTitle":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:title",
              value
            );
            break;
          case "xlinkType":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:type",
              value
            );
            break;
          case "xmlBase":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:base",
              value
            );
            break;
          case "xmlLang":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:lang",
              value
            );
            break;
          case "xmlSpace":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:space",
              value
            );
            break;
          case "is":
            setValueForAttribute(domElement, "is", value);
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
              key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
        }
      }
      function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "children":
            "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!registrationNameDependencies.hasOwnProperty(key))
              a: {
                if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                  "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                  domElement.addEventListener(tag, value, props);
                  break a;
                }
                key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
              }
        }
      }
      function setInitialProperties(domElement, tag, props) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            var hasSrc = false, hasSrcSet = false, propKey;
            for (propKey in props)
              if (props.hasOwnProperty(propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "src":
                      hasSrc = true;
                      break;
                    case "srcSet":
                      hasSrcSet = true;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(formatProdErrorMessage(137, tag));
                    default:
                      setProp(domElement, tag, propKey, propValue, props, null);
                  }
              }
            hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
            hasSrc && setProp(domElement, tag, "src", props.src, props, null);
            return;
          case "input":
            listenToNonDelegatedEvent("invalid", domElement);
            var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
            for (hasSrc in props)
              if (props.hasOwnProperty(hasSrc)) {
                var propValue$188 = props[hasSrc];
                if (null != propValue$188)
                  switch (hasSrc) {
                    case "name":
                      hasSrcSet = propValue$188;
                      break;
                    case "type":
                      propValue = propValue$188;
                      break;
                    case "checked":
                      checked = propValue$188;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$188;
                      break;
                    case "value":
                      propKey = propValue$188;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$188;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propValue$188)
                        throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      setProp(domElement, tag, hasSrc, propValue$188, props, null);
                  }
              }
            initInput(
              domElement,
              propKey,
              defaultValue,
              checked,
              defaultChecked,
              propValue,
              hasSrcSet,
              false
            );
            track(domElement);
            return;
          case "select":
            listenToNonDelegatedEvent("invalid", domElement);
            hasSrc = propValue = propKey = null;
            for (hasSrcSet in props)
              if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                switch (hasSrcSet) {
                  case "value":
                    propKey = defaultValue;
                    break;
                  case "defaultValue":
                    propValue = defaultValue;
                    break;
                  case "multiple":
                    hasSrc = defaultValue;
                  default:
                    setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
            tag = propKey;
            props = propValue;
            domElement.multiple = !!hasSrc;
            null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
            return;
          case "textarea":
            listenToNonDelegatedEvent("invalid", domElement);
            propKey = hasSrcSet = hasSrc = null;
            for (propValue in props)
              if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                switch (propValue) {
                  case "value":
                    hasSrc = defaultValue;
                    break;
                  case "defaultValue":
                    hasSrcSet = defaultValue;
                    break;
                  case "children":
                    propKey = defaultValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    setProp(domElement, tag, propValue, defaultValue, props, null);
                }
            initTextarea(domElement, hasSrc, hasSrcSet, propKey);
            track(domElement);
            return;
          case "option":
            for (checked in props)
              if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                switch (checked) {
                  case "selected":
                    domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                    break;
                  default:
                    setProp(domElement, tag, checked, hasSrc, props, null);
                }
            return;
          case "dialog":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
              listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
            break;
          case "image":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "embed":
          case "source":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (defaultChecked in props)
              if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                switch (defaultChecked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (propValue$188 in props)
                props.hasOwnProperty(propValue$188) && (hasSrc = props[propValue$188], void 0 !== hasSrc && setPropOnCustomElement(
                  domElement,
                  tag,
                  propValue$188,
                  hasSrc,
                  props,
                  void 0
                ));
              return;
            }
        }
        for (defaultValue in props)
          props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
      }
      function updateProperties(domElement, tag, lastProps, nextProps) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
            for (propKey in lastProps) {
              var lastProp = lastProps[propKey];
              if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                switch (propKey) {
                  case "checked":
                    break;
                  case "value":
                    break;
                  case "defaultValue":
                    lastDefaultValue = lastProp;
                  default:
                    nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                }
            }
            for (var propKey$205 in nextProps) {
              var propKey = nextProps[propKey$205];
              lastProp = lastProps[propKey$205];
              if (nextProps.hasOwnProperty(propKey$205) && (null != propKey || null != lastProp))
                switch (propKey$205) {
                  case "type":
                    type = propKey;
                    break;
                  case "name":
                    name = propKey;
                    break;
                  case "checked":
                    checked = propKey;
                    break;
                  case "defaultChecked":
                    defaultChecked = propKey;
                    break;
                  case "value":
                    value = propKey;
                    break;
                  case "defaultValue":
                    defaultValue = propKey;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    propKey !== lastProp && setProp(
                      domElement,
                      tag,
                      propKey$205,
                      propKey,
                      nextProps,
                      lastProp
                    );
                }
            }
            updateInput(
              domElement,
              value,
              defaultValue,
              lastDefaultValue,
              checked,
              defaultChecked,
              type,
              name
            );
            return;
          case "select":
            propKey = value = defaultValue = propKey$205 = null;
            for (type in lastProps)
              if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                switch (type) {
                  case "value":
                    break;
                  case "multiple":
                    propKey = lastDefaultValue;
                  default:
                    nextProps.hasOwnProperty(type) || setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
                }
            for (name in nextProps)
              if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                switch (name) {
                  case "value":
                    propKey$205 = type;
                    break;
                  case "defaultValue":
                    defaultValue = type;
                    break;
                  case "multiple":
                    value = type;
                  default:
                    type !== lastDefaultValue && setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
                }
            tag = defaultValue;
            lastProps = value;
            nextProps = propKey;
            null != propKey$205 ? updateOptions(domElement, !!lastProps, propKey$205, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
            return;
          case "textarea":
            propKey = propKey$205 = null;
            for (defaultValue in lastProps)
              if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                switch (defaultValue) {
                  case "value":
                    break;
                  case "children":
                    break;
                  default:
                    setProp(domElement, tag, defaultValue, null, nextProps, name);
                }
            for (value in nextProps)
              if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                switch (value) {
                  case "value":
                    propKey$205 = name;
                    break;
                  case "defaultValue":
                    propKey = name;
                    break;
                  case "children":
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != name) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    name !== type && setProp(domElement, tag, value, name, nextProps, type);
                }
            updateTextarea(domElement, propKey$205, propKey);
            return;
          case "option":
            for (var propKey$221 in lastProps)
              if (propKey$205 = lastProps[propKey$221], lastProps.hasOwnProperty(propKey$221) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$221))
                switch (propKey$221) {
                  case "selected":
                    domElement.selected = false;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      propKey$221,
                      null,
                      nextProps,
                      propKey$205
                    );
                }
            for (lastDefaultValue in nextProps)
              if (propKey$205 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
                switch (lastDefaultValue) {
                  case "selected":
                    domElement.selected = propKey$205 && "function" !== typeof propKey$205 && "symbol" !== typeof propKey$205;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      lastDefaultValue,
                      propKey$205,
                      nextProps,
                      propKey
                    );
                }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var propKey$226 in lastProps)
              propKey$205 = lastProps[propKey$226], lastProps.hasOwnProperty(propKey$226) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$226) && setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
            for (checked in nextProps)
              if (propKey$205 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
                switch (checked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey$205)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      checked,
                      propKey$205,
                      nextProps,
                      propKey
                    );
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (var propKey$231 in lastProps)
                propKey$205 = lastProps[propKey$231], lastProps.hasOwnProperty(propKey$231) && void 0 !== propKey$205 && !nextProps.hasOwnProperty(propKey$231) && setPropOnCustomElement(
                  domElement,
                  tag,
                  propKey$231,
                  void 0,
                  nextProps,
                  propKey$205
                );
              for (defaultChecked in nextProps)
                propKey$205 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey || void 0 === propKey$205 && void 0 === propKey || setPropOnCustomElement(
                  domElement,
                  tag,
                  defaultChecked,
                  propKey$205,
                  nextProps,
                  propKey
                );
              return;
            }
        }
        for (var propKey$236 in lastProps)
          propKey$205 = lastProps[propKey$236], lastProps.hasOwnProperty(propKey$236) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$236) && setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
        for (lastProp in nextProps)
          propKey$205 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || null == propKey$205 && null == propKey || setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
      }
      var eventsEnabled = null;
      var selectionInformation = null;
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function getOwnHostContext(namespaceURI) {
        switch (namespaceURI) {
          case "http://www.w3.org/2000/svg":
            return 1;
          case "http://www.w3.org/1998/Math/MathML":
            return 2;
          default:
            return 0;
        }
      }
      function getChildHostContextProd(parentNamespace, type) {
        if (0 === parentNamespace)
          switch (type) {
            case "svg":
              return 1;
            case "math":
              return 2;
            default:
              return 0;
          }
        return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
      }
      function shouldSetTextContent(type, props) {
        return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
      }
      var currentPopstateTransitionEvent = null;
      function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && "popstate" === event.type) {
          if (event === currentPopstateTransitionEvent) return false;
          currentPopstateTransitionEvent = event;
          return true;
        }
        currentPopstateTransitionEvent = null;
        return false;
      }
      var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0;
      var cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var localPromise = "function" === typeof Promise ? Promise : void 0;
      var scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error) {
        setTimeout(function() {
          throw error;
        });
      }
      function isSingletonScope(type) {
        return "head" === type;
      }
      function clearSuspenseBoundary(parentInstance, suspenseInstance) {
        var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node) {
              if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
                node = possiblePreambleContribution;
                var ownerDocument = parentInstance.ownerDocument;
                node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
                node & 2 && releaseSingletonInstance(ownerDocument.body);
                if (node & 4)
                  for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument; ) {
                    var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
                    ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
                    ownerDocument = nextNode$jscomp$0;
                  }
              }
              if (0 === depth) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(suspenseInstance);
                return;
              }
              depth--;
            } else
              "$" === node || "$?" === node || "$!" === node ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
          else possiblePreambleContribution = 0;
          node = nextNode;
        } while (node);
        retryIfBlockedOn(suspenseInstance);
      }
      function clearContainerSparingly(container) {
        var nextNode = container.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for (; nextNode; ) {
          var node = nextNode;
          nextNode = nextNode.nextSibling;
          switch (node.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              clearContainerSparingly(node);
              detachDeletedInstance(node);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if ("stylesheet" === node.rel.toLowerCase()) continue;
          }
          container.removeChild(node);
        }
      }
      function canHydrateInstance(instance, type, props, inRootOrSingleton) {
        for (; 1 === instance.nodeType; ) {
          var anyProps = props;
          if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
            if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
              break;
          } else if (!inRootOrSingleton)
            if ("input" === type && "hidden" === instance.type) {
              var name = null == anyProps.name ? null : "" + anyProps.name;
              if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                return instance;
            } else return instance;
          else if (!instance[internalHoistableMarker])
            switch (type) {
              case "meta":
                if (!instance.hasAttribute("itemprop")) break;
                return instance;
              case "link":
                name = instance.getAttribute("rel");
                if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                  break;
                else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                  break;
                return instance;
              case "style":
                if (instance.hasAttribute("data-precedence")) break;
                return instance;
              case "script":
                name = instance.getAttribute("src");
                if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                  break;
                return instance;
              default:
                return instance;
            }
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) break;
        }
        return null;
      }
      function canHydrateTextInstance(instance, text, inRootOrSingleton) {
        if ("" === text) return null;
        for (; 3 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function isSuspenseInstanceFallback(instance) {
        return "$!" === instance.data || "$?" === instance.data && "complete" === instance.ownerDocument.readyState;
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        var ownerDocument = instance.ownerDocument;
        if ("$?" !== instance.data || "complete" === ownerDocument.readyState)
          callback();
        else {
          var listener = function() {
            callback();
            ownerDocument.removeEventListener("DOMContentLoaded", listener);
          };
          ownerDocument.addEventListener("DOMContentLoaded", listener);
          instance._reactRetry = listener;
        }
      }
      function getNextHydratable(node) {
        for (; null != node; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (1 === nodeType || 3 === nodeType) break;
          if (8 === nodeType) {
            nodeType = node.data;
            if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType)
              break;
            if ("/$" === nodeType) return null;
          }
        }
        return node;
      }
      var previousHydratableOnEnteringScopedSingleton = null;
      function getParentSuspenseInstance(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for (var depth = 0; targetInstance; ) {
          if (8 === targetInstance.nodeType) {
            var data = targetInstance.data;
            if ("$" === data || "$!" === data || "$?" === data) {
              if (0 === depth) return targetInstance;
              depth--;
            } else "/$" === data && depth++;
          }
          targetInstance = targetInstance.previousSibling;
        }
        return null;
      }
      function resolveSingletonInstance(type, props, rootContainerInstance) {
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch (type) {
          case "html":
            type = props.documentElement;
            if (!type) throw Error(formatProdErrorMessage(452));
            return type;
          case "head":
            type = props.head;
            if (!type) throw Error(formatProdErrorMessage(453));
            return type;
          case "body":
            type = props.body;
            if (!type) throw Error(formatProdErrorMessage(454));
            return type;
          default:
            throw Error(formatProdErrorMessage(451));
        }
      }
      function releaseSingletonInstance(instance) {
        for (var attributes = instance.attributes; attributes.length; )
          instance.removeAttributeNode(attributes[0]);
        detachDeletedInstance(instance);
      }
      var preloadPropsMap = /* @__PURE__ */ new Map();
      var preconnectsSet = /* @__PURE__ */ new Set();
      function getHoistableRoot(container) {
        return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
      }
      var previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: flushSyncWork,
        r: requestFormReset,
        D: prefetchDNS,
        C: preconnect,
        L: preload,
        m: preloadModule,
        X: preinitScript,
        S: preinitStyle,
        M: preinitModuleScript
      };
      function flushSyncWork() {
        var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      }
      function requestFormReset(form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      }
      var globalDocument = "undefined" === typeof document ? null : document;
      function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument = globalDocument;
        if (ownerDocument && "string" === typeof href && href) {
          var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
          limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
          "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
          preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
        }
      }
      function prefetchDNS(href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      }
      function preconnect(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      }
      function preload(href, as, options2) {
        previousDispatcher.L(href, as, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSrcSet
          ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSizes
          ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign(
            {
              rel: "preload",
              href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
              as
            },
            options2
          ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      }
      function preloadModule(href, options2) {
        previousDispatcher.m(href, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      }
      function preinitStyle(href, precedence, options2) {
        previousDispatcher.S(href, precedence, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = { loading: 0, preload: null };
            if (resource = ownerDocument.querySelector(
              getStylesheetSelectorFromKey(key)
            ))
              state.loading = 5;
            else {
              href = assign(
                { rel: "stylesheet", href, "data-precedence": precedence },
                options2
              );
              (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
              var link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function(resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function() {
                state.loading |= 1;
              });
              link.addEventListener("error", function() {
                state.loading |= 2;
              });
              state.loading |= 4;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state
            };
            styles.set(key, resource);
          }
        }
      }
      function preinitScript(src, options2) {
        previousDispatcher.X(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function preinitModuleScript(src, options2) {
        previousDispatcher.M(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function getResource(type, currentProps, pendingProps, currentResource) {
        var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
        if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
        switch (type) {
          case "meta":
          case "title":
            return null;
          case "style":
            return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          case "link":
            if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
              type = getStyleKey(pendingProps.href);
              var styles$244 = getResourcesFromRoot(
                JSCompiler_inline_result
              ).hoistableStyles, resource$245 = styles$244.get(type);
              resource$245 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$245 = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null }
              }, styles$244.set(type, resource$245), (styles$244 = JSCompiler_inline_result.querySelector(
                getStylesheetSelectorFromKey(type)
              )) && !styles$244._p && (resource$245.instance = styles$244, resource$245.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              }, preloadPropsMap.set(type, pendingProps), styles$244 || preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$245.state
              )));
              if (currentProps && null === currentResource)
                throw Error(formatProdErrorMessage(528, ""));
              return resource$245;
            }
            if (currentProps && null !== currentResource)
              throw Error(formatProdErrorMessage(529, ""));
            return null;
          case "script":
            return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          default:
            throw Error(formatProdErrorMessage(444, type));
        }
      }
      function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
      }
      function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + "]";
      }
      function stylesheetPropsFromRawProps(rawProps) {
        return assign({}, rawProps, {
          "data-precedence": rawProps.precedence,
          precedence: null
        });
      }
      function preloadStylesheet(ownerDocument, key, preloadProps, state) {
        ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
          return state.loading |= 1;
        }), key.addEventListener("error", function() {
          return state.loading |= 2;
        }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
      }
      function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
      }
      function getScriptSelectorFromKey(key) {
        return "script[async]" + key;
      }
      function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance)
          switch (resource.type) {
            case "style":
              var instance = hoistableRoot.querySelector(
                'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
              );
              if (instance)
                return resource.instance = instance, markNodeAsHoistable(instance), instance;
              var styleProps = assign({}, props, {
                "data-href": props.href,
                "data-precedence": props.precedence,
                href: null,
                precedence: null
              });
              instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
                "style"
              );
              markNodeAsHoistable(instance);
              setInitialProperties(instance, "style", styleProps);
              insertStylesheet(instance, props.precedence, hoistableRoot);
              return resource.instance = instance;
            case "stylesheet":
              styleProps = getStyleKey(props.href);
              var instance$250 = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(styleProps)
              );
              if (instance$250)
                return resource.state.loading |= 4, resource.instance = instance$250, markNodeAsHoistable(instance$250), instance$250;
              instance = stylesheetPropsFromRawProps(props);
              (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
              instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
              markNodeAsHoistable(instance$250);
              var linkInstance = instance$250;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance$250, "link", instance);
              resource.state.loading |= 4;
              insertStylesheet(instance$250, props.precedence, hoistableRoot);
              return resource.instance = instance$250;
            case "script":
              instance$250 = getScriptKey(props.src);
              if (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(instance$250)
              ))
                return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
              instance = props;
              if (styleProps = preloadPropsMap.get(instance$250))
                instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              styleProps = hoistableRoot.createElement("script");
              markNodeAsHoistable(styleProps);
              setInitialProperties(styleProps, "link", instance);
              hoistableRoot.head.appendChild(styleProps);
              return resource.instance = styleProps;
            case "void":
              return null;
            default:
              throw Error(formatProdErrorMessage(443, resource.type));
          }
        else
          "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
        return resource.instance;
      }
      function insertStylesheet(instance, precedence, root3) {
        for (var nodes = root3.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (node.dataset.precedence === precedence) prior = node;
          else if (prior !== last) break;
        }
        prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root3.nodeType ? root3.head : root3, precedence.insertBefore(instance, precedence.firstChild));
      }
      function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
      }
      function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
      }
      var tagCaches = null;
      function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
        if (null === tagCaches) {
          var cache = /* @__PURE__ */ new Map();
          var caches = tagCaches = /* @__PURE__ */ new Map();
          caches.set(ownerDocument, cache);
        } else
          caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
        if (cache.has(type)) return cache;
        cache.set(type, null);
        ownerDocument = ownerDocument.getElementsByTagName(type);
        for (caches = 0; caches < ownerDocument.length; caches++) {
          var node = ownerDocument[caches];
          if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
            var nodeKey = node.getAttribute(keyAttribute) || "";
            nodeKey = type + nodeKey;
            var existing = cache.get(nodeKey);
            existing ? existing.push(node) : cache.set(nodeKey, [node]);
          }
        }
        return cache;
      }
      function mountHoistable(hoistableRoot, type, instance) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(
          instance,
          "title" === type ? hoistableRoot.querySelector("head > title") : null
        );
      }
      function isHostHoistableType(type, props, hostContext) {
        if (1 === hostContext || null != props.itemProp) return false;
        switch (type) {
          case "meta":
          case "title":
            return true;
          case "style":
            if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
              break;
            return true;
          case "link":
            if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
              break;
            switch (props.rel) {
              case "stylesheet":
                return type = props.disabled, "string" === typeof props.precedence && null == type;
              default:
                return true;
            }
          case "script":
            if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
              return true;
        }
        return false;
      }
      function preloadResource(resource) {
        return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
      }
      var suspendedState = null;
      function noop() {
      }
      function suspendResource(hoistableRoot, resource, props) {
        if (null === suspendedState) throw Error(formatProdErrorMessage(475));
        var state = suspendedState;
        if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
          if (null === resource.instance) {
            var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
            if (instance) {
              hoistableRoot = instance._p;
              null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
              resource.state.loading |= 4;
              resource.instance = instance;
              markNodeAsHoistable(instance);
              return;
            }
            instance = hoistableRoot.ownerDocument || hoistableRoot;
            props = stylesheetPropsFromRawProps(props);
            (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
            instance = instance.createElement("link");
            markNodeAsHoistable(instance);
            var linkInstance = instance;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance, "link", props);
            resource.instance = instance;
          }
          null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
          state.stylesheets.set(resource, hoistableRoot);
          (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
        }
      }
      function waitForCommitToBeReady() {
        if (null === suspendedState) throw Error(formatProdErrorMessage(475));
        var state = suspendedState;
        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count ? function(commit) {
          var stylesheetTimer = setTimeout(function() {
            state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
            if (state.unsuspend) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          }, 6e4);
          state.unsuspend = commit;
          return function() {
            state.unsuspend = null;
            clearTimeout(stylesheetTimer);
          };
        } : null;
      }
      function onUnsuspend() {
        this.count--;
        if (0 === this.count) {
          if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
          else if (this.unsuspend) {
            var unsuspend = this.unsuspend;
            this.unsuspend = null;
            unsuspend();
          }
        }
      }
      var precedencesByRoot = null;
      function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
      }
      function insertStylesheetIntoRoot(root3, resource) {
        if (!(resource.state.loading & 4)) {
          var precedences = precedencesByRoot.get(root3);
          if (precedences) var last = precedences.get(null);
          else {
            precedences = /* @__PURE__ */ new Map();
            precedencesByRoot.set(root3, precedences);
            for (var nodes = root3.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ), i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                precedences.set(node.dataset.precedence, node), last = node;
            }
            last && precedences.set(null, last);
          }
          nodes = resource.instance;
          node = nodes.getAttribute("data-precedence");
          i = precedences.get(node) || last;
          i === last && precedences.set(null, nodes);
          precedences.set(node, nodes);
          this.count++;
          last = onUnsuspend.bind(this);
          nodes.addEventListener("load", last);
          nodes.addEventListener("error", last);
          i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root3 = 9 === root3.nodeType ? root3.head : root3, root3.insertBefore(nodes, root3.firstChild));
          resource.state.loading |= 4;
        }
      }
      var HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: sharedNotPendingObject,
        _currentValue2: sharedNotPendingObject,
        _threadCount: 0
      };
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          formState
        );
        tag = 1;
        true === isStrictMode && (tag |= 24);
        isStrictMode = createFiberImplClass(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        tag.refCount++;
        containerInfo.pooledCache = tag;
        tag.refCount++;
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
        parentComponent = getContextForSubtree(parentComponent);
        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
        container = createUpdate(lane);
        container.payload = { element };
        callback = void 0 === callback ? null : callback;
        null !== callback && (container.callback = callback);
        element = enqueueUpdate(rootFiber, container, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag) {
          var root3 = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      }
      var _enabled = true;
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
          var blockedOn = findInstanceBlockingEvent(nativeEvent);
          if (null === blockedOn)
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            ), clearIfContinuousEvent(domEventName, nativeEvent);
          else if (queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ))
            nativeEvent.stopPropagation();
          else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
            for (; null !== blockedOn; ) {
              var fiber = getInstanceFromNode(blockedOn);
              if (null !== fiber)
                switch (fiber.tag) {
                  case 3:
                    fiber = fiber.stateNode;
                    if (fiber.current.memoizedState.isDehydrated) {
                      var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                      if (0 !== lanes) {
                        var root3 = fiber;
                        root3.pendingLanes |= 2;
                        for (root3.entangledLanes |= 2; lanes; ) {
                          var lane = 1 << 31 - clz32(lanes);
                          root3.entanglements[1] |= lane;
                          lanes &= ~lane;
                        }
                        ensureRootIsScheduled(fiber);
                        0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, false));
                      }
                    }
                    break;
                  case 13:
                    root3 = enqueueConcurrentRenderForLane(fiber, 2), null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                }
              fiber = findInstanceBlockingEvent(nativeEvent);
              null === fiber && dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
              if (fiber === blockedOn) break;
              blockedOn = fiber;
            }
            null !== blockedOn && nativeEvent.stopPropagation();
          } else
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              null,
              targetContainer
            );
        }
      }
      function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
      }
      var return_targetInst = null;
      function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
          var nearestMounted = getNearestMountedFiber(targetNode);
          if (null === nearestMounted) targetNode = null;
          else {
            var tag = nearestMounted.tag;
            if (13 === tag) {
              targetNode = getSuspenseInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (3 === tag) {
              if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              targetNode = null;
            } else nearestMounted !== targetNode && (targetNode = null);
          }
        }
        return_targetInst = targetNode;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 2;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 8;
          case "message":
            switch (getCurrentPriorityLevel()) {
              case ImmediatePriority:
                return 2;
              case UserBlockingPriority:
                return 8;
              case NormalPriority$1:
              case LowPriority:
                return 32;
              case IdlePriority:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var hasScheduledReplayAttempt = false;
      var queuedFocus = null;
      var queuedDrag = null;
      var queuedMouse = null;
      var queuedPointers = /* @__PURE__ */ new Map();
      var queuedPointerCaptures = /* @__PURE__ */ new Map();
      var queuedExplicitHydrationTargets = [];
      var discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout":
            queuedPointers.delete(nativeEvent.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
          return existingQueuedEvent = {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin":
            return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "dragenter":
            return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "mouseover":
            return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "pointerover":
            var pointerId = nativeEvent.pointerId;
            queuedPointers.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointers.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            );
            return true;
          case "gotpointercapture":
            return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ), true;
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (null !== nearestMounted) {
            if (targetInst = nearestMounted.tag, 13 === targetInst) {
              if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  if (13 === nearestMounted.tag) {
                    var lane = requestUpdateLane();
                    lane = getBumpedLaneForHydrationByLane(lane);
                    var root3 = enqueueConcurrentRenderForLane(nearestMounted, lane);
                    null !== root3 && scheduleUpdateOnFiber(root3, nearestMounted, lane);
                    markRetryLaneIfNotHydrated(nearestMounted, lane);
                  }
                });
                return;
              }
            } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
              queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              return;
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn) return false;
        for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
          if (null === nextBlockedOn) {
            nextBlockedOn = queuedEvent.nativeEvent;
            var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            );
            currentReplayingEvent = nativeEventClone;
            nextBlockedOn.target.dispatchEvent(nativeEventClone);
            currentReplayingEvent = null;
          } else
            return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          replayUnblockedEvents
        )));
      }
      var lastScheduledReplayQueue = null;
      function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (null === findInstanceBlockingTarget(submitterOrAction || form))
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
                formInst,
                {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                },
                submitterOrAction,
                formData
              ));
            }
          }
        ));
      }
      function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
          return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
          var queuedTarget = queuedExplicitHydrationTargets[i];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
          attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
        i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i)
          for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
            var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
            if ("function" === typeof submitterOrAction)
              formProps || scheduleReplayQueueIfNeeded(i);
            else if (formProps) {
              var action = null;
              if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                  action = formProps.formAction;
                else {
                  if (null !== findInstanceBlockingTarget(form)) continue;
                }
              else action = formProps.action;
              "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
              scheduleReplayQueueIfNeeded(i);
            }
          }
      }
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root3 = this._internalRoot;
        if (null === root3) throw Error(formatProdErrorMessage(409));
        var current = root3.current, lane = requestUpdateLane();
        updateContainerImpl(current, lane, children, root3, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        var root3 = this._internalRoot;
        if (null !== root3) {
          this._internalRoot = null;
          var container = root3.containerInfo;
          updateContainerImpl(root3.current, 2, null, root3, null, null);
          flushSyncWork$1();
          container[internalContainerInstanceKey] = null;
        }
      };
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
        if (target) {
          var updatePriority = resolveUpdatePriority();
          target = { blockedOn: null, target, priority: updatePriority };
          for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
          queuedExplicitHydrationTargets.splice(i, 0, target);
          0 === i && attemptExplicitHydrationTarget(target);
        }
      };
      var isomorphicReactPackageVersion$jscomp$inline_1785 = React12.version;
      if ("19.1.1" !== isomorphicReactPackageVersion$jscomp$inline_1785)
        throw Error(
          formatProdErrorMessage(
            527,
            isomorphicReactPackageVersion$jscomp$inline_1785,
            "19.1.1"
          )
        );
      ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof componentOrElement.render)
            throw Error(formatProdErrorMessage(188));
          componentOrElement = Object.keys(componentOrElement).join(",");
          throw Error(formatProdErrorMessage(268, componentOrElement));
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
      };
      var internals$jscomp$inline_2256 = {
        bundleType: 0,
        version: "19.1.1",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.1.1"
      };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber)
          try {
            rendererID = hook$jscomp$inline_2257.inject(
              internals$jscomp$inline_2256
            ), injectedHook = hook$jscomp$inline_2257;
          } catch (err) {
          }
      }
      var hook$jscomp$inline_2257;
      exports.createRoot = function(container, options2) {
        if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks));
        options2 = createFiberRoot(
          container,
          1,
          false,
          null,
          null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          null
        );
        container[internalContainerInstanceKey] = options2.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMRoot(options2);
      };
      exports.hydrateRoot = function(container, initialChildren, options2) {
        if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks), void 0 !== options2.formState && (formState = options2.formState));
        initialChildren = createFiberRoot(
          container,
          1,
          true,
          initialChildren,
          null != options2 ? options2 : null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          formState
        );
        initialChildren.context = getContextForSubtree(null);
        options2 = initialChildren.current;
        isStrictMode = requestUpdateLane();
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
        identifierPrefix = createUpdate(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options2, identifierPrefix, isStrictMode);
        options2 = isStrictMode;
        initialChildren.current.lanes = options2;
        markRootUpdated$1(initialChildren, options2);
        ensureRootIsScheduled(initialChildren);
        container[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMHydrationRoot(initialChildren);
      };
      exports.version = "19.1.1";
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_client_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.production.js
  var require_react_jsx_runtime_production = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      function jsxProd(type, config, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config.key && (key = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        config = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== config ? config : null,
          props: maybeKey
        };
      }
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = jsxProd;
      exports.jsxs = jsxProd;
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_jsx_runtime_production();
      } else {
        module.exports = null;
      }
    }
  });

  // index.tsx
  var import_react12 = __toESM(require_react());
  var import_client = __toESM(require_client());

  // App.tsx
  var import_react11 = __toESM(require_react());

  // node_modules/@google/genai/dist/web/index.mjs
  var _defaultBaseGeminiUrl = void 0;
  var _defaultBaseVertexUrl = void 0;
  function getDefaultBaseUrls() {
    return {
      geminiUrl: _defaultBaseGeminiUrl,
      vertexUrl: _defaultBaseVertexUrl
    };
  }
  function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {
    var _a, _b;
    if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {
      const defaultBaseUrls = getDefaultBaseUrls();
      if (vertexai) {
        return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;
      } else {
        return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;
      }
    }
    return httpOptions.baseUrl;
  }
  var BaseModule = class {
  };
  function formatMap(templateString, valueMap) {
    const regex = /\{([^}]+)\}/g;
    return templateString.replace(regex, (match, key) => {
      if (Object.prototype.hasOwnProperty.call(valueMap, key)) {
        const value = valueMap[key];
        return value !== void 0 && value !== null ? String(value) : "";
      } else {
        throw new Error(`Key '${key}' not found in valueMap.`);
      }
    });
  }
  function setValueByPath(data, keys, value) {
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      if (key.endsWith("[]")) {
        const keyName = key.slice(0, -2);
        if (!(keyName in data)) {
          if (Array.isArray(value)) {
            data[keyName] = Array.from({ length: value.length }, () => ({}));
          } else {
            throw new Error(`Value must be a list given an array path ${key}`);
          }
        }
        if (Array.isArray(data[keyName])) {
          const arrayData = data[keyName];
          if (Array.isArray(value)) {
            for (let j = 0; j < arrayData.length; j++) {
              const entry = arrayData[j];
              setValueByPath(entry, keys.slice(i + 1), value[j]);
            }
          } else {
            for (const d of arrayData) {
              setValueByPath(d, keys.slice(i + 1), value);
            }
          }
        }
        return;
      } else if (key.endsWith("[0]")) {
        const keyName = key.slice(0, -3);
        if (!(keyName in data)) {
          data[keyName] = [{}];
        }
        const arrayData = data[keyName];
        setValueByPath(arrayData[0], keys.slice(i + 1), value);
        return;
      }
      if (!data[key] || typeof data[key] !== "object") {
        data[key] = {};
      }
      data = data[key];
    }
    const keyToSet = keys[keys.length - 1];
    const existingData = data[keyToSet];
    if (existingData !== void 0) {
      if (!value || typeof value === "object" && Object.keys(value).length === 0) {
        return;
      }
      if (value === existingData) {
        return;
      }
      if (typeof existingData === "object" && typeof value === "object" && existingData !== null && value !== null) {
        Object.assign(existingData, value);
      } else {
        throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);
      }
    } else {
      if (keyToSet === "_self" && typeof value === "object" && value !== null && !Array.isArray(value)) {
        const valueAsRecord = value;
        Object.assign(data, valueAsRecord);
      } else {
        data[keyToSet] = value;
      }
    }
  }
  function getValueByPath(data, keys) {
    try {
      if (keys.length === 1 && keys[0] === "_self") {
        return data;
      }
      for (let i = 0; i < keys.length; i++) {
        if (typeof data !== "object" || data === null) {
          return void 0;
        }
        const key = keys[i];
        if (key.endsWith("[]")) {
          const keyName = key.slice(0, -2);
          if (keyName in data) {
            const arrayData = data[keyName];
            if (!Array.isArray(arrayData)) {
              return void 0;
            }
            return arrayData.map((d) => getValueByPath(d, keys.slice(i + 1)));
          } else {
            return void 0;
          }
        } else {
          data = data[key];
        }
      }
      return data;
    } catch (error) {
      if (error instanceof TypeError) {
        return void 0;
      }
      throw error;
    }
  }
  function tBytes$1(fromBytes) {
    if (typeof fromBytes !== "string") {
      throw new Error("fromImageBytes must be a string");
    }
    return fromBytes;
  }
  function fetchPredictOperationParametersToVertex(fromObject) {
    const toObject = {};
    const fromOperationName = getValueByPath(fromObject, [
      "operationName"
    ]);
    if (fromOperationName != null) {
      setValueByPath(toObject, ["operationName"], fromOperationName);
    }
    const fromResourceName = getValueByPath(fromObject, ["resourceName"]);
    if (fromResourceName != null) {
      setValueByPath(toObject, ["_url", "resourceName"], fromResourceName);
    }
    return toObject;
  }
  function generateVideosOperationFromMldev$1(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, [
      "response",
      "generateVideoResponse"
    ]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromMldev$1(fromResponse));
    }
    return toObject;
  }
  function generateVideosOperationFromVertex$1(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromVertex$1(fromResponse));
    }
    return toObject;
  }
  function generateVideosResponseFromMldev$1(fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, [
      "generatedSamples"
    ]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromMldev$1(item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosResponseFromVertex$1(fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromVertex$1(item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generatedVideoFromMldev$1(fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["_self"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromMldev$1(fromVideo));
    }
    return toObject;
  }
  function generatedVideoFromVertex$1(fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["_self"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromVertex$1(fromVideo));
    }
    return toObject;
  }
  function getOperationParametersToMldev(fromObject) {
    const toObject = {};
    const fromOperationName = getValueByPath(fromObject, [
      "operationName"
    ]);
    if (fromOperationName != null) {
      setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
    }
    return toObject;
  }
  function getOperationParametersToVertex(fromObject) {
    const toObject = {};
    const fromOperationName = getValueByPath(fromObject, [
      "operationName"
    ]);
    if (fromOperationName != null) {
      setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
    }
    return toObject;
  }
  function videoFromMldev$1(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["video", "uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, [
      "video",
      "encodedVideo"
    ]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["encoding"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function videoFromVertex$1(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  var Outcome;
  (function(Outcome2) {
    Outcome2["OUTCOME_UNSPECIFIED"] = "OUTCOME_UNSPECIFIED";
    Outcome2["OUTCOME_OK"] = "OUTCOME_OK";
    Outcome2["OUTCOME_FAILED"] = "OUTCOME_FAILED";
    Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "OUTCOME_DEADLINE_EXCEEDED";
  })(Outcome || (Outcome = {}));
  var Language;
  (function(Language2) {
    Language2["LANGUAGE_UNSPECIFIED"] = "LANGUAGE_UNSPECIFIED";
    Language2["PYTHON"] = "PYTHON";
  })(Language || (Language = {}));
  var Type;
  (function(Type2) {
    Type2["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
    Type2["STRING"] = "STRING";
    Type2["NUMBER"] = "NUMBER";
    Type2["INTEGER"] = "INTEGER";
    Type2["BOOLEAN"] = "BOOLEAN";
    Type2["ARRAY"] = "ARRAY";
    Type2["OBJECT"] = "OBJECT";
    Type2["NULL"] = "NULL";
  })(Type || (Type = {}));
  var HarmCategory;
  (function(HarmCategory2) {
    HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
    HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
    HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
    HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
    HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
    HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
    HarmCategory2["HARM_CATEGORY_IMAGE_HATE"] = "HARM_CATEGORY_IMAGE_HATE";
    HarmCategory2["HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT"] = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT";
    HarmCategory2["HARM_CATEGORY_IMAGE_HARASSMENT"] = "HARM_CATEGORY_IMAGE_HARASSMENT";
    HarmCategory2["HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT";
  })(HarmCategory || (HarmCategory = {}));
  var HarmBlockMethod;
  (function(HarmBlockMethod2) {
    HarmBlockMethod2["HARM_BLOCK_METHOD_UNSPECIFIED"] = "HARM_BLOCK_METHOD_UNSPECIFIED";
    HarmBlockMethod2["SEVERITY"] = "SEVERITY";
    HarmBlockMethod2["PROBABILITY"] = "PROBABILITY";
  })(HarmBlockMethod || (HarmBlockMethod = {}));
  var HarmBlockThreshold;
  (function(HarmBlockThreshold2) {
    HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
    HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
    HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
    HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
    HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
    HarmBlockThreshold2["OFF"] = "OFF";
  })(HarmBlockThreshold || (HarmBlockThreshold = {}));
  var Mode;
  (function(Mode2) {
    Mode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
    Mode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
  })(Mode || (Mode = {}));
  var AuthType;
  (function(AuthType2) {
    AuthType2["AUTH_TYPE_UNSPECIFIED"] = "AUTH_TYPE_UNSPECIFIED";
    AuthType2["NO_AUTH"] = "NO_AUTH";
    AuthType2["API_KEY_AUTH"] = "API_KEY_AUTH";
    AuthType2["HTTP_BASIC_AUTH"] = "HTTP_BASIC_AUTH";
    AuthType2["GOOGLE_SERVICE_ACCOUNT_AUTH"] = "GOOGLE_SERVICE_ACCOUNT_AUTH";
    AuthType2["OAUTH"] = "OAUTH";
    AuthType2["OIDC_AUTH"] = "OIDC_AUTH";
  })(AuthType || (AuthType = {}));
  var ApiSpec;
  (function(ApiSpec2) {
    ApiSpec2["API_SPEC_UNSPECIFIED"] = "API_SPEC_UNSPECIFIED";
    ApiSpec2["SIMPLE_SEARCH"] = "SIMPLE_SEARCH";
    ApiSpec2["ELASTIC_SEARCH"] = "ELASTIC_SEARCH";
  })(ApiSpec || (ApiSpec = {}));
  var UrlRetrievalStatus;
  (function(UrlRetrievalStatus2) {
    UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSPECIFIED"] = "URL_RETRIEVAL_STATUS_UNSPECIFIED";
    UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_SUCCESS"] = "URL_RETRIEVAL_STATUS_SUCCESS";
    UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_ERROR"] = "URL_RETRIEVAL_STATUS_ERROR";
    UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_PAYWALL"] = "URL_RETRIEVAL_STATUS_PAYWALL";
    UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSAFE"] = "URL_RETRIEVAL_STATUS_UNSAFE";
  })(UrlRetrievalStatus || (UrlRetrievalStatus = {}));
  var FinishReason;
  (function(FinishReason2) {
    FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
    FinishReason2["STOP"] = "STOP";
    FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
    FinishReason2["SAFETY"] = "SAFETY";
    FinishReason2["RECITATION"] = "RECITATION";
    FinishReason2["LANGUAGE"] = "LANGUAGE";
    FinishReason2["OTHER"] = "OTHER";
    FinishReason2["BLOCKLIST"] = "BLOCKLIST";
    FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
    FinishReason2["SPII"] = "SPII";
    FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
    FinishReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
    FinishReason2["UNEXPECTED_TOOL_CALL"] = "UNEXPECTED_TOOL_CALL";
  })(FinishReason || (FinishReason = {}));
  var HarmProbability;
  (function(HarmProbability2) {
    HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
    HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
    HarmProbability2["LOW"] = "LOW";
    HarmProbability2["MEDIUM"] = "MEDIUM";
    HarmProbability2["HIGH"] = "HIGH";
  })(HarmProbability || (HarmProbability = {}));
  var HarmSeverity;
  (function(HarmSeverity2) {
    HarmSeverity2["HARM_SEVERITY_UNSPECIFIED"] = "HARM_SEVERITY_UNSPECIFIED";
    HarmSeverity2["HARM_SEVERITY_NEGLIGIBLE"] = "HARM_SEVERITY_NEGLIGIBLE";
    HarmSeverity2["HARM_SEVERITY_LOW"] = "HARM_SEVERITY_LOW";
    HarmSeverity2["HARM_SEVERITY_MEDIUM"] = "HARM_SEVERITY_MEDIUM";
    HarmSeverity2["HARM_SEVERITY_HIGH"] = "HARM_SEVERITY_HIGH";
  })(HarmSeverity || (HarmSeverity = {}));
  var BlockedReason;
  (function(BlockedReason2) {
    BlockedReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
    BlockedReason2["SAFETY"] = "SAFETY";
    BlockedReason2["OTHER"] = "OTHER";
    BlockedReason2["BLOCKLIST"] = "BLOCKLIST";
    BlockedReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
    BlockedReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
  })(BlockedReason || (BlockedReason = {}));
  var TrafficType;
  (function(TrafficType2) {
    TrafficType2["TRAFFIC_TYPE_UNSPECIFIED"] = "TRAFFIC_TYPE_UNSPECIFIED";
    TrafficType2["ON_DEMAND"] = "ON_DEMAND";
    TrafficType2["PROVISIONED_THROUGHPUT"] = "PROVISIONED_THROUGHPUT";
  })(TrafficType || (TrafficType = {}));
  var Modality;
  (function(Modality2) {
    Modality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
    Modality2["TEXT"] = "TEXT";
    Modality2["IMAGE"] = "IMAGE";
    Modality2["AUDIO"] = "AUDIO";
  })(Modality || (Modality = {}));
  var MediaResolution;
  (function(MediaResolution2) {
    MediaResolution2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
    MediaResolution2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
    MediaResolution2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
    MediaResolution2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
  })(MediaResolution || (MediaResolution = {}));
  var JobState;
  (function(JobState2) {
    JobState2["JOB_STATE_UNSPECIFIED"] = "JOB_STATE_UNSPECIFIED";
    JobState2["JOB_STATE_QUEUED"] = "JOB_STATE_QUEUED";
    JobState2["JOB_STATE_PENDING"] = "JOB_STATE_PENDING";
    JobState2["JOB_STATE_RUNNING"] = "JOB_STATE_RUNNING";
    JobState2["JOB_STATE_SUCCEEDED"] = "JOB_STATE_SUCCEEDED";
    JobState2["JOB_STATE_FAILED"] = "JOB_STATE_FAILED";
    JobState2["JOB_STATE_CANCELLING"] = "JOB_STATE_CANCELLING";
    JobState2["JOB_STATE_CANCELLED"] = "JOB_STATE_CANCELLED";
    JobState2["JOB_STATE_PAUSED"] = "JOB_STATE_PAUSED";
    JobState2["JOB_STATE_EXPIRED"] = "JOB_STATE_EXPIRED";
    JobState2["JOB_STATE_UPDATING"] = "JOB_STATE_UPDATING";
    JobState2["JOB_STATE_PARTIALLY_SUCCEEDED"] = "JOB_STATE_PARTIALLY_SUCCEEDED";
  })(JobState || (JobState = {}));
  var TuningMode;
  (function(TuningMode2) {
    TuningMode2["TUNING_MODE_UNSPECIFIED"] = "TUNING_MODE_UNSPECIFIED";
    TuningMode2["TUNING_MODE_FULL"] = "TUNING_MODE_FULL";
    TuningMode2["TUNING_MODE_PEFT_ADAPTER"] = "TUNING_MODE_PEFT_ADAPTER";
  })(TuningMode || (TuningMode = {}));
  var AdapterSize;
  (function(AdapterSize2) {
    AdapterSize2["ADAPTER_SIZE_UNSPECIFIED"] = "ADAPTER_SIZE_UNSPECIFIED";
    AdapterSize2["ADAPTER_SIZE_ONE"] = "ADAPTER_SIZE_ONE";
    AdapterSize2["ADAPTER_SIZE_TWO"] = "ADAPTER_SIZE_TWO";
    AdapterSize2["ADAPTER_SIZE_FOUR"] = "ADAPTER_SIZE_FOUR";
    AdapterSize2["ADAPTER_SIZE_EIGHT"] = "ADAPTER_SIZE_EIGHT";
    AdapterSize2["ADAPTER_SIZE_SIXTEEN"] = "ADAPTER_SIZE_SIXTEEN";
    AdapterSize2["ADAPTER_SIZE_THIRTY_TWO"] = "ADAPTER_SIZE_THIRTY_TWO";
  })(AdapterSize || (AdapterSize = {}));
  var FeatureSelectionPreference;
  (function(FeatureSelectionPreference2) {
    FeatureSelectionPreference2["FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"] = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED";
    FeatureSelectionPreference2["PRIORITIZE_QUALITY"] = "PRIORITIZE_QUALITY";
    FeatureSelectionPreference2["BALANCED"] = "BALANCED";
    FeatureSelectionPreference2["PRIORITIZE_COST"] = "PRIORITIZE_COST";
  })(FeatureSelectionPreference || (FeatureSelectionPreference = {}));
  var Behavior;
  (function(Behavior2) {
    Behavior2["UNSPECIFIED"] = "UNSPECIFIED";
    Behavior2["BLOCKING"] = "BLOCKING";
    Behavior2["NON_BLOCKING"] = "NON_BLOCKING";
  })(Behavior || (Behavior = {}));
  var DynamicRetrievalConfigMode;
  (function(DynamicRetrievalConfigMode2) {
    DynamicRetrievalConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
    DynamicRetrievalConfigMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
  })(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));
  var Environment;
  (function(Environment2) {
    Environment2["ENVIRONMENT_UNSPECIFIED"] = "ENVIRONMENT_UNSPECIFIED";
    Environment2["ENVIRONMENT_BROWSER"] = "ENVIRONMENT_BROWSER";
  })(Environment || (Environment = {}));
  var FunctionCallingConfigMode;
  (function(FunctionCallingConfigMode2) {
    FunctionCallingConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
    FunctionCallingConfigMode2["AUTO"] = "AUTO";
    FunctionCallingConfigMode2["ANY"] = "ANY";
    FunctionCallingConfigMode2["NONE"] = "NONE";
    FunctionCallingConfigMode2["VALIDATED"] = "VALIDATED";
  })(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));
  var SafetyFilterLevel;
  (function(SafetyFilterLevel2) {
    SafetyFilterLevel2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
    SafetyFilterLevel2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
    SafetyFilterLevel2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
    SafetyFilterLevel2["BLOCK_NONE"] = "BLOCK_NONE";
  })(SafetyFilterLevel || (SafetyFilterLevel = {}));
  var PersonGeneration;
  (function(PersonGeneration2) {
    PersonGeneration2["DONT_ALLOW"] = "DONT_ALLOW";
    PersonGeneration2["ALLOW_ADULT"] = "ALLOW_ADULT";
    PersonGeneration2["ALLOW_ALL"] = "ALLOW_ALL";
  })(PersonGeneration || (PersonGeneration = {}));
  var ImagePromptLanguage;
  (function(ImagePromptLanguage2) {
    ImagePromptLanguage2["auto"] = "auto";
    ImagePromptLanguage2["en"] = "en";
    ImagePromptLanguage2["ja"] = "ja";
    ImagePromptLanguage2["ko"] = "ko";
    ImagePromptLanguage2["hi"] = "hi";
    ImagePromptLanguage2["zh"] = "zh";
    ImagePromptLanguage2["pt"] = "pt";
    ImagePromptLanguage2["es"] = "es";
  })(ImagePromptLanguage || (ImagePromptLanguage = {}));
  var MaskReferenceMode;
  (function(MaskReferenceMode2) {
    MaskReferenceMode2["MASK_MODE_DEFAULT"] = "MASK_MODE_DEFAULT";
    MaskReferenceMode2["MASK_MODE_USER_PROVIDED"] = "MASK_MODE_USER_PROVIDED";
    MaskReferenceMode2["MASK_MODE_BACKGROUND"] = "MASK_MODE_BACKGROUND";
    MaskReferenceMode2["MASK_MODE_FOREGROUND"] = "MASK_MODE_FOREGROUND";
    MaskReferenceMode2["MASK_MODE_SEMANTIC"] = "MASK_MODE_SEMANTIC";
  })(MaskReferenceMode || (MaskReferenceMode = {}));
  var ControlReferenceType;
  (function(ControlReferenceType2) {
    ControlReferenceType2["CONTROL_TYPE_DEFAULT"] = "CONTROL_TYPE_DEFAULT";
    ControlReferenceType2["CONTROL_TYPE_CANNY"] = "CONTROL_TYPE_CANNY";
    ControlReferenceType2["CONTROL_TYPE_SCRIBBLE"] = "CONTROL_TYPE_SCRIBBLE";
    ControlReferenceType2["CONTROL_TYPE_FACE_MESH"] = "CONTROL_TYPE_FACE_MESH";
  })(ControlReferenceType || (ControlReferenceType = {}));
  var SubjectReferenceType;
  (function(SubjectReferenceType2) {
    SubjectReferenceType2["SUBJECT_TYPE_DEFAULT"] = "SUBJECT_TYPE_DEFAULT";
    SubjectReferenceType2["SUBJECT_TYPE_PERSON"] = "SUBJECT_TYPE_PERSON";
    SubjectReferenceType2["SUBJECT_TYPE_ANIMAL"] = "SUBJECT_TYPE_ANIMAL";
    SubjectReferenceType2["SUBJECT_TYPE_PRODUCT"] = "SUBJECT_TYPE_PRODUCT";
  })(SubjectReferenceType || (SubjectReferenceType = {}));
  var EditMode;
  (function(EditMode2) {
    EditMode2["EDIT_MODE_DEFAULT"] = "EDIT_MODE_DEFAULT";
    EditMode2["EDIT_MODE_INPAINT_REMOVAL"] = "EDIT_MODE_INPAINT_REMOVAL";
    EditMode2["EDIT_MODE_INPAINT_INSERTION"] = "EDIT_MODE_INPAINT_INSERTION";
    EditMode2["EDIT_MODE_OUTPAINT"] = "EDIT_MODE_OUTPAINT";
    EditMode2["EDIT_MODE_CONTROLLED_EDITING"] = "EDIT_MODE_CONTROLLED_EDITING";
    EditMode2["EDIT_MODE_STYLE"] = "EDIT_MODE_STYLE";
    EditMode2["EDIT_MODE_BGSWAP"] = "EDIT_MODE_BGSWAP";
    EditMode2["EDIT_MODE_PRODUCT_IMAGE"] = "EDIT_MODE_PRODUCT_IMAGE";
  })(EditMode || (EditMode = {}));
  var SegmentMode;
  (function(SegmentMode2) {
    SegmentMode2["FOREGROUND"] = "FOREGROUND";
    SegmentMode2["BACKGROUND"] = "BACKGROUND";
    SegmentMode2["PROMPT"] = "PROMPT";
    SegmentMode2["SEMANTIC"] = "SEMANTIC";
    SegmentMode2["INTERACTIVE"] = "INTERACTIVE";
  })(SegmentMode || (SegmentMode = {}));
  var VideoGenerationReferenceType;
  (function(VideoGenerationReferenceType2) {
    VideoGenerationReferenceType2["ASSET"] = "ASSET";
    VideoGenerationReferenceType2["STYLE"] = "STYLE";
  })(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));
  var VideoGenerationMaskMode;
  (function(VideoGenerationMaskMode2) {
    VideoGenerationMaskMode2["INSERT"] = "INSERT";
    VideoGenerationMaskMode2["REMOVE"] = "REMOVE";
    VideoGenerationMaskMode2["REMOVE_STATIC"] = "REMOVE_STATIC";
    VideoGenerationMaskMode2["OUTPAINT"] = "OUTPAINT";
  })(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));
  var VideoCompressionQuality;
  (function(VideoCompressionQuality2) {
    VideoCompressionQuality2["OPTIMIZED"] = "OPTIMIZED";
    VideoCompressionQuality2["LOSSLESS"] = "LOSSLESS";
  })(VideoCompressionQuality || (VideoCompressionQuality = {}));
  var FileState;
  (function(FileState2) {
    FileState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
    FileState2["PROCESSING"] = "PROCESSING";
    FileState2["ACTIVE"] = "ACTIVE";
    FileState2["FAILED"] = "FAILED";
  })(FileState || (FileState = {}));
  var FileSource;
  (function(FileSource2) {
    FileSource2["SOURCE_UNSPECIFIED"] = "SOURCE_UNSPECIFIED";
    FileSource2["UPLOADED"] = "UPLOADED";
    FileSource2["GENERATED"] = "GENERATED";
  })(FileSource || (FileSource = {}));
  var TurnCompleteReason;
  (function(TurnCompleteReason2) {
    TurnCompleteReason2["TURN_COMPLETE_REASON_UNSPECIFIED"] = "TURN_COMPLETE_REASON_UNSPECIFIED";
    TurnCompleteReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
    TurnCompleteReason2["RESPONSE_REJECTED"] = "RESPONSE_REJECTED";
    TurnCompleteReason2["NEED_MORE_INPUT"] = "NEED_MORE_INPUT";
  })(TurnCompleteReason || (TurnCompleteReason = {}));
  var MediaModality;
  (function(MediaModality2) {
    MediaModality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
    MediaModality2["TEXT"] = "TEXT";
    MediaModality2["IMAGE"] = "IMAGE";
    MediaModality2["VIDEO"] = "VIDEO";
    MediaModality2["AUDIO"] = "AUDIO";
    MediaModality2["DOCUMENT"] = "DOCUMENT";
  })(MediaModality || (MediaModality = {}));
  var StartSensitivity;
  (function(StartSensitivity2) {
    StartSensitivity2["START_SENSITIVITY_UNSPECIFIED"] = "START_SENSITIVITY_UNSPECIFIED";
    StartSensitivity2["START_SENSITIVITY_HIGH"] = "START_SENSITIVITY_HIGH";
    StartSensitivity2["START_SENSITIVITY_LOW"] = "START_SENSITIVITY_LOW";
  })(StartSensitivity || (StartSensitivity = {}));
  var EndSensitivity;
  (function(EndSensitivity2) {
    EndSensitivity2["END_SENSITIVITY_UNSPECIFIED"] = "END_SENSITIVITY_UNSPECIFIED";
    EndSensitivity2["END_SENSITIVITY_HIGH"] = "END_SENSITIVITY_HIGH";
    EndSensitivity2["END_SENSITIVITY_LOW"] = "END_SENSITIVITY_LOW";
  })(EndSensitivity || (EndSensitivity = {}));
  var ActivityHandling;
  (function(ActivityHandling2) {
    ActivityHandling2["ACTIVITY_HANDLING_UNSPECIFIED"] = "ACTIVITY_HANDLING_UNSPECIFIED";
    ActivityHandling2["START_OF_ACTIVITY_INTERRUPTS"] = "START_OF_ACTIVITY_INTERRUPTS";
    ActivityHandling2["NO_INTERRUPTION"] = "NO_INTERRUPTION";
  })(ActivityHandling || (ActivityHandling = {}));
  var TurnCoverage;
  (function(TurnCoverage2) {
    TurnCoverage2["TURN_COVERAGE_UNSPECIFIED"] = "TURN_COVERAGE_UNSPECIFIED";
    TurnCoverage2["TURN_INCLUDES_ONLY_ACTIVITY"] = "TURN_INCLUDES_ONLY_ACTIVITY";
    TurnCoverage2["TURN_INCLUDES_ALL_INPUT"] = "TURN_INCLUDES_ALL_INPUT";
  })(TurnCoverage || (TurnCoverage = {}));
  var FunctionResponseScheduling;
  (function(FunctionResponseScheduling2) {
    FunctionResponseScheduling2["SCHEDULING_UNSPECIFIED"] = "SCHEDULING_UNSPECIFIED";
    FunctionResponseScheduling2["SILENT"] = "SILENT";
    FunctionResponseScheduling2["WHEN_IDLE"] = "WHEN_IDLE";
    FunctionResponseScheduling2["INTERRUPT"] = "INTERRUPT";
  })(FunctionResponseScheduling || (FunctionResponseScheduling = {}));
  var Scale;
  (function(Scale2) {
    Scale2["SCALE_UNSPECIFIED"] = "SCALE_UNSPECIFIED";
    Scale2["C_MAJOR_A_MINOR"] = "C_MAJOR_A_MINOR";
    Scale2["D_FLAT_MAJOR_B_FLAT_MINOR"] = "D_FLAT_MAJOR_B_FLAT_MINOR";
    Scale2["D_MAJOR_B_MINOR"] = "D_MAJOR_B_MINOR";
    Scale2["E_FLAT_MAJOR_C_MINOR"] = "E_FLAT_MAJOR_C_MINOR";
    Scale2["E_MAJOR_D_FLAT_MINOR"] = "E_MAJOR_D_FLAT_MINOR";
    Scale2["F_MAJOR_D_MINOR"] = "F_MAJOR_D_MINOR";
    Scale2["G_FLAT_MAJOR_E_FLAT_MINOR"] = "G_FLAT_MAJOR_E_FLAT_MINOR";
    Scale2["G_MAJOR_E_MINOR"] = "G_MAJOR_E_MINOR";
    Scale2["A_FLAT_MAJOR_F_MINOR"] = "A_FLAT_MAJOR_F_MINOR";
    Scale2["A_MAJOR_G_FLAT_MINOR"] = "A_MAJOR_G_FLAT_MINOR";
    Scale2["B_FLAT_MAJOR_G_MINOR"] = "B_FLAT_MAJOR_G_MINOR";
    Scale2["B_MAJOR_A_FLAT_MINOR"] = "B_MAJOR_A_FLAT_MINOR";
  })(Scale || (Scale = {}));
  var MusicGenerationMode;
  (function(MusicGenerationMode2) {
    MusicGenerationMode2["MUSIC_GENERATION_MODE_UNSPECIFIED"] = "MUSIC_GENERATION_MODE_UNSPECIFIED";
    MusicGenerationMode2["QUALITY"] = "QUALITY";
    MusicGenerationMode2["DIVERSITY"] = "DIVERSITY";
    MusicGenerationMode2["VOCALIZATION"] = "VOCALIZATION";
  })(MusicGenerationMode || (MusicGenerationMode = {}));
  var LiveMusicPlaybackControl;
  (function(LiveMusicPlaybackControl2) {
    LiveMusicPlaybackControl2["PLAYBACK_CONTROL_UNSPECIFIED"] = "PLAYBACK_CONTROL_UNSPECIFIED";
    LiveMusicPlaybackControl2["PLAY"] = "PLAY";
    LiveMusicPlaybackControl2["PAUSE"] = "PAUSE";
    LiveMusicPlaybackControl2["STOP"] = "STOP";
    LiveMusicPlaybackControl2["RESET_CONTEXT"] = "RESET_CONTEXT";
  })(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));
  var HttpResponse = class {
    constructor(response) {
      const headers = {};
      for (const pair of response.headers.entries()) {
        headers[pair[0]] = pair[1];
      }
      this.headers = headers;
      this.responseInternal = response;
    }
    json() {
      return this.responseInternal.json();
    }
  };
  var GenerateContentResponse = class {
    /**
     * Returns the concatenation of all text parts from the first candidate in the response.
     *
     * @remarks
     * If there are multiple candidates in the response, the text from the first
     * one will be returned.
     * If there are non-text parts in the response, the concatenation of all text
     * parts will be returned, and a warning will be logged.
     * If there are thought parts in the response, the concatenation of all text
     * parts excluding the thought parts will be returned.
     *
     * @example
     * ```ts
     * const response = await ai.models.generateContent({
     *   model: 'gemini-2.0-flash',
     *   contents:
     *     'Why is the sky blue?',
     * });
     *
     * console.debug(response.text);
     * ```
     */
    get text() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
        return void 0;
      }
      if (this.candidates && this.candidates.length > 1) {
        console.warn("there are multiple candidates in the response, returning text from the first one.");
      }
      let text = "";
      let anyTextPartText = false;
      const nonTextParts = [];
      for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
        for (const [fieldName, fieldValue] of Object.entries(part)) {
          if (fieldName !== "text" && fieldName !== "thought" && (fieldValue !== null || fieldValue !== void 0)) {
            nonTextParts.push(fieldName);
          }
        }
        if (typeof part.text === "string") {
          if (typeof part.thought === "boolean" && part.thought) {
            continue;
          }
          anyTextPartText = true;
          text += part.text;
        }
      }
      if (nonTextParts.length > 0) {
        console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
      }
      return anyTextPartText ? text : void 0;
    }
    /**
     * Returns the concatenation of all inline data parts from the first candidate
     * in the response.
     *
     * @remarks
     * If there are multiple candidates in the response, the inline data from the
     * first one will be returned. If there are non-inline data parts in the
     * response, the concatenation of all inline data parts will be returned, and
     * a warning will be logged.
     */
    get data() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
        return void 0;
      }
      if (this.candidates && this.candidates.length > 1) {
        console.warn("there are multiple candidates in the response, returning data from the first one.");
      }
      let data = "";
      const nonDataParts = [];
      for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
        for (const [fieldName, fieldValue] of Object.entries(part)) {
          if (fieldName !== "inlineData" && (fieldValue !== null || fieldValue !== void 0)) {
            nonDataParts.push(fieldName);
          }
        }
        if (part.inlineData && typeof part.inlineData.data === "string") {
          data += atob(part.inlineData.data);
        }
      }
      if (nonDataParts.length > 0) {
        console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
      }
      return data.length > 0 ? btoa(data) : void 0;
    }
    /**
     * Returns the function calls from the first candidate in the response.
     *
     * @remarks
     * If there are multiple candidates in the response, the function calls from
     * the first one will be returned.
     * If there are no function calls in the response, undefined will be returned.
     *
     * @example
     * ```ts
     * const controlLightFunctionDeclaration: FunctionDeclaration = {
     *   name: 'controlLight',
     *   parameters: {
     *   type: Type.OBJECT,
     *   description: 'Set the brightness and color temperature of a room light.',
     *   properties: {
     *     brightness: {
     *       type: Type.NUMBER,
     *       description:
     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
     *     },
     *     colorTemperature: {
     *       type: Type.STRING,
     *       description:
     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
     *     },
     *   },
     *   required: ['brightness', 'colorTemperature'],
     *  };
     *  const response = await ai.models.generateContent({
     *     model: 'gemini-2.0-flash',
     *     contents: 'Dim the lights so the room feels cozy and warm.',
     *     config: {
     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
     *       toolConfig: {
     *         functionCallingConfig: {
     *           mode: FunctionCallingConfigMode.ANY,
     *           allowedFunctionNames: ['controlLight'],
     *         },
     *       },
     *     },
     *   });
     *  console.debug(JSON.stringify(response.functionCalls));
     * ```
     */
    get functionCalls() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
        return void 0;
      }
      if (this.candidates && this.candidates.length > 1) {
        console.warn("there are multiple candidates in the response, returning function calls from the first one.");
      }
      const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== void 0);
      if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {
        return void 0;
      }
      return functionCalls;
    }
    /**
     * Returns the first executable code from the first candidate in the response.
     *
     * @remarks
     * If there are multiple candidates in the response, the executable code from
     * the first one will be returned.
     * If there are no executable code in the response, undefined will be
     * returned.
     *
     * @example
     * ```ts
     * const response = await ai.models.generateContent({
     *   model: 'gemini-2.0-flash',
     *   contents:
     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
     *   config: {
     *     tools: [{codeExecution: {}}],
     *   },
     * });
     *
     * console.debug(response.executableCode);
     * ```
     */
    get executableCode() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
        return void 0;
      }
      if (this.candidates && this.candidates.length > 1) {
        console.warn("there are multiple candidates in the response, returning executable code from the first one.");
      }
      const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode2) => executableCode2 !== void 0);
      if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {
        return void 0;
      }
      return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;
    }
    /**
     * Returns the first code execution result from the first candidate in the response.
     *
     * @remarks
     * If there are multiple candidates in the response, the code execution result from
     * the first one will be returned.
     * If there are no code execution result in the response, undefined will be returned.
     *
     * @example
     * ```ts
     * const response = await ai.models.generateContent({
     *   model: 'gemini-2.0-flash',
     *   contents:
     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
     *   config: {
     *     tools: [{codeExecution: {}}],
     *   },
     * });
     *
     * console.debug(response.codeExecutionResult);
     * ```
     */
    get codeExecutionResult() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
        return void 0;
      }
      if (this.candidates && this.candidates.length > 1) {
        console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
      }
      const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult2) => codeExecutionResult2 !== void 0);
      if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {
        return void 0;
      }
      return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;
    }
  };
  var EmbedContentResponse = class {
  };
  var GenerateImagesResponse = class {
  };
  var EditImageResponse = class {
  };
  var UpscaleImageResponse = class {
  };
  var RecontextImageResponse = class {
  };
  var SegmentImageResponse = class {
  };
  var ListModelsResponse = class {
  };
  var DeleteModelResponse = class {
  };
  var CountTokensResponse = class {
  };
  var ComputeTokensResponse = class {
  };
  var GenerateVideosOperation = class _GenerateVideosOperation {
    /**
     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
     * @internal
     */
    _fromAPIResponse({ apiResponse, isVertexAI }) {
      const operation = new _GenerateVideosOperation();
      let response;
      const op = apiResponse;
      if (isVertexAI) {
        response = generateVideosOperationFromVertex$1(op);
      } else {
        response = generateVideosOperationFromMldev$1(op);
      }
      Object.assign(operation, response);
      return operation;
    }
  };
  var ListTuningJobsResponse = class {
  };
  var DeleteCachedContentResponse = class {
  };
  var ListCachedContentsResponse = class {
  };
  var ListFilesResponse = class {
  };
  var CreateFileResponse = class {
  };
  var DeleteFileResponse = class {
  };
  var ListBatchJobsResponse = class {
  };
  var LiveServerMessage = class {
    /**
     * Returns the concatenation of all text parts from the server content if present.
     *
     * @remarks
     * If there are non-text parts in the response, the concatenation of all text
     * parts will be returned, and a warning will be logged.
     */
    get text() {
      var _a, _b, _c;
      let text = "";
      let anyTextPartFound = false;
      const nonTextParts = [];
      for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
        for (const [fieldName, fieldValue] of Object.entries(part)) {
          if (fieldName !== "text" && fieldName !== "thought" && fieldValue !== null) {
            nonTextParts.push(fieldName);
          }
        }
        if (typeof part.text === "string") {
          if (typeof part.thought === "boolean" && part.thought) {
            continue;
          }
          anyTextPartFound = true;
          text += part.text;
        }
      }
      if (nonTextParts.length > 0) {
        console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
      }
      return anyTextPartFound ? text : void 0;
    }
    /**
     * Returns the concatenation of all inline data parts from the server content if present.
     *
     * @remarks
     * If there are non-inline data parts in the
     * response, the concatenation of all inline data parts will be returned, and
     * a warning will be logged.
     */
    get data() {
      var _a, _b, _c;
      let data = "";
      const nonDataParts = [];
      for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
        for (const [fieldName, fieldValue] of Object.entries(part)) {
          if (fieldName !== "inlineData" && fieldValue !== null) {
            nonDataParts.push(fieldName);
          }
        }
        if (part.inlineData && typeof part.inlineData.data === "string") {
          data += atob(part.inlineData.data);
        }
      }
      if (nonDataParts.length > 0) {
        console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
      }
      return data.length > 0 ? btoa(data) : void 0;
    }
  };
  var LiveMusicServerMessage = class {
    /**
     * Returns the first audio chunk from the server content, if present.
     *
     * @remarks
     * If there are no audio chunks in the response, undefined will be returned.
     */
    get audioChunk() {
      if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {
        return this.serverContent.audioChunks[0];
      }
      return void 0;
    }
  };
  function tModel(apiClient, model) {
    if (!model || typeof model !== "string") {
      throw new Error("model is required and must be a string");
    }
    if (apiClient.isVertexAI()) {
      if (model.startsWith("publishers/") || model.startsWith("projects/") || model.startsWith("models/")) {
        return model;
      } else if (model.indexOf("/") >= 0) {
        const parts = model.split("/", 2);
        return `publishers/${parts[0]}/models/${parts[1]}`;
      } else {
        return `publishers/google/models/${model}`;
      }
    } else {
      if (model.startsWith("models/") || model.startsWith("tunedModels/")) {
        return model;
      } else {
        return `models/${model}`;
      }
    }
  }
  function tCachesModel(apiClient, model) {
    const transformedModel = tModel(apiClient, model);
    if (!transformedModel) {
      return "";
    }
    if (transformedModel.startsWith("publishers/") && apiClient.isVertexAI()) {
      return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;
    } else if (transformedModel.startsWith("models/") && apiClient.isVertexAI()) {
      return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;
    } else {
      return transformedModel;
    }
  }
  function tBlobs(blobs) {
    if (Array.isArray(blobs)) {
      return blobs.map((blob) => tBlob(blob));
    } else {
      return [tBlob(blobs)];
    }
  }
  function tBlob(blob) {
    if (typeof blob === "object" && blob !== null) {
      return blob;
    }
    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);
  }
  function tImageBlob(blob) {
    const transformedBlob = tBlob(blob);
    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("image/")) {
      return transformedBlob;
    }
    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
  }
  function tAudioBlob(blob) {
    const transformedBlob = tBlob(blob);
    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("audio/")) {
      return transformedBlob;
    }
    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
  }
  function tPart(origin) {
    if (origin === null || origin === void 0) {
      throw new Error("PartUnion is required");
    }
    if (typeof origin === "object") {
      return origin;
    }
    if (typeof origin === "string") {
      return { text: origin };
    }
    throw new Error(`Unsupported part type: ${typeof origin}`);
  }
  function tParts(origin) {
    if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
      throw new Error("PartListUnion is required");
    }
    if (Array.isArray(origin)) {
      return origin.map((item) => tPart(item));
    }
    return [tPart(origin)];
  }
  function _isContent(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "parts" in origin && Array.isArray(origin.parts);
  }
  function _isFunctionCallPart(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "functionCall" in origin;
  }
  function _isFunctionResponsePart(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "functionResponse" in origin;
  }
  function tContent(origin) {
    if (origin === null || origin === void 0) {
      throw new Error("ContentUnion is required");
    }
    if (_isContent(origin)) {
      return origin;
    }
    return {
      role: "user",
      parts: tParts(origin)
    };
  }
  function tContentsForEmbed(apiClient, origin) {
    if (!origin) {
      return [];
    }
    if (apiClient.isVertexAI() && Array.isArray(origin)) {
      return origin.flatMap((item) => {
        const content = tContent(item);
        if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
          return [content.parts[0].text];
        }
        return [];
      });
    } else if (apiClient.isVertexAI()) {
      const content = tContent(origin);
      if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
        return [content.parts[0].text];
      }
      return [];
    }
    if (Array.isArray(origin)) {
      return origin.map((item) => tContent(item));
    }
    return [tContent(origin)];
  }
  function tContents(origin) {
    if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
      throw new Error("contents are required");
    }
    if (!Array.isArray(origin)) {
      if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {
        throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
      }
      return [tContent(origin)];
    }
    const result = [];
    const accumulatedParts = [];
    const isContentArray = _isContent(origin[0]);
    for (const item of origin) {
      const isContent = _isContent(item);
      if (isContent != isContentArray) {
        throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
      }
      if (isContent) {
        result.push(item);
      } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {
        throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
      } else {
        accumulatedParts.push(item);
      }
    }
    if (!isContentArray) {
      result.push({ role: "user", parts: tParts(accumulatedParts) });
    }
    return result;
  }
  function flattenTypeArrayToAnyOf(typeList, resultingSchema) {
    if (typeList.includes("null")) {
      resultingSchema["nullable"] = true;
    }
    const listWithoutNull = typeList.filter((type) => type !== "null");
    if (listWithoutNull.length === 1) {
      resultingSchema["type"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;
    } else {
      resultingSchema["anyOf"] = [];
      for (const i of listWithoutNull) {
        resultingSchema["anyOf"].push({
          "type": Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED
        });
      }
    }
  }
  function processJsonSchema(_jsonSchema) {
    const genAISchema = {};
    const schemaFieldNames = ["items"];
    const listSchemaFieldNames = ["anyOf"];
    const dictSchemaFieldNames = ["properties"];
    if (_jsonSchema["type"] && _jsonSchema["anyOf"]) {
      throw new Error("type and anyOf cannot be both populated.");
    }
    const incomingAnyOf = _jsonSchema["anyOf"];
    if (incomingAnyOf != null && incomingAnyOf.length == 2) {
      if (incomingAnyOf[0]["type"] === "null") {
        genAISchema["nullable"] = true;
        _jsonSchema = incomingAnyOf[1];
      } else if (incomingAnyOf[1]["type"] === "null") {
        genAISchema["nullable"] = true;
        _jsonSchema = incomingAnyOf[0];
      }
    }
    if (_jsonSchema["type"] instanceof Array) {
      flattenTypeArrayToAnyOf(_jsonSchema["type"], genAISchema);
    }
    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {
      if (fieldValue == null) {
        continue;
      }
      if (fieldName == "type") {
        if (fieldValue === "null") {
          throw new Error("type: null can not be the only possible type for the field.");
        }
        if (fieldValue instanceof Array) {
          continue;
        }
        genAISchema["type"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;
      } else if (schemaFieldNames.includes(fieldName)) {
        genAISchema[fieldName] = processJsonSchema(fieldValue);
      } else if (listSchemaFieldNames.includes(fieldName)) {
        const listSchemaFieldValue = [];
        for (const item of fieldValue) {
          if (item["type"] == "null") {
            genAISchema["nullable"] = true;
            continue;
          }
          listSchemaFieldValue.push(processJsonSchema(item));
        }
        genAISchema[fieldName] = listSchemaFieldValue;
      } else if (dictSchemaFieldNames.includes(fieldName)) {
        const dictSchemaFieldValue = {};
        for (const [key, value] of Object.entries(fieldValue)) {
          dictSchemaFieldValue[key] = processJsonSchema(value);
        }
        genAISchema[fieldName] = dictSchemaFieldValue;
      } else {
        if (fieldName === "additionalProperties") {
          continue;
        }
        genAISchema[fieldName] = fieldValue;
      }
    }
    return genAISchema;
  }
  function tSchema(schema) {
    return processJsonSchema(schema);
  }
  function tSpeechConfig(speechConfig) {
    if (typeof speechConfig === "object") {
      return speechConfig;
    } else if (typeof speechConfig === "string") {
      return {
        voiceConfig: {
          prebuiltVoiceConfig: {
            voiceName: speechConfig
          }
        }
      };
    } else {
      throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);
    }
  }
  function tLiveSpeechConfig(speechConfig) {
    if ("multiSpeakerVoiceConfig" in speechConfig) {
      throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
    }
    return speechConfig;
  }
  function tTool(tool) {
    if (tool.functionDeclarations) {
      for (const functionDeclaration of tool.functionDeclarations) {
        if (functionDeclaration.parameters) {
          if (!Object.keys(functionDeclaration.parameters).includes("$schema")) {
            functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);
          } else {
            if (!functionDeclaration.parametersJsonSchema) {
              functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;
              delete functionDeclaration.parameters;
            }
          }
        }
        if (functionDeclaration.response) {
          if (!Object.keys(functionDeclaration.response).includes("$schema")) {
            functionDeclaration.response = processJsonSchema(functionDeclaration.response);
          } else {
            if (!functionDeclaration.responseJsonSchema) {
              functionDeclaration.responseJsonSchema = functionDeclaration.response;
              delete functionDeclaration.response;
            }
          }
        }
      }
    }
    return tool;
  }
  function tTools(tools) {
    if (tools === void 0 || tools === null) {
      throw new Error("tools is required");
    }
    if (!Array.isArray(tools)) {
      throw new Error("tools is required and must be an array of Tools");
    }
    const result = [];
    for (const tool of tools) {
      result.push(tool);
    }
    return result;
  }
  function resourceName(client, resourceName2, resourcePrefix, splitsAfterPrefix = 1) {
    const shouldAppendPrefix = !resourceName2.startsWith(`${resourcePrefix}/`) && resourceName2.split("/").length === splitsAfterPrefix;
    if (client.isVertexAI()) {
      if (resourceName2.startsWith("projects/")) {
        return resourceName2;
      } else if (resourceName2.startsWith("locations/")) {
        return `projects/${client.getProject()}/${resourceName2}`;
      } else if (resourceName2.startsWith(`${resourcePrefix}/`)) {
        return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName2}`;
      } else if (shouldAppendPrefix) {
        return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName2}`;
      } else {
        return resourceName2;
      }
    }
    if (shouldAppendPrefix) {
      return `${resourcePrefix}/${resourceName2}`;
    }
    return resourceName2;
  }
  function tCachedContentName(apiClient, name) {
    if (typeof name !== "string") {
      throw new Error("name must be a string");
    }
    return resourceName(apiClient, name, "cachedContents");
  }
  function tTuningJobStatus(status) {
    switch (status) {
      case "STATE_UNSPECIFIED":
        return "JOB_STATE_UNSPECIFIED";
      case "CREATING":
        return "JOB_STATE_RUNNING";
      case "ACTIVE":
        return "JOB_STATE_SUCCEEDED";
      case "FAILED":
        return "JOB_STATE_FAILED";
      default:
        return status;
    }
  }
  function tBytes(fromImageBytes) {
    return tBytes$1(fromImageBytes);
  }
  function _isFile(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "name" in origin;
  }
  function isGeneratedVideo(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "video" in origin;
  }
  function isVideo(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "uri" in origin;
  }
  function tFileName(fromName) {
    var _a;
    let name;
    if (_isFile(fromName)) {
      name = fromName.name;
    }
    if (isVideo(fromName)) {
      name = fromName.uri;
      if (name === void 0) {
        return void 0;
      }
    }
    if (isGeneratedVideo(fromName)) {
      name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;
      if (name === void 0) {
        return void 0;
      }
    }
    if (typeof fromName === "string") {
      name = fromName;
    }
    if (name === void 0) {
      throw new Error("Could not extract file name from the provided input.");
    }
    if (name.startsWith("https://")) {
      const suffix = name.split("files/")[1];
      const match = suffix.match(/[a-z0-9]+/);
      if (match === null) {
        throw new Error(`Could not extract file name from URI ${name}`);
      }
      name = match[0];
    } else if (name.startsWith("files/")) {
      name = name.split("files/")[1];
    }
    return name;
  }
  function tModelsUrl(apiClient, baseModels) {
    let res;
    if (apiClient.isVertexAI()) {
      res = baseModels ? "publishers/google/models" : "models";
    } else {
      res = baseModels ? "models" : "tunedModels";
    }
    return res;
  }
  function tExtractModels(response) {
    for (const key of ["models", "tunedModels", "publisherModels"]) {
      if (hasField(response, key)) {
        return response[key];
      }
    }
    return [];
  }
  function hasField(data, fieldName) {
    return data !== null && typeof data === "object" && fieldName in data;
  }
  function mcpToGeminiTool(mcpTool, config = {}) {
    const mcpToolSchema = mcpTool;
    const functionDeclaration = {
      name: mcpToolSchema["name"],
      description: mcpToolSchema["description"],
      parametersJsonSchema: mcpToolSchema["inputSchema"]
    };
    if (mcpToolSchema["outputSchema"]) {
      functionDeclaration["responseJsonSchema"] = mcpToolSchema["outputSchema"];
    }
    if (config.behavior) {
      functionDeclaration["behavior"] = config.behavior;
    }
    const geminiTool = {
      functionDeclarations: [
        functionDeclaration
      ]
    };
    return geminiTool;
  }
  function mcpToolsToGeminiTool(mcpTools, config = {}) {
    const functionDeclarations = [];
    const toolNames = /* @__PURE__ */ new Set();
    for (const mcpTool of mcpTools) {
      const mcpToolName = mcpTool.name;
      if (toolNames.has(mcpToolName)) {
        throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
      }
      toolNames.add(mcpToolName);
      const geminiTool = mcpToGeminiTool(mcpTool, config);
      if (geminiTool.functionDeclarations) {
        functionDeclarations.push(...geminiTool.functionDeclarations);
      }
    }
    return { functionDeclarations };
  }
  function tBatchJobSource(client, src) {
    let sourceObj;
    if (typeof src === "string") {
      if (client.isVertexAI()) {
        if (src.startsWith("gs://")) {
          sourceObj = { format: "jsonl", gcsUri: [src] };
        } else if (src.startsWith("bq://")) {
          sourceObj = { format: "bigquery", bigqueryUri: src };
        } else {
          throw new Error(`Unsupported string source for Vertex AI: ${src}`);
        }
      } else {
        if (src.startsWith("files/")) {
          sourceObj = { fileName: src };
        } else {
          throw new Error(`Unsupported string source for Gemini API: ${src}`);
        }
      }
    } else if (Array.isArray(src)) {
      if (client.isVertexAI()) {
        throw new Error("InlinedRequest[] is not supported in Vertex AI.");
      }
      sourceObj = { inlinedRequests: src };
    } else {
      sourceObj = src;
    }
    const vertexSourcesCount = [sourceObj.gcsUri, sourceObj.bigqueryUri].filter(Boolean).length;
    const mldevSourcesCount = [
      sourceObj.inlinedRequests,
      sourceObj.fileName
    ].filter(Boolean).length;
    if (client.isVertexAI()) {
      if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {
        throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.");
      }
    } else {
      if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {
        throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API.");
      }
    }
    return sourceObj;
  }
  function tBatchJobDestination(dest) {
    if (typeof dest !== "string") {
      return dest;
    }
    const destString = dest;
    if (destString.startsWith("gs://")) {
      return {
        format: "jsonl",
        gcsUri: destString
      };
    } else if (destString.startsWith("bq://")) {
      return {
        format: "bigquery",
        bigqueryUri: destString
      };
    } else {
      throw new Error(`Unsupported destination: ${destString}`);
    }
  }
  function tRecvBatchJobDestination(dest) {
    if (typeof dest !== "object" || dest === null) {
      return {};
    }
    const obj = dest;
    const inlineResponsesVal = obj["inlinedResponses"];
    if (typeof inlineResponsesVal !== "object" || inlineResponsesVal === null) {
      return dest;
    }
    const inlineResponsesObj = inlineResponsesVal;
    const responsesArray = inlineResponsesObj["inlinedResponses"];
    if (!Array.isArray(responsesArray) || responsesArray.length === 0) {
      return dest;
    }
    let hasEmbedding = false;
    for (const responseItem of responsesArray) {
      if (typeof responseItem !== "object" || responseItem === null) {
        continue;
      }
      const responseItemObj = responseItem;
      const responseVal = responseItemObj["response"];
      if (typeof responseVal !== "object" || responseVal === null) {
        continue;
      }
      const responseObj = responseVal;
      if (responseObj["embedding"] !== void 0) {
        hasEmbedding = true;
        break;
      }
    }
    if (hasEmbedding) {
      obj["inlinedEmbedContentResponses"] = obj["inlinedResponses"];
      delete obj["inlinedResponses"];
    }
    return dest;
  }
  function tBatchJobName(apiClient, name) {
    const nameString = name;
    if (!apiClient.isVertexAI()) {
      const mldevPattern = /batches\/[^/]+$/;
      if (mldevPattern.test(nameString)) {
        return nameString.split("/").pop();
      } else {
        throw new Error(`Invalid batch job name: ${nameString}.`);
      }
    }
    const vertexPattern = /^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/;
    if (vertexPattern.test(nameString)) {
      return nameString.split("/").pop();
    } else if (/^\d+$/.test(nameString)) {
      return nameString;
    } else {
      throw new Error(`Invalid batch job name: ${nameString}.`);
    }
  }
  function tJobState(state) {
    const stateString = state;
    if (stateString === "BATCH_STATE_UNSPECIFIED") {
      return "JOB_STATE_UNSPECIFIED";
    } else if (stateString === "BATCH_STATE_PENDING") {
      return "JOB_STATE_PENDING";
    } else if (stateString === "BATCH_STATE_RUNNING") {
      return "JOB_STATE_RUNNING";
    } else if (stateString === "BATCH_STATE_SUCCEEDED") {
      return "JOB_STATE_SUCCEEDED";
    } else if (stateString === "BATCH_STATE_FAILED") {
      return "JOB_STATE_FAILED";
    } else if (stateString === "BATCH_STATE_CANCELLED") {
      return "JOB_STATE_CANCELLED";
    } else if (stateString === "BATCH_STATE_EXPIRED") {
      return "JOB_STATE_EXPIRED";
    } else {
      return stateString;
    }
  }
  function batchJobDestinationFromMldev(fromObject) {
    const toObject = {};
    const fromFileName = getValueByPath(fromObject, ["responsesFile"]);
    if (fromFileName != null) {
      setValueByPath(toObject, ["fileName"], fromFileName);
    }
    const fromInlinedResponses = getValueByPath(fromObject, [
      "inlinedResponses",
      "inlinedResponses"
    ]);
    if (fromInlinedResponses != null) {
      let transformedList = fromInlinedResponses;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return inlinedResponseFromMldev(item);
        });
      }
      setValueByPath(toObject, ["inlinedResponses"], transformedList);
    }
    const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [
      "inlinedEmbedContentResponses",
      "inlinedResponses"
    ]);
    if (fromInlinedEmbedContentResponses != null) {
      let transformedList = fromInlinedEmbedContentResponses;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return inlinedEmbedContentResponseFromMldev(item);
        });
      }
      setValueByPath(toObject, ["inlinedEmbedContentResponses"], transformedList);
    }
    return toObject;
  }
  function batchJobDestinationFromVertex(fromObject) {
    const toObject = {};
    const fromFormat = getValueByPath(fromObject, ["predictionsFormat"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["format"], fromFormat);
    }
    const fromGcsUri = getValueByPath(fromObject, [
      "gcsDestination",
      "outputUriPrefix"
    ]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromBigqueryUri = getValueByPath(fromObject, [
      "bigqueryDestination",
      "outputUri"
    ]);
    if (fromBigqueryUri != null) {
      setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
    }
    return toObject;
  }
  function batchJobDestinationToVertex(fromObject) {
    const toObject = {};
    const fromFormat = getValueByPath(fromObject, ["format"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["predictionsFormat"], fromFormat);
    }
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsDestination", "outputUriPrefix"], fromGcsUri);
    }
    const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
    if (fromBigqueryUri != null) {
      setValueByPath(toObject, ["bigqueryDestination", "outputUri"], fromBigqueryUri);
    }
    if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
      throw new Error("fileName parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["inlinedResponses"]) !== void 0) {
      throw new Error("inlinedResponses parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["inlinedEmbedContentResponses"]) !== void 0) {
      throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function batchJobFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, [
      "metadata",
      "displayName"
    ]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromState = getValueByPath(fromObject, ["metadata", "state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tJobState(fromState));
    }
    const fromCreateTime = getValueByPath(fromObject, [
      "metadata",
      "createTime"
    ]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromEndTime = getValueByPath(fromObject, [
      "metadata",
      "endTime"
    ]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, [
      "metadata",
      "updateTime"
    ]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromModel = getValueByPath(fromObject, ["metadata", "model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromDest = getValueByPath(fromObject, ["metadata", "output"]);
    if (fromDest != null) {
      setValueByPath(toObject, ["dest"], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));
    }
    return toObject;
  }
  function batchJobFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tJobState(fromState));
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], jobErrorFromVertex(fromError));
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromSrc = getValueByPath(fromObject, ["inputConfig"]);
    if (fromSrc != null) {
      setValueByPath(toObject, ["src"], batchJobSourceFromVertex(fromSrc));
    }
    const fromDest = getValueByPath(fromObject, ["outputConfig"]);
    if (fromDest != null) {
      setValueByPath(toObject, ["dest"], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));
    }
    return toObject;
  }
  function batchJobSourceFromVertex(fromObject) {
    const toObject = {};
    const fromFormat = getValueByPath(fromObject, ["instancesFormat"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["format"], fromFormat);
    }
    const fromGcsUri = getValueByPath(fromObject, ["gcsSource", "uris"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromBigqueryUri = getValueByPath(fromObject, [
      "bigquerySource",
      "inputUri"
    ]);
    if (fromBigqueryUri != null) {
      setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
    }
    return toObject;
  }
  function batchJobSourceToMldev(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["format"]) !== void 0) {
      throw new Error("format parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
      throw new Error("gcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["bigqueryUri"]) !== void 0) {
      throw new Error("bigqueryUri parameter is not supported in Gemini API.");
    }
    const fromFileName = getValueByPath(fromObject, ["fileName"]);
    if (fromFileName != null) {
      setValueByPath(toObject, ["fileName"], fromFileName);
    }
    const fromInlinedRequests = getValueByPath(fromObject, [
      "inlinedRequests"
    ]);
    if (fromInlinedRequests != null) {
      let transformedList = fromInlinedRequests;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return inlinedRequestToMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["requests", "requests"], transformedList);
    }
    return toObject;
  }
  function batchJobSourceToVertex(fromObject) {
    const toObject = {};
    const fromFormat = getValueByPath(fromObject, ["format"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["instancesFormat"], fromFormat);
    }
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsSource", "uris"], fromGcsUri);
    }
    const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
    if (fromBigqueryUri != null) {
      setValueByPath(toObject, ["bigquerySource", "inputUri"], fromBigqueryUri);
    }
    if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
      throw new Error("fileName parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["inlinedRequests"]) !== void 0) {
      throw new Error("inlinedRequests parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function blobFromMldev$2(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function blobToMldev$4(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function cancelBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function cancelBatchJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function candidateFromMldev$1(fromObject) {
    const toObject = {};
    const fromContent = getValueByPath(fromObject, ["content"]);
    if (fromContent != null) {
      setValueByPath(toObject, ["content"], contentFromMldev$2(fromContent));
    }
    const fromCitationMetadata = getValueByPath(fromObject, [
      "citationMetadata"
    ]);
    if (fromCitationMetadata != null) {
      setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev$1(fromCitationMetadata));
    }
    const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
    if (fromFinishReason != null) {
      setValueByPath(toObject, ["finishReason"], fromFinishReason);
    }
    const fromUrlContextMetadata = getValueByPath(fromObject, [
      "urlContextMetadata"
    ]);
    if (fromUrlContextMetadata != null) {
      setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromMldev$2(fromUrlContextMetadata));
    }
    const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
    if (fromAvgLogprobs != null) {
      setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromIndex = getValueByPath(fromObject, ["index"]);
    if (fromIndex != null) {
      setValueByPath(toObject, ["index"], fromIndex);
    }
    const fromLogprobsResult = getValueByPath(fromObject, [
      "logprobsResult"
    ]);
    if (fromLogprobsResult != null) {
      setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
    }
    const fromSafetyRatings = getValueByPath(fromObject, [
      "safetyRatings"
    ]);
    if (fromSafetyRatings != null) {
      setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
    }
    return toObject;
  }
  function citationMetadataFromMldev$1(fromObject) {
    const toObject = {};
    const fromCitations = getValueByPath(fromObject, ["citationSources"]);
    if (fromCitations != null) {
      setValueByPath(toObject, ["citations"], fromCitations);
    }
    return toObject;
  }
  function contentEmbeddingFromMldev$1(fromObject) {
    const toObject = {};
    const fromValues = getValueByPath(fromObject, ["values"]);
    if (fromValues != null) {
      setValueByPath(toObject, ["values"], fromValues);
    }
    return toObject;
  }
  function contentFromMldev$2(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partFromMldev$2(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function contentToMldev$4(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$4(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function createBatchJobConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
    }
    if (getValueByPath(fromObject, ["dest"]) !== void 0) {
      throw new Error("dest parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function createBatchJobConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromDest = getValueByPath(fromObject, ["dest"]);
    if (parentObject !== void 0 && fromDest != null) {
      setValueByPath(parentObject, ["outputConfig"], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));
    }
    return toObject;
  }
  function createBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromSrc = getValueByPath(fromObject, ["src"]);
    if (fromSrc != null) {
      setValueByPath(toObject, ["batch", "inputConfig"], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createBatchJobConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function createBatchJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], tModel(apiClient, fromModel));
    }
    const fromSrc = getValueByPath(fromObject, ["src"]);
    if (fromSrc != null) {
      setValueByPath(toObject, ["inputConfig"], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createBatchJobConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
    }
    return toObject;
  }
  function createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromSrc = getValueByPath(fromObject, ["src"]);
    if (fromSrc != null) {
      setValueByPath(toObject, ["batch", "inputConfig"], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function deleteBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function deleteBatchJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function deleteResourceJobFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], jobErrorFromMldev(fromError));
    }
    return toObject;
  }
  function deleteResourceJobFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], jobErrorFromVertex(fromError));
    }
    return toObject;
  }
  function dynamicRetrievalConfigToMldev$4(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function embedContentBatchToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      setValueByPath(toObject, ["requests[]", "request", "content"], tContentsForEmbed(apiClient, fromContents));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], embedContentConfigToMldev$1(fromConfig, toObject));
    }
    return toObject;
  }
  function embedContentConfigToMldev$1(fromObject, parentObject) {
    const toObject = {};
    const fromTaskType = getValueByPath(fromObject, ["taskType"]);
    if (parentObject !== void 0 && fromTaskType != null) {
      setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (parentObject !== void 0 && fromTitle != null) {
      setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
    }
    const fromOutputDimensionality = getValueByPath(fromObject, [
      "outputDimensionality"
    ]);
    if (parentObject !== void 0 && fromOutputDimensionality != null) {
      setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
    }
    if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
      throw new Error("mimeType parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
      throw new Error("autoTruncate parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function embeddingsBatchJobSourceToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromFileName = getValueByPath(fromObject, ["fileName"]);
    if (fromFileName != null) {
      setValueByPath(toObject, ["file_name"], fromFileName);
    }
    const fromInlinedRequests = getValueByPath(fromObject, [
      "inlinedRequests"
    ]);
    if (fromInlinedRequests != null) {
      setValueByPath(toObject, ["requests"], embedContentBatchToMldev(apiClient, fromInlinedRequests));
    }
    return toObject;
  }
  function fileDataFromMldev$2(fromObject) {
    const toObject = {};
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataToMldev$4(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallFromMldev$2(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionCallToMldev$4(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionCallingConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    return toObject;
  }
  function functionDeclarationToMldev$4(fromObject) {
    const toObject = {};
    const fromBehavior = getValueByPath(fromObject, ["behavior"]);
    if (fromBehavior != null) {
      setValueByPath(toObject, ["behavior"], fromBehavior);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToMldev$4(tContent(fromSystemInstruction)));
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], schemaToMldev$1(tSchema(fromResponseSchema)));
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
      throw new Error("routingConfig parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
      throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
    }
    const fromSafetySettings = getValueByPath(fromObject, [
      "safetySettings"
    ]);
    if (parentObject !== void 0 && fromSafetySettings != null) {
      let transformedList = fromSafetySettings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return safetySettingToMldev$1(item);
        });
      }
      setValueByPath(parentObject, ["safetySettings"], transformedList);
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$4(tTool(item));
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$2(fromToolConfig));
    }
    if (getValueByPath(fromObject, ["labels"]) !== void 0) {
      throw new Error("labels parameter is not supported in Gemini API.");
    }
    const fromCachedContent = getValueByPath(fromObject, [
      "cachedContent"
    ]);
    if (parentObject !== void 0 && fromCachedContent != null) {
      setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], speechConfigToMldev$3(tSpeechConfig(fromSpeechConfig)));
    }
    if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
      throw new Error("audioTimestamp parameter is not supported in Gemini API.");
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToMldev$1(fromThinkingConfig));
    }
    return toObject;
  }
  function generateContentResponseFromMldev$1(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromCandidates = getValueByPath(fromObject, ["candidates"]);
    if (fromCandidates != null) {
      let transformedList = fromCandidates;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return candidateFromMldev$1(item);
        });
      }
      setValueByPath(toObject, ["candidates"], transformedList);
    }
    const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
    if (fromModelVersion != null) {
      setValueByPath(toObject, ["modelVersion"], fromModelVersion);
    }
    const fromPromptFeedback = getValueByPath(fromObject, [
      "promptFeedback"
    ]);
    if (fromPromptFeedback != null) {
      setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
    }
    const fromResponseId = getValueByPath(fromObject, ["responseId"]);
    if (fromResponseId != null) {
      setValueByPath(toObject, ["responseId"], fromResponseId);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function getBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function getBatchJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function googleSearchRetrievalToMldev$4(fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$4(fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function googleSearchToMldev$4(fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$4(fromTimeRangeFilter));
    }
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function inlinedEmbedContentResponseFromMldev(fromObject) {
    const toObject = {};
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], singleEmbedContentResponseFromMldev(fromResponse));
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], jobErrorFromMldev(fromError));
    }
    return toObject;
  }
  function inlinedRequestToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["request", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$4(item);
        });
      }
      setValueByPath(toObject, ["request", "contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["request", "generationConfig"], generateContentConfigToMldev$1(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function inlinedResponseFromMldev(fromObject) {
    const toObject = {};
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateContentResponseFromMldev$1(fromResponse));
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], jobErrorFromMldev(fromError));
    }
    return toObject;
  }
  function intervalToMldev$4(fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function jobErrorFromMldev(fromObject) {
    const toObject = {};
    const fromDetails = getValueByPath(fromObject, ["details"]);
    if (fromDetails != null) {
      setValueByPath(toObject, ["details"], fromDetails);
    }
    const fromCode = getValueByPath(fromObject, ["code"]);
    if (fromCode != null) {
      setValueByPath(toObject, ["code"], fromCode);
    }
    const fromMessage = getValueByPath(fromObject, ["message"]);
    if (fromMessage != null) {
      setValueByPath(toObject, ["message"], fromMessage);
    }
    return toObject;
  }
  function jobErrorFromVertex(fromObject) {
    const toObject = {};
    const fromDetails = getValueByPath(fromObject, ["details"]);
    if (fromDetails != null) {
      setValueByPath(toObject, ["details"], fromDetails);
    }
    const fromCode = getValueByPath(fromObject, ["code"]);
    if (fromCode != null) {
      setValueByPath(toObject, ["code"], fromCode);
    }
    const fromMessage = getValueByPath(fromObject, ["message"]);
    if (fromMessage != null) {
      setValueByPath(toObject, ["message"], fromMessage);
    }
    return toObject;
  }
  function latLngToMldev$2(fromObject) {
    const toObject = {};
    const fromLatitude = getValueByPath(fromObject, ["latitude"]);
    if (fromLatitude != null) {
      setValueByPath(toObject, ["latitude"], fromLatitude);
    }
    const fromLongitude = getValueByPath(fromObject, ["longitude"]);
    if (fromLongitude != null) {
      setValueByPath(toObject, ["longitude"], fromLongitude);
    }
    return toObject;
  }
  function listBatchJobsConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    if (getValueByPath(fromObject, ["filter"]) !== void 0) {
      throw new Error("filter parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function listBatchJobsConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    return toObject;
  }
  function listBatchJobsParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listBatchJobsConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listBatchJobsParametersToVertex(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listBatchJobsConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function listBatchJobsResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromBatchJobs = getValueByPath(fromObject, ["operations"]);
    if (fromBatchJobs != null) {
      let transformedList = fromBatchJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return batchJobFromMldev(item);
        });
      }
      setValueByPath(toObject, ["batchJobs"], transformedList);
    }
    return toObject;
  }
  function listBatchJobsResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromBatchJobs = getValueByPath(fromObject, [
      "batchPredictionJobs"
    ]);
    if (fromBatchJobs != null) {
      let transformedList = fromBatchJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return batchJobFromVertex(item);
        });
      }
      setValueByPath(toObject, ["batchJobs"], transformedList);
    }
    return toObject;
  }
  function multiSpeakerVoiceConfigToMldev$3(fromObject) {
    const toObject = {};
    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
      "speakerVoiceConfigs"
    ]);
    if (fromSpeakerVoiceConfigs != null) {
      let transformedList = fromSpeakerVoiceConfigs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return speakerVoiceConfigToMldev$3(item);
        });
      }
      setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
    }
    return toObject;
  }
  function partFromMldev$2(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataFromMldev$2(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobFromMldev$2(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataFromMldev$2(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallFromMldev$2(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function partToMldev$4(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$4(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$4(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$4(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev$4(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function prebuiltVoiceConfigToMldev$3(fromObject) {
    const toObject = {};
    const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
    if (fromVoiceName != null) {
      setValueByPath(toObject, ["voiceName"], fromVoiceName);
    }
    return toObject;
  }
  function retrievalConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromLatLng = getValueByPath(fromObject, ["latLng"]);
    if (fromLatLng != null) {
      setValueByPath(toObject, ["latLng"], latLngToMldev$2(fromLatLng));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function safetySettingToMldev$1(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["method"]) !== void 0) {
      throw new Error("method parameter is not supported in Gemini API.");
    }
    const fromCategory = getValueByPath(fromObject, ["category"]);
    if (fromCategory != null) {
      setValueByPath(toObject, ["category"], fromCategory);
    }
    const fromThreshold = getValueByPath(fromObject, ["threshold"]);
    if (fromThreshold != null) {
      setValueByPath(toObject, ["threshold"], fromThreshold);
    }
    return toObject;
  }
  function schemaToMldev$1(fromObject) {
    const toObject = {};
    const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
    if (fromAnyOf != null) {
      setValueByPath(toObject, ["anyOf"], fromAnyOf);
    }
    const fromDefault = getValueByPath(fromObject, ["default"]);
    if (fromDefault != null) {
      setValueByPath(toObject, ["default"], fromDefault);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromEnum = getValueByPath(fromObject, ["enum"]);
    if (fromEnum != null) {
      setValueByPath(toObject, ["enum"], fromEnum);
    }
    const fromExample = getValueByPath(fromObject, ["example"]);
    if (fromExample != null) {
      setValueByPath(toObject, ["example"], fromExample);
    }
    const fromFormat = getValueByPath(fromObject, ["format"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["format"], fromFormat);
    }
    const fromItems = getValueByPath(fromObject, ["items"]);
    if (fromItems != null) {
      setValueByPath(toObject, ["items"], fromItems);
    }
    const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
    if (fromMaxItems != null) {
      setValueByPath(toObject, ["maxItems"], fromMaxItems);
    }
    const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
    if (fromMaxLength != null) {
      setValueByPath(toObject, ["maxLength"], fromMaxLength);
    }
    const fromMaxProperties = getValueByPath(fromObject, [
      "maxProperties"
    ]);
    if (fromMaxProperties != null) {
      setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
    }
    const fromMaximum = getValueByPath(fromObject, ["maximum"]);
    if (fromMaximum != null) {
      setValueByPath(toObject, ["maximum"], fromMaximum);
    }
    const fromMinItems = getValueByPath(fromObject, ["minItems"]);
    if (fromMinItems != null) {
      setValueByPath(toObject, ["minItems"], fromMinItems);
    }
    const fromMinLength = getValueByPath(fromObject, ["minLength"]);
    if (fromMinLength != null) {
      setValueByPath(toObject, ["minLength"], fromMinLength);
    }
    const fromMinProperties = getValueByPath(fromObject, [
      "minProperties"
    ]);
    if (fromMinProperties != null) {
      setValueByPath(toObject, ["minProperties"], fromMinProperties);
    }
    const fromMinimum = getValueByPath(fromObject, ["minimum"]);
    if (fromMinimum != null) {
      setValueByPath(toObject, ["minimum"], fromMinimum);
    }
    const fromNullable = getValueByPath(fromObject, ["nullable"]);
    if (fromNullable != null) {
      setValueByPath(toObject, ["nullable"], fromNullable);
    }
    const fromPattern = getValueByPath(fromObject, ["pattern"]);
    if (fromPattern != null) {
      setValueByPath(toObject, ["pattern"], fromPattern);
    }
    const fromProperties = getValueByPath(fromObject, ["properties"]);
    if (fromProperties != null) {
      setValueByPath(toObject, ["properties"], fromProperties);
    }
    const fromPropertyOrdering = getValueByPath(fromObject, [
      "propertyOrdering"
    ]);
    if (fromPropertyOrdering != null) {
      setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
    }
    const fromRequired = getValueByPath(fromObject, ["required"]);
    if (fromRequired != null) {
      setValueByPath(toObject, ["required"], fromRequired);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (fromTitle != null) {
      setValueByPath(toObject, ["title"], fromTitle);
    }
    const fromType = getValueByPath(fromObject, ["type"]);
    if (fromType != null) {
      setValueByPath(toObject, ["type"], fromType);
    }
    return toObject;
  }
  function singleEmbedContentResponseFromMldev(fromObject) {
    const toObject = {};
    const fromEmbedding = getValueByPath(fromObject, ["embedding"]);
    if (fromEmbedding != null) {
      setValueByPath(toObject, ["embedding"], contentEmbeddingFromMldev$1(fromEmbedding));
    }
    const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    return toObject;
  }
  function speakerVoiceConfigToMldev$3(fromObject) {
    const toObject = {};
    const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
    if (fromSpeaker != null) {
      setValueByPath(toObject, ["speaker"], fromSpeaker);
    }
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$3(fromVoiceConfig));
    }
    return toObject;
  }
  function speechConfigToMldev$3(fromObject) {
    const toObject = {};
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$3(fromVoiceConfig));
    }
    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
      "multiSpeakerVoiceConfig"
    ]);
    if (fromMultiSpeakerVoiceConfig != null) {
      setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev$3(fromMultiSpeakerVoiceConfig));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function thinkingConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromIncludeThoughts = getValueByPath(fromObject, [
      "includeThoughts"
    ]);
    if (fromIncludeThoughts != null) {
      setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
    }
    const fromThinkingBudget = getValueByPath(fromObject, [
      "thinkingBudget"
    ]);
    if (fromThinkingBudget != null) {
      setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
    }
    return toObject;
  }
  function toolComputerUseToMldev$4(fromObject) {
    const toObject = {};
    const fromEnvironment = getValueByPath(fromObject, ["environment"]);
    if (fromEnvironment != null) {
      setValueByPath(toObject, ["environment"], fromEnvironment);
    }
    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [
      "excludedPredefinedFunctions"
    ]);
    if (fromExcludedPredefinedFunctions != null) {
      setValueByPath(toObject, ["excludedPredefinedFunctions"], fromExcludedPredefinedFunctions);
    }
    return toObject;
  }
  function toolConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$2(fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToMldev$2(fromRetrievalConfig));
    }
    return toObject;
  }
  function toolToMldev$4(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToMldev$4(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$4(fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$4(fromGoogleSearchRetrieval));
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
      throw new Error("googleMaps parameter is not supported in Gemini API.");
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], urlContextToMldev$4());
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], toolComputerUseToMldev$4(fromComputerUse));
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function urlContextMetadataFromMldev$2(fromObject) {
    const toObject = {};
    const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
    if (fromUrlMetadata != null) {
      let transformedList = fromUrlMetadata;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return urlMetadataFromMldev$2(item);
        });
      }
      setValueByPath(toObject, ["urlMetadata"], transformedList);
    }
    return toObject;
  }
  function urlContextToMldev$4() {
    const toObject = {};
    return toObject;
  }
  function urlMetadataFromMldev$2(fromObject) {
    const toObject = {};
    const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
    if (fromRetrievedUrl != null) {
      setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
    }
    const fromUrlRetrievalStatus = getValueByPath(fromObject, [
      "urlRetrievalStatus"
    ]);
    if (fromUrlRetrievalStatus != null) {
      setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
    }
    return toObject;
  }
  function videoMetadataFromMldev$2(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function videoMetadataToMldev$4(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function voiceConfigToMldev$3(fromObject) {
    const toObject = {};
    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
      "prebuiltVoiceConfig"
    ]);
    if (fromPrebuiltVoiceConfig != null) {
      setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev$3(fromPrebuiltVoiceConfig));
    }
    return toObject;
  }
  var PagedItem;
  (function(PagedItem2) {
    PagedItem2["PAGED_ITEM_BATCH_JOBS"] = "batchJobs";
    PagedItem2["PAGED_ITEM_MODELS"] = "models";
    PagedItem2["PAGED_ITEM_TUNING_JOBS"] = "tuningJobs";
    PagedItem2["PAGED_ITEM_FILES"] = "files";
    PagedItem2["PAGED_ITEM_CACHED_CONTENTS"] = "cachedContents";
  })(PagedItem || (PagedItem = {}));
  var Pager = class {
    constructor(name, request, response, params) {
      this.pageInternal = [];
      this.paramsInternal = {};
      this.requestInternal = request;
      this.init(name, response, params);
    }
    init(name, response, params) {
      var _a, _b;
      this.nameInternal = name;
      this.pageInternal = response[this.nameInternal] || [];
      this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;
      this.idxInternal = 0;
      let requestParams = { config: {} };
      if (!params || Object.keys(params).length === 0) {
        requestParams = { config: {} };
      } else if (typeof params === "object") {
        requestParams = Object.assign({}, params);
      } else {
        requestParams = params;
      }
      if (requestParams["config"]) {
        requestParams["config"]["pageToken"] = response["nextPageToken"];
      }
      this.paramsInternal = requestParams;
      this.pageInternalSize = (_b = (_a = requestParams["config"]) === null || _a === void 0 ? void 0 : _a["pageSize"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;
    }
    initNextPage(response) {
      this.init(this.nameInternal, response, this.paramsInternal);
    }
    /**
     * Returns the current page, which is a list of items.
     *
     * @remarks
     * The first page is retrieved when the pager is created. The returned list of
     * items could be a subset of the entire list.
     */
    get page() {
      return this.pageInternal;
    }
    /**
     * Returns the type of paged item (for example, ``batch_jobs``).
     */
    get name() {
      return this.nameInternal;
    }
    /**
     * Returns the length of the page fetched each time by this pager.
     *
     * @remarks
     * The number of items in the page is less than or equal to the page length.
     */
    get pageSize() {
      return this.pageInternalSize;
    }
    /**
     * Returns the headers of the API response.
     */
    get sdkHttpResponse() {
      return this.sdkHttpResponseInternal;
    }
    /**
     * Returns the parameters when making the API request for the next page.
     *
     * @remarks
     * Parameters contain a set of optional configs that can be
     * used to customize the API request. For example, the `pageToken` parameter
     * contains the token to request the next page.
     */
    get params() {
      return this.paramsInternal;
    }
    /**
     * Returns the total number of items in the current page.
     */
    get pageLength() {
      return this.pageInternal.length;
    }
    /**
     * Returns the item at the given index.
     */
    getItem(index) {
      return this.pageInternal[index];
    }
    /**
     * Returns an async iterator that support iterating through all items
     * retrieved from the API.
     *
     * @remarks
     * The iterator will automatically fetch the next page if there are more items
     * to fetch from the API.
     *
     * @example
     *
     * ```ts
     * const pager = await ai.files.list({config: {pageSize: 10}});
     * for await (const file of pager) {
     *   console.log(file.name);
     * }
     * ```
     */
    [Symbol.asyncIterator]() {
      return {
        next: async () => {
          if (this.idxInternal >= this.pageLength) {
            if (this.hasNextPage()) {
              await this.nextPage();
            } else {
              return { value: void 0, done: true };
            }
          }
          const item = this.getItem(this.idxInternal);
          this.idxInternal += 1;
          return { value: item, done: false };
        },
        return: async () => {
          return { value: void 0, done: true };
        }
      };
    }
    /**
     * Fetches the next page of items. This makes a new API request.
     *
     * @throws {Error} If there are no more pages to fetch.
     *
     * @example
     *
     * ```ts
     * const pager = await ai.files.list({config: {pageSize: 10}});
     * let page = pager.page;
     * while (true) {
     *   for (const file of page) {
     *     console.log(file.name);
     *   }
     *   if (!pager.hasNextPage()) {
     *     break;
     *   }
     *   page = await pager.nextPage();
     * }
     * ```
     */
    async nextPage() {
      if (!this.hasNextPage()) {
        throw new Error("No more pages to fetch.");
      }
      const response = await this.requestInternal(this.params);
      this.initNextPage(response);
      return this.page;
    }
    /**
     * Returns true if there are more pages to fetch from the API.
     */
    hasNextPage() {
      var _a;
      if (((_a = this.params["config"]) === null || _a === void 0 ? void 0 : _a["pageToken"]) !== void 0) {
        return true;
      }
      return false;
    }
  };
  var Batches = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
      this.create = async (params) => {
        var _a, _b;
        if (this.apiClient.isVertexAI()) {
          params.config = this.formatDestination(params.src, params.config);
          return this.createInternal(params);
        }
        const src = params.src;
        const is_inlined = Array.isArray(params.src) || src.inlinedRequests !== void 0;
        if (!is_inlined) {
          return this.createInternal(params);
        }
        const result = this.createInlinedGenerateContentRequest(params);
        const path = result.path;
        const requestBody = result.body;
        const queryParams = createBatchJobParametersToMldev(this.apiClient, params)["_query"] || {};
        const response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(requestBody),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = batchJobFromMldev(apiResponse);
          return resp;
        });
      };
      this.createEmbeddings = async (params) => {
        var _a, _b;
        console.warn("batches.createEmbeddings() is experimental and may change without notice.");
        if (this.apiClient.isVertexAI()) {
          throw new Error("Vertex AI does not support batches.createEmbeddings.");
        }
        const src = params.src;
        const is_inlined = src.inlinedRequests !== void 0;
        if (!is_inlined) {
          return this.createEmbeddingsInternal(params);
        }
        const result = this.createInlinedEmbedContentRequest(params);
        const path = result.path;
        const requestBody = result.body;
        const queryParams = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params)["_query"] || {};
        const response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(requestBody),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = batchJobFromMldev(apiResponse);
          return resp;
        });
      };
      this.list = async (params = {}) => {
        return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x3) => this.listInternal(x3), await this.listInternal(params), params);
      };
    }
    // Helper function to handle inlined generate content requests
    createInlinedGenerateContentRequest(params) {
      const body = createBatchJobParametersToMldev(
        this.apiClient,
        // Use instance apiClient
        params
      );
      const urlParams = body["_url"];
      const path = formatMap("{model}:batchGenerateContent", urlParams);
      const batch = body["batch"];
      const inputConfig = batch["inputConfig"];
      const requestsWrapper = inputConfig["requests"];
      const requests = requestsWrapper["requests"];
      const newRequests = [];
      for (const request of requests) {
        const requestDict = Object.assign({}, request);
        if (requestDict["systemInstruction"]) {
          const systemInstructionValue = requestDict["systemInstruction"];
          delete requestDict["systemInstruction"];
          const requestContent = requestDict["request"];
          requestContent["systemInstruction"] = systemInstructionValue;
          requestDict["request"] = requestContent;
        }
        newRequests.push(requestDict);
      }
      requestsWrapper["requests"] = newRequests;
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      return { path, body };
    }
    // Helper function to handle inlined embedding requests
    createInlinedEmbedContentRequest(params) {
      const body = createEmbeddingsBatchJobParametersToMldev(
        this.apiClient,
        // Use instance apiClient
        params
      );
      const urlParams = body["_url"];
      const path = formatMap("{model}:asyncBatchEmbedContent", urlParams);
      const batch = body["batch"];
      const inputConfig = batch["inputConfig"];
      const requestsWrapper = inputConfig["requests"];
      const requests = requestsWrapper["requests"];
      const newRequests = [];
      delete requestsWrapper["config"];
      for (const request of requests) {
        const requestDict = Object.assign({}, request);
        const innerRequest = requestDict["request"];
        for (const key in requestDict) {
          if (key !== "request") {
            innerRequest[key] = requestDict[key];
            delete requestDict[key];
          }
        }
        newRequests.push(requestDict);
      }
      requestsWrapper["requests"] = newRequests;
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      return { path, body };
    }
    // Helper function to get the first GCS URI
    getGcsUri(src) {
      if (typeof src === "string") {
        return src.startsWith("gs://") ? src : void 0;
      }
      if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {
        return src.gcsUri[0];
      }
      return void 0;
    }
    // Helper function to get the BigQuery URI
    getBigqueryUri(src) {
      if (typeof src === "string") {
        return src.startsWith("bq://") ? src : void 0;
      }
      if (!Array.isArray(src)) {
        return src.bigqueryUri;
      }
      return void 0;
    }
    // Function to format the destination configuration for Vertex AI
    formatDestination(src, config) {
      const newConfig = config ? Object.assign({}, config) : {};
      const timestampStr = Date.now().toString();
      if (!newConfig.displayName) {
        newConfig.displayName = `genaiBatchJob_${timestampStr}`;
      }
      if (newConfig.dest === void 0) {
        const gcsUri = this.getGcsUri(src);
        const bigqueryUri = this.getBigqueryUri(src);
        if (gcsUri) {
          if (gcsUri.endsWith(".jsonl")) {
            newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;
          } else {
            newConfig.dest = `${gcsUri}_dest_${timestampStr}`;
          }
        } else if (bigqueryUri) {
          newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;
        } else {
          throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.");
        }
      }
      return newConfig;
    }
    /**
     * Internal method to create batch job.
     *
     * @param params - The parameters for create batch job request.
     * @return The created batch job.
     *
     */
    async createInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = createBatchJobParametersToVertex(this.apiClient, params);
        path = formatMap("batchPredictionJobs", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = batchJobFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = createBatchJobParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:batchGenerateContent", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = batchJobFromMldev(apiResponse);
          return resp;
        });
      }
    }
    /**
     * Internal method to create batch job.
     *
     * @param params - The parameters for create batch job request.
     * @return The created batch job.
     *
     */
    async createEmbeddingsInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:asyncBatchEmbedContent", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = batchJobFromMldev(apiResponse);
          return resp;
        });
      }
    }
    /**
     * Gets batch job configurations.
     *
     * @param params - The parameters for the get request.
     * @return The batch job.
     *
     * @example
     * ```ts
     * await ai.batches.get({name: '...'}); // The server-generated resource name.
     * ```
     */
    async get(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = getBatchJobParametersToVertex(this.apiClient, params);
        path = formatMap("batchPredictionJobs/{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = batchJobFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = getBatchJobParametersToMldev(this.apiClient, params);
        path = formatMap("batches/{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = batchJobFromMldev(apiResponse);
          return resp;
        });
      }
    }
    /**
     * Cancels a batch job.
     *
     * @param params - The parameters for the cancel request.
     * @return The empty response returned by the API.
     *
     * @example
     * ```ts
     * await ai.batches.cancel({name: '...'}); // The server-generated resource name.
     * ```
     */
    async cancel(params) {
      var _a, _b, _c, _d;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = cancelBatchJobParametersToVertex(this.apiClient, params);
        path = formatMap("batchPredictionJobs/{name}:cancel", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        await this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        });
      } else {
        const body = cancelBatchJobParametersToMldev(this.apiClient, params);
        path = formatMap("batches/{name}:cancel", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        await this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        });
      }
    }
    async listInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = listBatchJobsParametersToVertex(params);
        path = formatMap("batchPredictionJobs", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listBatchJobsResponseFromVertex(apiResponse);
          const typedResp = new ListBatchJobsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = listBatchJobsParametersToMldev(params);
        path = formatMap("batches", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listBatchJobsResponseFromMldev(apiResponse);
          const typedResp = new ListBatchJobsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Deletes a batch job.
     *
     * @param params - The parameters for the delete request.
     * @return The empty response returned by the API.
     *
     * @example
     * ```ts
     * await ai.batches.delete({name: '...'}); // The server-generated resource name.
     * ```
     */
    async delete(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = deleteBatchJobParametersToVertex(this.apiClient, params);
        path = formatMap("batchPredictionJobs/{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteResourceJobFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = deleteBatchJobParametersToMldev(this.apiClient, params);
        path = formatMap("batches/{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteResourceJobFromMldev(apiResponse);
          return resp;
        });
      }
    }
  };
  function apiKeyConfigToVertex$2(fromObject) {
    const toObject = {};
    const fromApiKeyString = getValueByPath(fromObject, ["apiKeyString"]);
    if (fromApiKeyString != null) {
      setValueByPath(toObject, ["apiKeyString"], fromApiKeyString);
    }
    return toObject;
  }
  function authConfigToVertex$2(fromObject) {
    const toObject = {};
    const fromApiKeyConfig = getValueByPath(fromObject, ["apiKeyConfig"]);
    if (fromApiKeyConfig != null) {
      setValueByPath(toObject, ["apiKeyConfig"], apiKeyConfigToVertex$2(fromApiKeyConfig));
    }
    const fromAuthType = getValueByPath(fromObject, ["authType"]);
    if (fromAuthType != null) {
      setValueByPath(toObject, ["authType"], fromAuthType);
    }
    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [
      "googleServiceAccountConfig"
    ]);
    if (fromGoogleServiceAccountConfig != null) {
      setValueByPath(toObject, ["googleServiceAccountConfig"], fromGoogleServiceAccountConfig);
    }
    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [
      "httpBasicAuthConfig"
    ]);
    if (fromHttpBasicAuthConfig != null) {
      setValueByPath(toObject, ["httpBasicAuthConfig"], fromHttpBasicAuthConfig);
    }
    const fromOauthConfig = getValueByPath(fromObject, ["oauthConfig"]);
    if (fromOauthConfig != null) {
      setValueByPath(toObject, ["oauthConfig"], fromOauthConfig);
    }
    const fromOidcConfig = getValueByPath(fromObject, ["oidcConfig"]);
    if (fromOidcConfig != null) {
      setValueByPath(toObject, ["oidcConfig"], fromOidcConfig);
    }
    return toObject;
  }
  function blobToMldev$3(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function blobToVertex$2(fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function cachedContentFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (fromExpireTime != null) {
      setValueByPath(toObject, ["expireTime"], fromExpireTime);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function cachedContentFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (fromExpireTime != null) {
      setValueByPath(toObject, ["expireTime"], fromExpireTime);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function contentToMldev$3(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$3(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function contentToVertex$2(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToVertex$2(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function createCachedContentConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (parentObject !== void 0 && fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$3(item);
        });
      }
      setValueByPath(parentObject, ["contents"], transformedList);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToMldev$3(tContent(fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = fromTools;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$3(item);
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$1(fromToolConfig));
    }
    if (getValueByPath(fromObject, ["kmsKeyName"]) !== void 0) {
      throw new Error("kmsKeyName parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function createCachedContentConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (parentObject !== void 0 && fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToVertex$2(item);
        });
      }
      setValueByPath(parentObject, ["contents"], transformedList);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToVertex$2(tContent(fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = fromTools;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex$2(item);
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToVertex$1(fromToolConfig));
    }
    const fromKmsKeyName = getValueByPath(fromObject, ["kmsKeyName"]);
    if (parentObject !== void 0 && fromKmsKeyName != null) {
      setValueByPath(parentObject, ["encryption_spec", "kmsKeyName"], fromKmsKeyName);
    }
    return toObject;
  }
  function createCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createCachedContentConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function createCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createCachedContentConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function deleteCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    return toObject;
  }
  function deleteCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    return toObject;
  }
  function deleteCachedContentResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function deleteCachedContentResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function dynamicRetrievalConfigToMldev$3(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function dynamicRetrievalConfigToVertex$2(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function enterpriseWebSearchToVertex$2(fromObject) {
    const toObject = {};
    const fromExcludeDomains = getValueByPath(fromObject, [
      "excludeDomains"
    ]);
    if (fromExcludeDomains != null) {
      setValueByPath(toObject, ["excludeDomains"], fromExcludeDomains);
    }
    return toObject;
  }
  function fileDataToMldev$3(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataToVertex$2(fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallToMldev$3(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionCallToVertex$2(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionCallingConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    return toObject;
  }
  function functionCallingConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    return toObject;
  }
  function functionDeclarationToMldev$3(fromObject) {
    const toObject = {};
    const fromBehavior = getValueByPath(fromObject, ["behavior"]);
    if (fromBehavior != null) {
      setValueByPath(toObject, ["behavior"], fromBehavior);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function functionDeclarationToVertex$2(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
      throw new Error("behavior parameter is not supported in Vertex AI.");
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function getCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    return toObject;
  }
  function getCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    return toObject;
  }
  function googleMapsToVertex$2(fromObject) {
    const toObject = {};
    const fromAuthConfig = getValueByPath(fromObject, ["authConfig"]);
    if (fromAuthConfig != null) {
      setValueByPath(toObject, ["authConfig"], authConfigToVertex$2(fromAuthConfig));
    }
    return toObject;
  }
  function googleSearchRetrievalToMldev$3(fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$3(fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function googleSearchRetrievalToVertex$2(fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex$2(fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function googleSearchToMldev$3(fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$3(fromTimeRangeFilter));
    }
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function googleSearchToVertex$2(fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToVertex$2(fromTimeRangeFilter));
    }
    const fromExcludeDomains = getValueByPath(fromObject, [
      "excludeDomains"
    ]);
    if (fromExcludeDomains != null) {
      setValueByPath(toObject, ["excludeDomains"], fromExcludeDomains);
    }
    return toObject;
  }
  function intervalToMldev$3(fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function intervalToVertex$2(fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function latLngToMldev$1(fromObject) {
    const toObject = {};
    const fromLatitude = getValueByPath(fromObject, ["latitude"]);
    if (fromLatitude != null) {
      setValueByPath(toObject, ["latitude"], fromLatitude);
    }
    const fromLongitude = getValueByPath(fromObject, ["longitude"]);
    if (fromLongitude != null) {
      setValueByPath(toObject, ["longitude"], fromLongitude);
    }
    return toObject;
  }
  function latLngToVertex$1(fromObject) {
    const toObject = {};
    const fromLatitude = getValueByPath(fromObject, ["latitude"]);
    if (fromLatitude != null) {
      setValueByPath(toObject, ["latitude"], fromLatitude);
    }
    const fromLongitude = getValueByPath(fromObject, ["longitude"]);
    if (fromLongitude != null) {
      setValueByPath(toObject, ["longitude"], fromLongitude);
    }
    return toObject;
  }
  function listCachedContentsConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listCachedContentsConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listCachedContentsParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listCachedContentsConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listCachedContentsParametersToVertex(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listCachedContentsConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function listCachedContentsResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromCachedContents = getValueByPath(fromObject, [
      "cachedContents"
    ]);
    if (fromCachedContents != null) {
      let transformedList = fromCachedContents;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return cachedContentFromMldev(item);
        });
      }
      setValueByPath(toObject, ["cachedContents"], transformedList);
    }
    return toObject;
  }
  function listCachedContentsResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromCachedContents = getValueByPath(fromObject, [
      "cachedContents"
    ]);
    if (fromCachedContents != null) {
      let transformedList = fromCachedContents;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return cachedContentFromVertex(item);
        });
      }
      setValueByPath(toObject, ["cachedContents"], transformedList);
    }
    return toObject;
  }
  function partToMldev$3(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$3(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$3(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$3(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev$3(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function partToVertex$2(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToVertex$2(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToVertex$2(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToVertex$2(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToVertex$2(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function retrievalConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromLatLng = getValueByPath(fromObject, ["latLng"]);
    if (fromLatLng != null) {
      setValueByPath(toObject, ["latLng"], latLngToMldev$1(fromLatLng));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function retrievalConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromLatLng = getValueByPath(fromObject, ["latLng"]);
    if (fromLatLng != null) {
      setValueByPath(toObject, ["latLng"], latLngToVertex$1(fromLatLng));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function toolComputerUseToMldev$3(fromObject) {
    const toObject = {};
    const fromEnvironment = getValueByPath(fromObject, ["environment"]);
    if (fromEnvironment != null) {
      setValueByPath(toObject, ["environment"], fromEnvironment);
    }
    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [
      "excludedPredefinedFunctions"
    ]);
    if (fromExcludedPredefinedFunctions != null) {
      setValueByPath(toObject, ["excludedPredefinedFunctions"], fromExcludedPredefinedFunctions);
    }
    return toObject;
  }
  function toolComputerUseToVertex$2(fromObject) {
    const toObject = {};
    const fromEnvironment = getValueByPath(fromObject, ["environment"]);
    if (fromEnvironment != null) {
      setValueByPath(toObject, ["environment"], fromEnvironment);
    }
    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [
      "excludedPredefinedFunctions"
    ]);
    if (fromExcludedPredefinedFunctions != null) {
      setValueByPath(toObject, ["excludedPredefinedFunctions"], fromExcludedPredefinedFunctions);
    }
    return toObject;
  }
  function toolConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$1(fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToMldev$1(fromRetrievalConfig));
    }
    return toObject;
  }
  function toolConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToVertex$1(fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToVertex$1(fromRetrievalConfig));
    }
    return toObject;
  }
  function toolToMldev$3(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToMldev$3(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$3(fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$3(fromGoogleSearchRetrieval));
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
      throw new Error("googleMaps parameter is not supported in Gemini API.");
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], urlContextToMldev$3());
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], toolComputerUseToMldev$3(fromComputerUse));
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function toolToVertex$2(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToVertex$2(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
    if (fromRetrieval != null) {
      setValueByPath(toObject, ["retrieval"], fromRetrieval);
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToVertex$2(fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex$2(fromGoogleSearchRetrieval));
    }
    const fromEnterpriseWebSearch = getValueByPath(fromObject, [
      "enterpriseWebSearch"
    ]);
    if (fromEnterpriseWebSearch != null) {
      setValueByPath(toObject, ["enterpriseWebSearch"], enterpriseWebSearchToVertex$2(fromEnterpriseWebSearch));
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToVertex$2(fromGoogleMaps));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], urlContextToVertex$2());
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], toolComputerUseToVertex$2(fromComputerUse));
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function updateCachedContentConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    return toObject;
  }
  function updateCachedContentConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    return toObject;
  }
  function updateCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      updateCachedContentConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function updateCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      updateCachedContentConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function urlContextToMldev$3() {
    const toObject = {};
    return toObject;
  }
  function urlContextToVertex$2() {
    const toObject = {};
    return toObject;
  }
  function videoMetadataToMldev$3(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function videoMetadataToVertex$2(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  var Caches = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
      this.list = async (params = {}) => {
        return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x3) => this.listInternal(x3), await this.listInternal(params), params);
      };
    }
    /**
     * Creates a cached contents resource.
     *
     * @remarks
     * Context caching is only supported for specific models. See [Gemini
     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
     * for more information.
     *
     * @param params - The parameters for the create request.
     * @return The created cached content.
     *
     * @example
     * ```ts
     * const contents = ...; // Initialize the content to cache.
     * const response = await ai.caches.create({
     *   model: 'gemini-2.0-flash-001',
     *   config: {
     *    'contents': contents,
     *    'displayName': 'test cache',
     *    'systemInstruction': 'What is the sum of the two pdfs?',
     *    'ttl': '86400s',
     *  }
     * });
     * ```
     */
    async create(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = createCachedContentParametersToVertex(this.apiClient, params);
        path = formatMap("cachedContents", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = cachedContentFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = createCachedContentParametersToMldev(this.apiClient, params);
        path = formatMap("cachedContents", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = cachedContentFromMldev(apiResponse);
          return resp;
        });
      }
    }
    /**
     * Gets cached content configurations.
     *
     * @param params - The parameters for the get request.
     * @return The cached content.
     *
     * @example
     * ```ts
     * await ai.caches.get({name: '...'}); // The server-generated resource name.
     * ```
     */
    async get(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = getCachedContentParametersToVertex(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = cachedContentFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = getCachedContentParametersToMldev(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = cachedContentFromMldev(apiResponse);
          return resp;
        });
      }
    }
    /**
     * Deletes cached content.
     *
     * @param params - The parameters for the delete request.
     * @return The empty response returned by the API.
     *
     * @example
     * ```ts
     * await ai.caches.delete({name: '...'}); // The server-generated resource name.
     * ```
     */
    async delete(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = deleteCachedContentParametersToVertex(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteCachedContentResponseFromVertex(apiResponse);
          const typedResp = new DeleteCachedContentResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = deleteCachedContentParametersToMldev(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteCachedContentResponseFromMldev(apiResponse);
          const typedResp = new DeleteCachedContentResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Updates cached content configurations.
     *
     * @param params - The parameters for the update request.
     * @return The updated cached content.
     *
     * @example
     * ```ts
     * const response = await ai.caches.update({
     *   name: '...',  // The server-generated resource name.
     *   config: {'ttl': '7600s'}
     * });
     * ```
     */
    async update(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = updateCachedContentParametersToVertex(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "PATCH",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = cachedContentFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = updateCachedContentParametersToMldev(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "PATCH",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = cachedContentFromMldev(apiResponse);
          return resp;
        });
      }
    }
    async listInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = listCachedContentsParametersToVertex(params);
        path = formatMap("cachedContents", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listCachedContentsResponseFromVertex(apiResponse);
          const typedResp = new ListCachedContentsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = listCachedContentsParametersToMldev(params);
        path = formatMap("cachedContents", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listCachedContentsResponseFromMldev(apiResponse);
          const typedResp = new ListCachedContentsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
  };
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
    if (m2) return m2.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __await(v2) {
    return this instanceof __await ? (this.v = v2, this) : new __await(v2);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function awaitReturn(f) {
      return function(v2) {
        return Promise.resolve(v2).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i[n] = function(v2) {
          return new Promise(function(a, b2) {
            q.push([n, v2, a, b2]) > 1 || resume(n, v2);
          });
        };
        if (f) i[n] = f(i[n]);
      }
    }
    function resume(n, v2) {
      try {
        step(g[n](v2));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v2) {
      if (f(v2), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o[Symbol.asyncIterator], i;
    return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d });
      }, reject);
    }
  }
  function isValidResponse(response) {
    var _a;
    if (response.candidates == void 0 || response.candidates.length === 0) {
      return false;
    }
    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;
    if (content === void 0) {
      return false;
    }
    return isValidContent(content);
  }
  function isValidContent(content) {
    if (content.parts === void 0 || content.parts.length === 0) {
      return false;
    }
    for (const part of content.parts) {
      if (part === void 0 || Object.keys(part).length === 0) {
        return false;
      }
    }
    return true;
  }
  function validateHistory(history) {
    if (history.length === 0) {
      return;
    }
    for (const content of history) {
      if (content.role !== "user" && content.role !== "model") {
        throw new Error(`Role must be user or model, but got ${content.role}.`);
      }
    }
  }
  function extractCuratedHistory(comprehensiveHistory) {
    if (comprehensiveHistory === void 0 || comprehensiveHistory.length === 0) {
      return [];
    }
    const curatedHistory = [];
    const length = comprehensiveHistory.length;
    let i = 0;
    while (i < length) {
      if (comprehensiveHistory[i].role === "user") {
        curatedHistory.push(comprehensiveHistory[i]);
        i++;
      } else {
        const modelOutput = [];
        let isValid = true;
        while (i < length && comprehensiveHistory[i].role === "model") {
          modelOutput.push(comprehensiveHistory[i]);
          if (isValid && !isValidContent(comprehensiveHistory[i])) {
            isValid = false;
          }
          i++;
        }
        if (isValid) {
          curatedHistory.push(...modelOutput);
        } else {
          curatedHistory.pop();
        }
      }
    }
    return curatedHistory;
  }
  var Chats = class {
    constructor(modelsModule, apiClient) {
      this.modelsModule = modelsModule;
      this.apiClient = apiClient;
    }
    /**
     * Creates a new chat session.
     *
     * @remarks
     * The config in the params will be used for all requests within the chat
     * session unless overridden by a per-request `config` in
     * @see {@link types.SendMessageParameters#config}.
     *
     * @param params - Parameters for creating a chat session.
     * @returns A new chat session.
     *
     * @example
     * ```ts
     * const chat = ai.chats.create({
     *   model: 'gemini-2.0-flash'
     *   config: {
     *     temperature: 0.5,
     *     maxOutputTokens: 1024,
     *   }
     * });
     * ```
     */
    create(params) {
      return new Chat(
        this.apiClient,
        this.modelsModule,
        params.model,
        params.config,
        // Deep copy the history to avoid mutating the history outside of the
        // chat session.
        structuredClone(params.history)
      );
    }
  };
  var Chat = class {
    constructor(apiClient, modelsModule, model, config = {}, history = []) {
      this.apiClient = apiClient;
      this.modelsModule = modelsModule;
      this.model = model;
      this.config = config;
      this.history = history;
      this.sendPromise = Promise.resolve();
      validateHistory(history);
    }
    /**
     * Sends a message to the model and returns the response.
     *
     * @remarks
     * This method will wait for the previous message to be processed before
     * sending the next message.
     *
     * @see {@link Chat#sendMessageStream} for streaming method.
     * @param params - parameters for sending messages within a chat session.
     * @returns The model's response.
     *
     * @example
     * ```ts
     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
     * const response = await chat.sendMessage({
     *   message: 'Why is the sky blue?'
     * });
     * console.log(response.text);
     * ```
     */
    async sendMessage(params) {
      var _a;
      await this.sendPromise;
      const inputContent = tContent(params.message);
      const responsePromise = this.modelsModule.generateContent({
        model: this.model,
        contents: this.getHistory(true).concat(inputContent),
        config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config
      });
      this.sendPromise = (async () => {
        var _a2, _b, _c;
        const response = await responsePromise;
        const outputContent = (_b = (_a2 = response.candidates) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.content;
        const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;
        const index = this.getHistory(true).length;
        let automaticFunctionCallingHistory = [];
        if (fullAutomaticFunctionCallingHistory != null) {
          automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];
        }
        const modelOutput = outputContent ? [outputContent] : [];
        this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);
        return;
      })();
      await this.sendPromise.catch(() => {
        this.sendPromise = Promise.resolve();
      });
      return responsePromise;
    }
    /**
     * Sends a message to the model and returns the response in chunks.
     *
     * @remarks
     * This method will wait for the previous message to be processed before
     * sending the next message.
     *
     * @see {@link Chat#sendMessage} for non-streaming method.
     * @param params - parameters for sending the message.
     * @return The model's response.
     *
     * @example
     * ```ts
     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
     * const response = await chat.sendMessageStream({
     *   message: 'Why is the sky blue?'
     * });
     * for await (const chunk of response) {
     *   console.log(chunk.text);
     * }
     * ```
     */
    async sendMessageStream(params) {
      var _a;
      await this.sendPromise;
      const inputContent = tContent(params.message);
      const streamResponse = this.modelsModule.generateContentStream({
        model: this.model,
        contents: this.getHistory(true).concat(inputContent),
        config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config
      });
      this.sendPromise = streamResponse.then(() => void 0).catch(() => void 0);
      const response = await streamResponse;
      const result = this.processStreamResponse(response, inputContent);
      return result;
    }
    /**
     * Returns the chat history.
     *
     * @remarks
     * The history is a list of contents alternating between user and model.
     *
     * There are two types of history:
     * - The `curated history` contains only the valid turns between user and
     * model, which will be included in the subsequent requests sent to the model.
     * - The `comprehensive history` contains all turns, including invalid or
     *   empty model outputs, providing a complete record of the history.
     *
     * The history is updated after receiving the response from the model,
     * for streaming response, it means receiving the last chunk of the response.
     *
     * The `comprehensive history` is returned by default. To get the `curated
     * history`, set the `curated` parameter to `true`.
     *
     * @param curated - whether to return the curated history or the comprehensive
     *     history.
     * @return History contents alternating between user and model for the entire
     *     chat session.
     */
    getHistory(curated = false) {
      const history = curated ? extractCuratedHistory(this.history) : this.history;
      return structuredClone(history);
    }
    processStreamResponse(streamResponse, inputContent) {
      var _a, _b;
      return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
        var _c, e_1, _d, _e;
        const outputContent = [];
        try {
          for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true) {
            _e = streamResponse_1_1.value;
            _f = false;
            const chunk = _e;
            if (isValidResponse(chunk)) {
              const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;
              if (content !== void 0) {
                outputContent.push(content);
              }
            }
            yield yield __await(chunk);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        this.recordHistory(inputContent, outputContent);
      });
    }
    recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {
      let outputContents = [];
      if (modelOutput.length > 0 && modelOutput.every((content) => content.role !== void 0)) {
        outputContents = modelOutput;
      } else {
        outputContents.push({
          role: "model",
          parts: []
        });
      }
      if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {
        this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));
      } else {
        this.history.push(userInput);
      }
      this.history.push(...outputContents);
    }
  };
  var ApiError = class _ApiError extends Error {
    constructor(options) {
      super(options.message);
      this.name = "ApiError";
      this.status = options.status;
      Object.setPrototypeOf(this, _ApiError.prototype);
    }
  };
  function createFileParametersToMldev(fromObject) {
    const toObject = {};
    const fromFile = getValueByPath(fromObject, ["file"]);
    if (fromFile != null) {
      setValueByPath(toObject, ["file"], fileToMldev(fromFile));
    }
    return toObject;
  }
  function createFileResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function deleteFileParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
    }
    return toObject;
  }
  function deleteFileResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function fileFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    const fromSizeBytes = getValueByPath(fromObject, ["sizeBytes"]);
    if (fromSizeBytes != null) {
      setValueByPath(toObject, ["sizeBytes"], fromSizeBytes);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromExpirationTime = getValueByPath(fromObject, [
      "expirationTime"
    ]);
    if (fromExpirationTime != null) {
      setValueByPath(toObject, ["expirationTime"], fromExpirationTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromSha256Hash = getValueByPath(fromObject, ["sha256Hash"]);
    if (fromSha256Hash != null) {
      setValueByPath(toObject, ["sha256Hash"], fromSha256Hash);
    }
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromDownloadUri = getValueByPath(fromObject, ["downloadUri"]);
    if (fromDownloadUri != null) {
      setValueByPath(toObject, ["downloadUri"], fromDownloadUri);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], fromState);
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      setValueByPath(toObject, ["source"], fromSource);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fileStatusFromMldev(fromError));
    }
    return toObject;
  }
  function fileStatusFromMldev(fromObject) {
    const toObject = {};
    const fromDetails = getValueByPath(fromObject, ["details"]);
    if (fromDetails != null) {
      setValueByPath(toObject, ["details"], fromDetails);
    }
    const fromMessage = getValueByPath(fromObject, ["message"]);
    if (fromMessage != null) {
      setValueByPath(toObject, ["message"], fromMessage);
    }
    const fromCode = getValueByPath(fromObject, ["code"]);
    if (fromCode != null) {
      setValueByPath(toObject, ["code"], fromCode);
    }
    return toObject;
  }
  function fileStatusToMldev(fromObject) {
    const toObject = {};
    const fromDetails = getValueByPath(fromObject, ["details"]);
    if (fromDetails != null) {
      setValueByPath(toObject, ["details"], fromDetails);
    }
    const fromMessage = getValueByPath(fromObject, ["message"]);
    if (fromMessage != null) {
      setValueByPath(toObject, ["message"], fromMessage);
    }
    const fromCode = getValueByPath(fromObject, ["code"]);
    if (fromCode != null) {
      setValueByPath(toObject, ["code"], fromCode);
    }
    return toObject;
  }
  function fileToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    const fromSizeBytes = getValueByPath(fromObject, ["sizeBytes"]);
    if (fromSizeBytes != null) {
      setValueByPath(toObject, ["sizeBytes"], fromSizeBytes);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromExpirationTime = getValueByPath(fromObject, [
      "expirationTime"
    ]);
    if (fromExpirationTime != null) {
      setValueByPath(toObject, ["expirationTime"], fromExpirationTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromSha256Hash = getValueByPath(fromObject, ["sha256Hash"]);
    if (fromSha256Hash != null) {
      setValueByPath(toObject, ["sha256Hash"], fromSha256Hash);
    }
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromDownloadUri = getValueByPath(fromObject, ["downloadUri"]);
    if (fromDownloadUri != null) {
      setValueByPath(toObject, ["downloadUri"], fromDownloadUri);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], fromState);
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      setValueByPath(toObject, ["source"], fromSource);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fileStatusToMldev(fromError));
    }
    return toObject;
  }
  function getFileParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
    }
    return toObject;
  }
  function listFilesConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listFilesParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listFilesConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listFilesResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromFiles = getValueByPath(fromObject, ["files"]);
    if (fromFiles != null) {
      let transformedList = fromFiles;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return fileFromMldev(item);
        });
      }
      setValueByPath(toObject, ["files"], transformedList);
    }
    return toObject;
  }
  var Files = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
      this.list = async (params = {}) => {
        return new Pager(PagedItem.PAGED_ITEM_FILES, (x3) => this.listInternal(x3), await this.listInternal(params), params);
      };
    }
    /**
     * Uploads a file asynchronously to the Gemini API.
     * This method is not available in Vertex AI.
     * Supported upload sources:
     * - Node.js: File path (string) or Blob object.
     * - Browser: Blob object (e.g., File).
     *
     * @remarks
     * The `mimeType` can be specified in the `config` parameter. If omitted:
     *  - For file path (string) inputs, the `mimeType` will be inferred from the
     *     file extension.
     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
     *     property.
     * Somex eamples for file extension to mimeType mapping:
     * .txt -> text/plain
     * .json -> application/json
     * .jpg  -> image/jpeg
     * .png -> image/png
     * .mp3 -> audio/mpeg
     * .mp4 -> video/mp4
     *
     * This section can contain multiple paragraphs and code examples.
     *
     * @param params - Optional parameters specified in the
     *        `types.UploadFileParameters` interface.
     *         @see {@link types.UploadFileParameters#config} for the optional
     *         config in the parameters.
     * @return A promise that resolves to a `types.File` object.
     * @throws An error if called on a Vertex AI client.
     * @throws An error if the `mimeType` is not provided and can not be inferred,
     * the `mimeType` can be provided in the `params.config` parameter.
     * @throws An error occurs if a suitable upload location cannot be established.
     *
     * @example
     * The following code uploads a file to Gemini API.
     *
     * ```ts
     * const file = await ai.files.upload({file: 'file.txt', config: {
     *   mimeType: 'text/plain',
     * }});
     * console.log(file.name);
     * ```
     */
    async upload(params) {
      if (this.apiClient.isVertexAI()) {
        throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
      }
      return this.apiClient.uploadFile(params.file, params.config).then((response) => {
        const file = fileFromMldev(response);
        return file;
      });
    }
    /**
     * Downloads a remotely stored file asynchronously to a location specified in
     * the `params` object. This method only works on Node environment, to
     * download files in the browser, use a browser compliant method like an <a>
     * tag.
     *
     * @param params - The parameters for the download request.
     *
     * @example
     * The following code downloads an example file named "files/mehozpxf877d" as
     * "file.txt".
     *
     * ```ts
     * await ai.files.download({file: file.name, downloadPath: 'file.txt'});
     * ```
     */
    async download(params) {
      await this.apiClient.downloadFile(params);
    }
    async listInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = listFilesParametersToMldev(params);
        path = formatMap("files", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listFilesResponseFromMldev(apiResponse);
          const typedResp = new ListFilesResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    async createInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = createFileParametersToMldev(params);
        path = formatMap("upload/v1beta/files", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = createFileResponseFromMldev(apiResponse);
          const typedResp = new CreateFileResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Retrieves the file information from the service.
     *
     * @param params - The parameters for the get request
     * @return The Promise that resolves to the types.File object requested.
     *
     * @example
     * ```ts
     * const config: GetFileParameters = {
     *   name: fileName,
     * };
     * file = await ai.files.get(config);
     * console.log(file.name);
     * ```
     */
    async get(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = getFileParametersToMldev(params);
        path = formatMap("files/{file}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = fileFromMldev(apiResponse);
          return resp;
        });
      }
    }
    /**
     * Deletes a remotely stored file.
     *
     * @param params - The parameters for the delete request.
     * @return The DeleteFileResponse, the response for the delete method.
     *
     * @example
     * The following code deletes an example file named "files/mehozpxf877d".
     *
     * ```ts
     * await ai.files.delete({name: file.name});
     * ```
     */
    async delete(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = deleteFileParametersToMldev(params);
        path = formatMap("files/{file}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteFileResponseFromMldev(apiResponse);
          const typedResp = new DeleteFileResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
  };
  function activityEndToMldev() {
    const toObject = {};
    return toObject;
  }
  function activityEndToVertex() {
    const toObject = {};
    return toObject;
  }
  function activityStartToMldev() {
    const toObject = {};
    return toObject;
  }
  function activityStartToVertex() {
    const toObject = {};
    return toObject;
  }
  function apiKeyConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromApiKeyString = getValueByPath(fromObject, ["apiKeyString"]);
    if (fromApiKeyString != null) {
      setValueByPath(toObject, ["apiKeyString"], fromApiKeyString);
    }
    return toObject;
  }
  function audioChunkFromMldev(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    const fromSourceMetadata = getValueByPath(fromObject, [
      "sourceMetadata"
    ]);
    if (fromSourceMetadata != null) {
      setValueByPath(toObject, ["sourceMetadata"], liveMusicSourceMetadataFromMldev(fromSourceMetadata));
    }
    return toObject;
  }
  function audioTranscriptionConfigToMldev$1() {
    const toObject = {};
    return toObject;
  }
  function audioTranscriptionConfigToVertex() {
    const toObject = {};
    return toObject;
  }
  function authConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromApiKeyConfig = getValueByPath(fromObject, ["apiKeyConfig"]);
    if (fromApiKeyConfig != null) {
      setValueByPath(toObject, ["apiKeyConfig"], apiKeyConfigToVertex$1(fromApiKeyConfig));
    }
    const fromAuthType = getValueByPath(fromObject, ["authType"]);
    if (fromAuthType != null) {
      setValueByPath(toObject, ["authType"], fromAuthType);
    }
    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [
      "googleServiceAccountConfig"
    ]);
    if (fromGoogleServiceAccountConfig != null) {
      setValueByPath(toObject, ["googleServiceAccountConfig"], fromGoogleServiceAccountConfig);
    }
    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [
      "httpBasicAuthConfig"
    ]);
    if (fromHttpBasicAuthConfig != null) {
      setValueByPath(toObject, ["httpBasicAuthConfig"], fromHttpBasicAuthConfig);
    }
    const fromOauthConfig = getValueByPath(fromObject, ["oauthConfig"]);
    if (fromOauthConfig != null) {
      setValueByPath(toObject, ["oauthConfig"], fromOauthConfig);
    }
    const fromOidcConfig = getValueByPath(fromObject, ["oidcConfig"]);
    if (fromOidcConfig != null) {
      setValueByPath(toObject, ["oidcConfig"], fromOidcConfig);
    }
    return toObject;
  }
  function automaticActivityDetectionToMldev$1(fromObject) {
    const toObject = {};
    const fromDisabled = getValueByPath(fromObject, ["disabled"]);
    if (fromDisabled != null) {
      setValueByPath(toObject, ["disabled"], fromDisabled);
    }
    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [
      "startOfSpeechSensitivity"
    ]);
    if (fromStartOfSpeechSensitivity != null) {
      setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
    }
    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [
      "endOfSpeechSensitivity"
    ]);
    if (fromEndOfSpeechSensitivity != null) {
      setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
    }
    const fromPrefixPaddingMs = getValueByPath(fromObject, [
      "prefixPaddingMs"
    ]);
    if (fromPrefixPaddingMs != null) {
      setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
    }
    const fromSilenceDurationMs = getValueByPath(fromObject, [
      "silenceDurationMs"
    ]);
    if (fromSilenceDurationMs != null) {
      setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
    }
    return toObject;
  }
  function automaticActivityDetectionToVertex(fromObject) {
    const toObject = {};
    const fromDisabled = getValueByPath(fromObject, ["disabled"]);
    if (fromDisabled != null) {
      setValueByPath(toObject, ["disabled"], fromDisabled);
    }
    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [
      "startOfSpeechSensitivity"
    ]);
    if (fromStartOfSpeechSensitivity != null) {
      setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
    }
    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [
      "endOfSpeechSensitivity"
    ]);
    if (fromEndOfSpeechSensitivity != null) {
      setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
    }
    const fromPrefixPaddingMs = getValueByPath(fromObject, [
      "prefixPaddingMs"
    ]);
    if (fromPrefixPaddingMs != null) {
      setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
    }
    const fromSilenceDurationMs = getValueByPath(fromObject, [
      "silenceDurationMs"
    ]);
    if (fromSilenceDurationMs != null) {
      setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
    }
    return toObject;
  }
  function blobFromMldev$1(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function blobFromVertex$1(fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function blobToMldev$2(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function blobToVertex$1(fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function contentFromMldev$1(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partFromMldev$1(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function contentFromVertex$1(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partFromVertex$1(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function contentToMldev$2(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$2(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function contentToVertex$1(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToVertex$1(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function contextWindowCompressionConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromTriggerTokens = getValueByPath(fromObject, [
      "triggerTokens"
    ]);
    if (fromTriggerTokens != null) {
      setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
    }
    const fromSlidingWindow = getValueByPath(fromObject, [
      "slidingWindow"
    ]);
    if (fromSlidingWindow != null) {
      setValueByPath(toObject, ["slidingWindow"], slidingWindowToMldev$1(fromSlidingWindow));
    }
    return toObject;
  }
  function contextWindowCompressionConfigToVertex(fromObject) {
    const toObject = {};
    const fromTriggerTokens = getValueByPath(fromObject, [
      "triggerTokens"
    ]);
    if (fromTriggerTokens != null) {
      setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
    }
    const fromSlidingWindow = getValueByPath(fromObject, [
      "slidingWindow"
    ]);
    if (fromSlidingWindow != null) {
      setValueByPath(toObject, ["slidingWindow"], slidingWindowToVertex(fromSlidingWindow));
    }
    return toObject;
  }
  function dynamicRetrievalConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function dynamicRetrievalConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function enterpriseWebSearchToVertex$1(fromObject) {
    const toObject = {};
    const fromExcludeDomains = getValueByPath(fromObject, [
      "excludeDomains"
    ]);
    if (fromExcludeDomains != null) {
      setValueByPath(toObject, ["excludeDomains"], fromExcludeDomains);
    }
    return toObject;
  }
  function fileDataFromMldev$1(fromObject) {
    const toObject = {};
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataFromVertex$1(fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataToMldev$2(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataToVertex$1(fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallFromMldev$1(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionCallFromVertex$1(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionCallToMldev$2(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionCallToVertex$1(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionDeclarationToMldev$2(fromObject) {
    const toObject = {};
    const fromBehavior = getValueByPath(fromObject, ["behavior"]);
    if (fromBehavior != null) {
      setValueByPath(toObject, ["behavior"], fromBehavior);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function functionDeclarationToVertex$1(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
      throw new Error("behavior parameter is not supported in Vertex AI.");
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function googleMapsToVertex$1(fromObject) {
    const toObject = {};
    const fromAuthConfig = getValueByPath(fromObject, ["authConfig"]);
    if (fromAuthConfig != null) {
      setValueByPath(toObject, ["authConfig"], authConfigToVertex$1(fromAuthConfig));
    }
    return toObject;
  }
  function googleSearchRetrievalToMldev$2(fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$2(fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function googleSearchRetrievalToVertex$1(fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex$1(fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function googleSearchToMldev$2(fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$2(fromTimeRangeFilter));
    }
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function googleSearchToVertex$1(fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToVertex$1(fromTimeRangeFilter));
    }
    const fromExcludeDomains = getValueByPath(fromObject, [
      "excludeDomains"
    ]);
    if (fromExcludeDomains != null) {
      setValueByPath(toObject, ["excludeDomains"], fromExcludeDomains);
    }
    return toObject;
  }
  function intervalToMldev$2(fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function intervalToVertex$1(fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function liveConnectConfigToMldev$1(fromObject, parentObject) {
    const toObject = {};
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (parentObject !== void 0 && fromResponseModalities != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (parentObject !== void 0 && fromTemperature != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (parentObject !== void 0 && fromTopP != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (parentObject !== void 0 && fromTopK != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (parentObject !== void 0 && fromMaxOutputTokens != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (parentObject !== void 0 && fromMediaResolution != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (parentObject !== void 0 && fromSpeechConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToMldev$2(tLiveSpeechConfig(fromSpeechConfig)));
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev$2(tContent(fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$2(tTool(item));
        });
      }
      setValueByPath(parentObject, ["setup", "tools"], transformedList);
    }
    const fromSessionResumption = getValueByPath(fromObject, [
      "sessionResumption"
    ]);
    if (parentObject !== void 0 && fromSessionResumption != null) {
      setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev$1(fromSessionResumption));
    }
    const fromInputAudioTranscription = getValueByPath(fromObject, [
      "inputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromInputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "inputAudioTranscription"], audioTranscriptionConfigToMldev$1());
    }
    const fromOutputAudioTranscription = getValueByPath(fromObject, [
      "outputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToMldev$1());
    }
    const fromRealtimeInputConfig = getValueByPath(fromObject, [
      "realtimeInputConfig"
    ]);
    if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
      setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToMldev$1(fromRealtimeInputConfig));
    }
    const fromContextWindowCompression = getValueByPath(fromObject, [
      "contextWindowCompression"
    ]);
    if (parentObject !== void 0 && fromContextWindowCompression != null) {
      setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToMldev$1(fromContextWindowCompression));
    }
    const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
    if (parentObject !== void 0 && fromProactivity != null) {
      setValueByPath(parentObject, ["setup", "proactivity"], proactivityConfigToMldev$1(fromProactivity));
    }
    return toObject;
  }
  function liveConnectConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (parentObject !== void 0 && fromResponseModalities != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (parentObject !== void 0 && fromTemperature != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (parentObject !== void 0 && fromTopP != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (parentObject !== void 0 && fromTopK != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (parentObject !== void 0 && fromMaxOutputTokens != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (parentObject !== void 0 && fromMediaResolution != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (parentObject !== void 0 && fromSpeechConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["setup", "systemInstruction"], contentToVertex$1(tContent(fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex$1(tTool(item));
        });
      }
      setValueByPath(parentObject, ["setup", "tools"], transformedList);
    }
    const fromSessionResumption = getValueByPath(fromObject, [
      "sessionResumption"
    ]);
    if (parentObject !== void 0 && fromSessionResumption != null) {
      setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToVertex(fromSessionResumption));
    }
    const fromInputAudioTranscription = getValueByPath(fromObject, [
      "inputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromInputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "inputAudioTranscription"], audioTranscriptionConfigToVertex());
    }
    const fromOutputAudioTranscription = getValueByPath(fromObject, [
      "outputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToVertex());
    }
    const fromRealtimeInputConfig = getValueByPath(fromObject, [
      "realtimeInputConfig"
    ]);
    if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
      setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToVertex(fromRealtimeInputConfig));
    }
    const fromContextWindowCompression = getValueByPath(fromObject, [
      "contextWindowCompression"
    ]);
    if (parentObject !== void 0 && fromContextWindowCompression != null) {
      setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToVertex(fromContextWindowCompression));
    }
    const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
    if (parentObject !== void 0 && fromProactivity != null) {
      setValueByPath(parentObject, ["setup", "proactivity"], proactivityConfigToVertex(fromProactivity));
    }
    return toObject;
  }
  function liveConnectParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], liveConnectConfigToMldev$1(fromConfig, toObject));
    }
    return toObject;
  }
  function liveConnectParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], liveConnectConfigToVertex(fromConfig, toObject));
    }
    return toObject;
  }
  function liveMusicClientContentFromMldev(fromObject) {
    const toObject = {};
    const fromWeightedPrompts = getValueByPath(fromObject, [
      "weightedPrompts"
    ]);
    if (fromWeightedPrompts != null) {
      let transformedList = fromWeightedPrompts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return weightedPromptFromMldev(item);
        });
      }
      setValueByPath(toObject, ["weightedPrompts"], transformedList);
    }
    return toObject;
  }
  function liveMusicClientContentToMldev(fromObject) {
    const toObject = {};
    const fromWeightedPrompts = getValueByPath(fromObject, [
      "weightedPrompts"
    ]);
    if (fromWeightedPrompts != null) {
      let transformedList = fromWeightedPrompts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return weightedPromptToMldev(item);
        });
      }
      setValueByPath(toObject, ["weightedPrompts"], transformedList);
    }
    return toObject;
  }
  function liveMusicClientMessageToMldev(fromObject) {
    const toObject = {};
    const fromSetup = getValueByPath(fromObject, ["setup"]);
    if (fromSetup != null) {
      setValueByPath(toObject, ["setup"], liveMusicClientSetupToMldev(fromSetup));
    }
    const fromClientContent = getValueByPath(fromObject, [
      "clientContent"
    ]);
    if (fromClientContent != null) {
      setValueByPath(toObject, ["clientContent"], liveMusicClientContentToMldev(fromClientContent));
    }
    const fromMusicGenerationConfig = getValueByPath(fromObject, [
      "musicGenerationConfig"
    ]);
    if (fromMusicGenerationConfig != null) {
      setValueByPath(toObject, ["musicGenerationConfig"], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));
    }
    const fromPlaybackControl = getValueByPath(fromObject, [
      "playbackControl"
    ]);
    if (fromPlaybackControl != null) {
      setValueByPath(toObject, ["playbackControl"], fromPlaybackControl);
    }
    return toObject;
  }
  function liveMusicClientSetupToMldev(fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    return toObject;
  }
  function liveMusicFilteredPromptFromMldev(fromObject) {
    const toObject = {};
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromFilteredReason = getValueByPath(fromObject, [
      "filteredReason"
    ]);
    if (fromFilteredReason != null) {
      setValueByPath(toObject, ["filteredReason"], fromFilteredReason);
    }
    return toObject;
  }
  function liveMusicGenerationConfigFromMldev(fromObject) {
    const toObject = {};
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromGuidance = getValueByPath(fromObject, ["guidance"]);
    if (fromGuidance != null) {
      setValueByPath(toObject, ["guidance"], fromGuidance);
    }
    const fromBpm = getValueByPath(fromObject, ["bpm"]);
    if (fromBpm != null) {
      setValueByPath(toObject, ["bpm"], fromBpm);
    }
    const fromDensity = getValueByPath(fromObject, ["density"]);
    if (fromDensity != null) {
      setValueByPath(toObject, ["density"], fromDensity);
    }
    const fromBrightness = getValueByPath(fromObject, ["brightness"]);
    if (fromBrightness != null) {
      setValueByPath(toObject, ["brightness"], fromBrightness);
    }
    const fromScale = getValueByPath(fromObject, ["scale"]);
    if (fromScale != null) {
      setValueByPath(toObject, ["scale"], fromScale);
    }
    const fromMuteBass = getValueByPath(fromObject, ["muteBass"]);
    if (fromMuteBass != null) {
      setValueByPath(toObject, ["muteBass"], fromMuteBass);
    }
    const fromMuteDrums = getValueByPath(fromObject, ["muteDrums"]);
    if (fromMuteDrums != null) {
      setValueByPath(toObject, ["muteDrums"], fromMuteDrums);
    }
    const fromOnlyBassAndDrums = getValueByPath(fromObject, [
      "onlyBassAndDrums"
    ]);
    if (fromOnlyBassAndDrums != null) {
      setValueByPath(toObject, ["onlyBassAndDrums"], fromOnlyBassAndDrums);
    }
    const fromMusicGenerationMode = getValueByPath(fromObject, [
      "musicGenerationMode"
    ]);
    if (fromMusicGenerationMode != null) {
      setValueByPath(toObject, ["musicGenerationMode"], fromMusicGenerationMode);
    }
    return toObject;
  }
  function liveMusicGenerationConfigToMldev(fromObject) {
    const toObject = {};
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromGuidance = getValueByPath(fromObject, ["guidance"]);
    if (fromGuidance != null) {
      setValueByPath(toObject, ["guidance"], fromGuidance);
    }
    const fromBpm = getValueByPath(fromObject, ["bpm"]);
    if (fromBpm != null) {
      setValueByPath(toObject, ["bpm"], fromBpm);
    }
    const fromDensity = getValueByPath(fromObject, ["density"]);
    if (fromDensity != null) {
      setValueByPath(toObject, ["density"], fromDensity);
    }
    const fromBrightness = getValueByPath(fromObject, ["brightness"]);
    if (fromBrightness != null) {
      setValueByPath(toObject, ["brightness"], fromBrightness);
    }
    const fromScale = getValueByPath(fromObject, ["scale"]);
    if (fromScale != null) {
      setValueByPath(toObject, ["scale"], fromScale);
    }
    const fromMuteBass = getValueByPath(fromObject, ["muteBass"]);
    if (fromMuteBass != null) {
      setValueByPath(toObject, ["muteBass"], fromMuteBass);
    }
    const fromMuteDrums = getValueByPath(fromObject, ["muteDrums"]);
    if (fromMuteDrums != null) {
      setValueByPath(toObject, ["muteDrums"], fromMuteDrums);
    }
    const fromOnlyBassAndDrums = getValueByPath(fromObject, [
      "onlyBassAndDrums"
    ]);
    if (fromOnlyBassAndDrums != null) {
      setValueByPath(toObject, ["onlyBassAndDrums"], fromOnlyBassAndDrums);
    }
    const fromMusicGenerationMode = getValueByPath(fromObject, [
      "musicGenerationMode"
    ]);
    if (fromMusicGenerationMode != null) {
      setValueByPath(toObject, ["musicGenerationMode"], fromMusicGenerationMode);
    }
    return toObject;
  }
  function liveMusicServerContentFromMldev(fromObject) {
    const toObject = {};
    const fromAudioChunks = getValueByPath(fromObject, ["audioChunks"]);
    if (fromAudioChunks != null) {
      let transformedList = fromAudioChunks;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return audioChunkFromMldev(item);
        });
      }
      setValueByPath(toObject, ["audioChunks"], transformedList);
    }
    return toObject;
  }
  function liveMusicServerMessageFromMldev(fromObject) {
    const toObject = {};
    const fromSetupComplete = getValueByPath(fromObject, [
      "setupComplete"
    ]);
    if (fromSetupComplete != null) {
      setValueByPath(toObject, ["setupComplete"], liveMusicServerSetupCompleteFromMldev());
    }
    const fromServerContent = getValueByPath(fromObject, [
      "serverContent"
    ]);
    if (fromServerContent != null) {
      setValueByPath(toObject, ["serverContent"], liveMusicServerContentFromMldev(fromServerContent));
    }
    const fromFilteredPrompt = getValueByPath(fromObject, [
      "filteredPrompt"
    ]);
    if (fromFilteredPrompt != null) {
      setValueByPath(toObject, ["filteredPrompt"], liveMusicFilteredPromptFromMldev(fromFilteredPrompt));
    }
    return toObject;
  }
  function liveMusicServerSetupCompleteFromMldev() {
    const toObject = {};
    return toObject;
  }
  function liveMusicSetConfigParametersToMldev(fromObject) {
    const toObject = {};
    const fromMusicGenerationConfig = getValueByPath(fromObject, [
      "musicGenerationConfig"
    ]);
    if (fromMusicGenerationConfig != null) {
      setValueByPath(toObject, ["musicGenerationConfig"], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));
    }
    return toObject;
  }
  function liveMusicSetWeightedPromptsParametersToMldev(fromObject) {
    const toObject = {};
    const fromWeightedPrompts = getValueByPath(fromObject, [
      "weightedPrompts"
    ]);
    if (fromWeightedPrompts != null) {
      let transformedList = fromWeightedPrompts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return weightedPromptToMldev(item);
        });
      }
      setValueByPath(toObject, ["weightedPrompts"], transformedList);
    }
    return toObject;
  }
  function liveMusicSourceMetadataFromMldev(fromObject) {
    const toObject = {};
    const fromClientContent = getValueByPath(fromObject, [
      "clientContent"
    ]);
    if (fromClientContent != null) {
      setValueByPath(toObject, ["clientContent"], liveMusicClientContentFromMldev(fromClientContent));
    }
    const fromMusicGenerationConfig = getValueByPath(fromObject, [
      "musicGenerationConfig"
    ]);
    if (fromMusicGenerationConfig != null) {
      setValueByPath(toObject, ["musicGenerationConfig"], liveMusicGenerationConfigFromMldev(fromMusicGenerationConfig));
    }
    return toObject;
  }
  function liveSendRealtimeInputParametersToMldev(fromObject) {
    const toObject = {};
    const fromMedia = getValueByPath(fromObject, ["media"]);
    if (fromMedia != null) {
      let transformedList = tBlobs(fromMedia);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["mediaChunks"], transformedList);
    }
    const fromAudio = getValueByPath(fromObject, ["audio"]);
    if (fromAudio != null) {
      setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
    }
    const fromAudioStreamEnd = getValueByPath(fromObject, [
      "audioStreamEnd"
    ]);
    if (fromAudioStreamEnd != null) {
      setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromActivityStart = getValueByPath(fromObject, [
      "activityStart"
    ]);
    if (fromActivityStart != null) {
      setValueByPath(toObject, ["activityStart"], activityStartToMldev());
    }
    const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
    if (fromActivityEnd != null) {
      setValueByPath(toObject, ["activityEnd"], activityEndToMldev());
    }
    return toObject;
  }
  function liveSendRealtimeInputParametersToVertex(fromObject) {
    const toObject = {};
    const fromMedia = getValueByPath(fromObject, ["media"]);
    if (fromMedia != null) {
      let transformedList = tBlobs(fromMedia);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["mediaChunks"], transformedList);
    }
    const fromAudio = getValueByPath(fromObject, ["audio"]);
    if (fromAudio != null) {
      setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
    }
    const fromAudioStreamEnd = getValueByPath(fromObject, [
      "audioStreamEnd"
    ]);
    if (fromAudioStreamEnd != null) {
      setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromActivityStart = getValueByPath(fromObject, [
      "activityStart"
    ]);
    if (fromActivityStart != null) {
      setValueByPath(toObject, ["activityStart"], activityStartToVertex());
    }
    const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
    if (fromActivityEnd != null) {
      setValueByPath(toObject, ["activityEnd"], activityEndToVertex());
    }
    return toObject;
  }
  function liveServerContentFromMldev(fromObject) {
    const toObject = {};
    const fromModelTurn = getValueByPath(fromObject, ["modelTurn"]);
    if (fromModelTurn != null) {
      setValueByPath(toObject, ["modelTurn"], contentFromMldev$1(fromModelTurn));
    }
    const fromTurnComplete = getValueByPath(fromObject, ["turnComplete"]);
    if (fromTurnComplete != null) {
      setValueByPath(toObject, ["turnComplete"], fromTurnComplete);
    }
    const fromInterrupted = getValueByPath(fromObject, ["interrupted"]);
    if (fromInterrupted != null) {
      setValueByPath(toObject, ["interrupted"], fromInterrupted);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromGenerationComplete = getValueByPath(fromObject, [
      "generationComplete"
    ]);
    if (fromGenerationComplete != null) {
      setValueByPath(toObject, ["generationComplete"], fromGenerationComplete);
    }
    const fromInputTranscription = getValueByPath(fromObject, [
      "inputTranscription"
    ]);
    if (fromInputTranscription != null) {
      setValueByPath(toObject, ["inputTranscription"], transcriptionFromMldev(fromInputTranscription));
    }
    const fromOutputTranscription = getValueByPath(fromObject, [
      "outputTranscription"
    ]);
    if (fromOutputTranscription != null) {
      setValueByPath(toObject, ["outputTranscription"], transcriptionFromMldev(fromOutputTranscription));
    }
    const fromUrlContextMetadata = getValueByPath(fromObject, [
      "urlContextMetadata"
    ]);
    if (fromUrlContextMetadata != null) {
      setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromMldev$1(fromUrlContextMetadata));
    }
    const fromTurnCompleteReason = getValueByPath(fromObject, [
      "turnCompleteReason"
    ]);
    if (fromTurnCompleteReason != null) {
      setValueByPath(toObject, ["turnCompleteReason"], fromTurnCompleteReason);
    }
    const fromWaitingForInput = getValueByPath(fromObject, [
      "waitingForInput"
    ]);
    if (fromWaitingForInput != null) {
      setValueByPath(toObject, ["waitingForInput"], fromWaitingForInput);
    }
    return toObject;
  }
  function liveServerContentFromVertex(fromObject) {
    const toObject = {};
    const fromModelTurn = getValueByPath(fromObject, ["modelTurn"]);
    if (fromModelTurn != null) {
      setValueByPath(toObject, ["modelTurn"], contentFromVertex$1(fromModelTurn));
    }
    const fromTurnComplete = getValueByPath(fromObject, ["turnComplete"]);
    if (fromTurnComplete != null) {
      setValueByPath(toObject, ["turnComplete"], fromTurnComplete);
    }
    const fromInterrupted = getValueByPath(fromObject, ["interrupted"]);
    if (fromInterrupted != null) {
      setValueByPath(toObject, ["interrupted"], fromInterrupted);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromGenerationComplete = getValueByPath(fromObject, [
      "generationComplete"
    ]);
    if (fromGenerationComplete != null) {
      setValueByPath(toObject, ["generationComplete"], fromGenerationComplete);
    }
    const fromInputTranscription = getValueByPath(fromObject, [
      "inputTranscription"
    ]);
    if (fromInputTranscription != null) {
      setValueByPath(toObject, ["inputTranscription"], transcriptionFromVertex(fromInputTranscription));
    }
    const fromOutputTranscription = getValueByPath(fromObject, [
      "outputTranscription"
    ]);
    if (fromOutputTranscription != null) {
      setValueByPath(toObject, ["outputTranscription"], transcriptionFromVertex(fromOutputTranscription));
    }
    const fromTurnCompleteReason = getValueByPath(fromObject, [
      "turnCompleteReason"
    ]);
    if (fromTurnCompleteReason != null) {
      setValueByPath(toObject, ["turnCompleteReason"], fromTurnCompleteReason);
    }
    const fromWaitingForInput = getValueByPath(fromObject, [
      "waitingForInput"
    ]);
    if (fromWaitingForInput != null) {
      setValueByPath(toObject, ["waitingForInput"], fromWaitingForInput);
    }
    return toObject;
  }
  function liveServerGoAwayFromMldev(fromObject) {
    const toObject = {};
    const fromTimeLeft = getValueByPath(fromObject, ["timeLeft"]);
    if (fromTimeLeft != null) {
      setValueByPath(toObject, ["timeLeft"], fromTimeLeft);
    }
    return toObject;
  }
  function liveServerGoAwayFromVertex(fromObject) {
    const toObject = {};
    const fromTimeLeft = getValueByPath(fromObject, ["timeLeft"]);
    if (fromTimeLeft != null) {
      setValueByPath(toObject, ["timeLeft"], fromTimeLeft);
    }
    return toObject;
  }
  function liveServerMessageFromMldev(fromObject) {
    const toObject = {};
    const fromSetupComplete = getValueByPath(fromObject, [
      "setupComplete"
    ]);
    if (fromSetupComplete != null) {
      setValueByPath(toObject, ["setupComplete"], liveServerSetupCompleteFromMldev());
    }
    const fromServerContent = getValueByPath(fromObject, [
      "serverContent"
    ]);
    if (fromServerContent != null) {
      setValueByPath(toObject, ["serverContent"], liveServerContentFromMldev(fromServerContent));
    }
    const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
    if (fromToolCall != null) {
      setValueByPath(toObject, ["toolCall"], liveServerToolCallFromMldev(fromToolCall));
    }
    const fromToolCallCancellation = getValueByPath(fromObject, [
      "toolCallCancellation"
    ]);
    if (fromToolCallCancellation != null) {
      setValueByPath(toObject, ["toolCallCancellation"], liveServerToolCallCancellationFromMldev(fromToolCallCancellation));
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], usageMetadataFromMldev(fromUsageMetadata));
    }
    const fromGoAway = getValueByPath(fromObject, ["goAway"]);
    if (fromGoAway != null) {
      setValueByPath(toObject, ["goAway"], liveServerGoAwayFromMldev(fromGoAway));
    }
    const fromSessionResumptionUpdate = getValueByPath(fromObject, [
      "sessionResumptionUpdate"
    ]);
    if (fromSessionResumptionUpdate != null) {
      setValueByPath(toObject, ["sessionResumptionUpdate"], liveServerSessionResumptionUpdateFromMldev(fromSessionResumptionUpdate));
    }
    return toObject;
  }
  function liveServerMessageFromVertex(fromObject) {
    const toObject = {};
    const fromSetupComplete = getValueByPath(fromObject, [
      "setupComplete"
    ]);
    if (fromSetupComplete != null) {
      setValueByPath(toObject, ["setupComplete"], liveServerSetupCompleteFromVertex(fromSetupComplete));
    }
    const fromServerContent = getValueByPath(fromObject, [
      "serverContent"
    ]);
    if (fromServerContent != null) {
      setValueByPath(toObject, ["serverContent"], liveServerContentFromVertex(fromServerContent));
    }
    const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
    if (fromToolCall != null) {
      setValueByPath(toObject, ["toolCall"], liveServerToolCallFromVertex(fromToolCall));
    }
    const fromToolCallCancellation = getValueByPath(fromObject, [
      "toolCallCancellation"
    ]);
    if (fromToolCallCancellation != null) {
      setValueByPath(toObject, ["toolCallCancellation"], liveServerToolCallCancellationFromVertex(fromToolCallCancellation));
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], usageMetadataFromVertex(fromUsageMetadata));
    }
    const fromGoAway = getValueByPath(fromObject, ["goAway"]);
    if (fromGoAway != null) {
      setValueByPath(toObject, ["goAway"], liveServerGoAwayFromVertex(fromGoAway));
    }
    const fromSessionResumptionUpdate = getValueByPath(fromObject, [
      "sessionResumptionUpdate"
    ]);
    if (fromSessionResumptionUpdate != null) {
      setValueByPath(toObject, ["sessionResumptionUpdate"], liveServerSessionResumptionUpdateFromVertex(fromSessionResumptionUpdate));
    }
    return toObject;
  }
  function liveServerSessionResumptionUpdateFromMldev(fromObject) {
    const toObject = {};
    const fromNewHandle = getValueByPath(fromObject, ["newHandle"]);
    if (fromNewHandle != null) {
      setValueByPath(toObject, ["newHandle"], fromNewHandle);
    }
    const fromResumable = getValueByPath(fromObject, ["resumable"]);
    if (fromResumable != null) {
      setValueByPath(toObject, ["resumable"], fromResumable);
    }
    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [
      "lastConsumedClientMessageIndex"
    ]);
    if (fromLastConsumedClientMessageIndex != null) {
      setValueByPath(toObject, ["lastConsumedClientMessageIndex"], fromLastConsumedClientMessageIndex);
    }
    return toObject;
  }
  function liveServerSessionResumptionUpdateFromVertex(fromObject) {
    const toObject = {};
    const fromNewHandle = getValueByPath(fromObject, ["newHandle"]);
    if (fromNewHandle != null) {
      setValueByPath(toObject, ["newHandle"], fromNewHandle);
    }
    const fromResumable = getValueByPath(fromObject, ["resumable"]);
    if (fromResumable != null) {
      setValueByPath(toObject, ["resumable"], fromResumable);
    }
    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [
      "lastConsumedClientMessageIndex"
    ]);
    if (fromLastConsumedClientMessageIndex != null) {
      setValueByPath(toObject, ["lastConsumedClientMessageIndex"], fromLastConsumedClientMessageIndex);
    }
    return toObject;
  }
  function liveServerSetupCompleteFromMldev() {
    const toObject = {};
    return toObject;
  }
  function liveServerSetupCompleteFromVertex(fromObject) {
    const toObject = {};
    const fromSessionId = getValueByPath(fromObject, ["sessionId"]);
    if (fromSessionId != null) {
      setValueByPath(toObject, ["sessionId"], fromSessionId);
    }
    return toObject;
  }
  function liveServerToolCallCancellationFromMldev(fromObject) {
    const toObject = {};
    const fromIds = getValueByPath(fromObject, ["ids"]);
    if (fromIds != null) {
      setValueByPath(toObject, ["ids"], fromIds);
    }
    return toObject;
  }
  function liveServerToolCallCancellationFromVertex(fromObject) {
    const toObject = {};
    const fromIds = getValueByPath(fromObject, ["ids"]);
    if (fromIds != null) {
      setValueByPath(toObject, ["ids"], fromIds);
    }
    return toObject;
  }
  function liveServerToolCallFromMldev(fromObject) {
    const toObject = {};
    const fromFunctionCalls = getValueByPath(fromObject, [
      "functionCalls"
    ]);
    if (fromFunctionCalls != null) {
      let transformedList = fromFunctionCalls;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionCallFromMldev$1(item);
        });
      }
      setValueByPath(toObject, ["functionCalls"], transformedList);
    }
    return toObject;
  }
  function liveServerToolCallFromVertex(fromObject) {
    const toObject = {};
    const fromFunctionCalls = getValueByPath(fromObject, [
      "functionCalls"
    ]);
    if (fromFunctionCalls != null) {
      let transformedList = fromFunctionCalls;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionCallFromVertex$1(item);
        });
      }
      setValueByPath(toObject, ["functionCalls"], transformedList);
    }
    return toObject;
  }
  function modalityTokenCountFromMldev(fromObject) {
    const toObject = {};
    const fromModality = getValueByPath(fromObject, ["modality"]);
    if (fromModality != null) {
      setValueByPath(toObject, ["modality"], fromModality);
    }
    const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    return toObject;
  }
  function modalityTokenCountFromVertex(fromObject) {
    const toObject = {};
    const fromModality = getValueByPath(fromObject, ["modality"]);
    if (fromModality != null) {
      setValueByPath(toObject, ["modality"], fromModality);
    }
    const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    return toObject;
  }
  function multiSpeakerVoiceConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
      "speakerVoiceConfigs"
    ]);
    if (fromSpeakerVoiceConfigs != null) {
      let transformedList = fromSpeakerVoiceConfigs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return speakerVoiceConfigToMldev$2(item);
        });
      }
      setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
    }
    return toObject;
  }
  function partFromMldev$1(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataFromMldev$1(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobFromMldev$1(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataFromMldev$1(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallFromMldev$1(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function partFromVertex$1(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataFromVertex$1(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobFromVertex$1(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataFromVertex$1(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallFromVertex$1(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function partToMldev$2(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$2(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$2(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$2(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev$2(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function partToVertex$1(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToVertex$1(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToVertex$1(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToVertex$1(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToVertex$1(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function prebuiltVoiceConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
    if (fromVoiceName != null) {
      setValueByPath(toObject, ["voiceName"], fromVoiceName);
    }
    return toObject;
  }
  function prebuiltVoiceConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
    if (fromVoiceName != null) {
      setValueByPath(toObject, ["voiceName"], fromVoiceName);
    }
    return toObject;
  }
  function proactivityConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromProactiveAudio = getValueByPath(fromObject, [
      "proactiveAudio"
    ]);
    if (fromProactiveAudio != null) {
      setValueByPath(toObject, ["proactiveAudio"], fromProactiveAudio);
    }
    return toObject;
  }
  function proactivityConfigToVertex(fromObject) {
    const toObject = {};
    const fromProactiveAudio = getValueByPath(fromObject, [
      "proactiveAudio"
    ]);
    if (fromProactiveAudio != null) {
      setValueByPath(toObject, ["proactiveAudio"], fromProactiveAudio);
    }
    return toObject;
  }
  function realtimeInputConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromAutomaticActivityDetection = getValueByPath(fromObject, [
      "automaticActivityDetection"
    ]);
    if (fromAutomaticActivityDetection != null) {
      setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToMldev$1(fromAutomaticActivityDetection));
    }
    const fromActivityHandling = getValueByPath(fromObject, [
      "activityHandling"
    ]);
    if (fromActivityHandling != null) {
      setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
    }
    const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
    if (fromTurnCoverage != null) {
      setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
    }
    return toObject;
  }
  function realtimeInputConfigToVertex(fromObject) {
    const toObject = {};
    const fromAutomaticActivityDetection = getValueByPath(fromObject, [
      "automaticActivityDetection"
    ]);
    if (fromAutomaticActivityDetection != null) {
      setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToVertex(fromAutomaticActivityDetection));
    }
    const fromActivityHandling = getValueByPath(fromObject, [
      "activityHandling"
    ]);
    if (fromActivityHandling != null) {
      setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
    }
    const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
    if (fromTurnCoverage != null) {
      setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
    }
    return toObject;
  }
  function sessionResumptionConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromHandle = getValueByPath(fromObject, ["handle"]);
    if (fromHandle != null) {
      setValueByPath(toObject, ["handle"], fromHandle);
    }
    if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
      throw new Error("transparent parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function sessionResumptionConfigToVertex(fromObject) {
    const toObject = {};
    const fromHandle = getValueByPath(fromObject, ["handle"]);
    if (fromHandle != null) {
      setValueByPath(toObject, ["handle"], fromHandle);
    }
    const fromTransparent = getValueByPath(fromObject, ["transparent"]);
    if (fromTransparent != null) {
      setValueByPath(toObject, ["transparent"], fromTransparent);
    }
    return toObject;
  }
  function slidingWindowToMldev$1(fromObject) {
    const toObject = {};
    const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
    if (fromTargetTokens != null) {
      setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
    }
    return toObject;
  }
  function slidingWindowToVertex(fromObject) {
    const toObject = {};
    const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
    if (fromTargetTokens != null) {
      setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
    }
    return toObject;
  }
  function speakerVoiceConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
    if (fromSpeaker != null) {
      setValueByPath(toObject, ["speaker"], fromSpeaker);
    }
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$2(fromVoiceConfig));
    }
    return toObject;
  }
  function speechConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$2(fromVoiceConfig));
    }
    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
      "multiSpeakerVoiceConfig"
    ]);
    if (fromMultiSpeakerVoiceConfig != null) {
      setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev$2(fromMultiSpeakerVoiceConfig));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function speechConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToVertex$1(fromVoiceConfig));
    }
    if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
      throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function toolComputerUseToMldev$2(fromObject) {
    const toObject = {};
    const fromEnvironment = getValueByPath(fromObject, ["environment"]);
    if (fromEnvironment != null) {
      setValueByPath(toObject, ["environment"], fromEnvironment);
    }
    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [
      "excludedPredefinedFunctions"
    ]);
    if (fromExcludedPredefinedFunctions != null) {
      setValueByPath(toObject, ["excludedPredefinedFunctions"], fromExcludedPredefinedFunctions);
    }
    return toObject;
  }
  function toolComputerUseToVertex$1(fromObject) {
    const toObject = {};
    const fromEnvironment = getValueByPath(fromObject, ["environment"]);
    if (fromEnvironment != null) {
      setValueByPath(toObject, ["environment"], fromEnvironment);
    }
    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [
      "excludedPredefinedFunctions"
    ]);
    if (fromExcludedPredefinedFunctions != null) {
      setValueByPath(toObject, ["excludedPredefinedFunctions"], fromExcludedPredefinedFunctions);
    }
    return toObject;
  }
  function toolToMldev$2(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToMldev$2(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$2(fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$2(fromGoogleSearchRetrieval));
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
      throw new Error("googleMaps parameter is not supported in Gemini API.");
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], urlContextToMldev$2());
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], toolComputerUseToMldev$2(fromComputerUse));
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function toolToVertex$1(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToVertex$1(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
    if (fromRetrieval != null) {
      setValueByPath(toObject, ["retrieval"], fromRetrieval);
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToVertex$1(fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex$1(fromGoogleSearchRetrieval));
    }
    const fromEnterpriseWebSearch = getValueByPath(fromObject, [
      "enterpriseWebSearch"
    ]);
    if (fromEnterpriseWebSearch != null) {
      setValueByPath(toObject, ["enterpriseWebSearch"], enterpriseWebSearchToVertex$1(fromEnterpriseWebSearch));
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToVertex$1(fromGoogleMaps));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], urlContextToVertex$1());
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], toolComputerUseToVertex$1(fromComputerUse));
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function transcriptionFromMldev(fromObject) {
    const toObject = {};
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromFinished = getValueByPath(fromObject, ["finished"]);
    if (fromFinished != null) {
      setValueByPath(toObject, ["finished"], fromFinished);
    }
    return toObject;
  }
  function transcriptionFromVertex(fromObject) {
    const toObject = {};
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromFinished = getValueByPath(fromObject, ["finished"]);
    if (fromFinished != null) {
      setValueByPath(toObject, ["finished"], fromFinished);
    }
    return toObject;
  }
  function urlContextMetadataFromMldev$1(fromObject) {
    const toObject = {};
    const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
    if (fromUrlMetadata != null) {
      let transformedList = fromUrlMetadata;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return urlMetadataFromMldev$1(item);
        });
      }
      setValueByPath(toObject, ["urlMetadata"], transformedList);
    }
    return toObject;
  }
  function urlContextToMldev$2() {
    const toObject = {};
    return toObject;
  }
  function urlContextToVertex$1() {
    const toObject = {};
    return toObject;
  }
  function urlMetadataFromMldev$1(fromObject) {
    const toObject = {};
    const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
    if (fromRetrievedUrl != null) {
      setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
    }
    const fromUrlRetrievalStatus = getValueByPath(fromObject, [
      "urlRetrievalStatus"
    ]);
    if (fromUrlRetrievalStatus != null) {
      setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
    }
    return toObject;
  }
  function usageMetadataFromMldev(fromObject) {
    const toObject = {};
    const fromPromptTokenCount = getValueByPath(fromObject, [
      "promptTokenCount"
    ]);
    if (fromPromptTokenCount != null) {
      setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
    }
    const fromCachedContentTokenCount = getValueByPath(fromObject, [
      "cachedContentTokenCount"
    ]);
    if (fromCachedContentTokenCount != null) {
      setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
    }
    const fromResponseTokenCount = getValueByPath(fromObject, [
      "responseTokenCount"
    ]);
    if (fromResponseTokenCount != null) {
      setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
    }
    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
      "toolUsePromptTokenCount"
    ]);
    if (fromToolUsePromptTokenCount != null) {
      setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
    }
    const fromThoughtsTokenCount = getValueByPath(fromObject, [
      "thoughtsTokenCount"
    ]);
    if (fromThoughtsTokenCount != null) {
      setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
    }
    const fromTotalTokenCount = getValueByPath(fromObject, [
      "totalTokenCount"
    ]);
    if (fromTotalTokenCount != null) {
      setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
    }
    const fromPromptTokensDetails = getValueByPath(fromObject, [
      "promptTokensDetails"
    ]);
    if (fromPromptTokensDetails != null) {
      let transformedList = fromPromptTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromMldev(item);
        });
      }
      setValueByPath(toObject, ["promptTokensDetails"], transformedList);
    }
    const fromCacheTokensDetails = getValueByPath(fromObject, [
      "cacheTokensDetails"
    ]);
    if (fromCacheTokensDetails != null) {
      let transformedList = fromCacheTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromMldev(item);
        });
      }
      setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
    }
    const fromResponseTokensDetails = getValueByPath(fromObject, [
      "responseTokensDetails"
    ]);
    if (fromResponseTokensDetails != null) {
      let transformedList = fromResponseTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromMldev(item);
        });
      }
      setValueByPath(toObject, ["responseTokensDetails"], transformedList);
    }
    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
      "toolUsePromptTokensDetails"
    ]);
    if (fromToolUsePromptTokensDetails != null) {
      let transformedList = fromToolUsePromptTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromMldev(item);
        });
      }
      setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
    }
    return toObject;
  }
  function usageMetadataFromVertex(fromObject) {
    const toObject = {};
    const fromPromptTokenCount = getValueByPath(fromObject, [
      "promptTokenCount"
    ]);
    if (fromPromptTokenCount != null) {
      setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
    }
    const fromCachedContentTokenCount = getValueByPath(fromObject, [
      "cachedContentTokenCount"
    ]);
    if (fromCachedContentTokenCount != null) {
      setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
    }
    const fromResponseTokenCount = getValueByPath(fromObject, [
      "candidatesTokenCount"
    ]);
    if (fromResponseTokenCount != null) {
      setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
    }
    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
      "toolUsePromptTokenCount"
    ]);
    if (fromToolUsePromptTokenCount != null) {
      setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
    }
    const fromThoughtsTokenCount = getValueByPath(fromObject, [
      "thoughtsTokenCount"
    ]);
    if (fromThoughtsTokenCount != null) {
      setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
    }
    const fromTotalTokenCount = getValueByPath(fromObject, [
      "totalTokenCount"
    ]);
    if (fromTotalTokenCount != null) {
      setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
    }
    const fromPromptTokensDetails = getValueByPath(fromObject, [
      "promptTokensDetails"
    ]);
    if (fromPromptTokensDetails != null) {
      let transformedList = fromPromptTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromVertex(item);
        });
      }
      setValueByPath(toObject, ["promptTokensDetails"], transformedList);
    }
    const fromCacheTokensDetails = getValueByPath(fromObject, [
      "cacheTokensDetails"
    ]);
    if (fromCacheTokensDetails != null) {
      let transformedList = fromCacheTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromVertex(item);
        });
      }
      setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
    }
    const fromResponseTokensDetails = getValueByPath(fromObject, [
      "candidatesTokensDetails"
    ]);
    if (fromResponseTokensDetails != null) {
      let transformedList = fromResponseTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromVertex(item);
        });
      }
      setValueByPath(toObject, ["responseTokensDetails"], transformedList);
    }
    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
      "toolUsePromptTokensDetails"
    ]);
    if (fromToolUsePromptTokensDetails != null) {
      let transformedList = fromToolUsePromptTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modalityTokenCountFromVertex(item);
        });
      }
      setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
    }
    const fromTrafficType = getValueByPath(fromObject, ["trafficType"]);
    if (fromTrafficType != null) {
      setValueByPath(toObject, ["trafficType"], fromTrafficType);
    }
    return toObject;
  }
  function videoMetadataFromMldev$1(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function videoMetadataFromVertex$1(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function videoMetadataToMldev$2(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function videoMetadataToVertex$1(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function voiceConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
      "prebuiltVoiceConfig"
    ]);
    if (fromPrebuiltVoiceConfig != null) {
      setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev$2(fromPrebuiltVoiceConfig));
    }
    return toObject;
  }
  function voiceConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
      "prebuiltVoiceConfig"
    ]);
    if (fromPrebuiltVoiceConfig != null) {
      setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToVertex$1(fromPrebuiltVoiceConfig));
    }
    return toObject;
  }
  function weightedPromptFromMldev(fromObject) {
    const toObject = {};
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromWeight = getValueByPath(fromObject, ["weight"]);
    if (fromWeight != null) {
      setValueByPath(toObject, ["weight"], fromWeight);
    }
    return toObject;
  }
  function weightedPromptToMldev(fromObject) {
    const toObject = {};
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromWeight = getValueByPath(fromObject, ["weight"]);
    if (fromWeight != null) {
      setValueByPath(toObject, ["weight"], fromWeight);
    }
    return toObject;
  }
  function apiKeyConfigToVertex(fromObject) {
    const toObject = {};
    const fromApiKeyString = getValueByPath(fromObject, ["apiKeyString"]);
    if (fromApiKeyString != null) {
      setValueByPath(toObject, ["apiKeyString"], fromApiKeyString);
    }
    return toObject;
  }
  function authConfigToVertex(fromObject) {
    const toObject = {};
    const fromApiKeyConfig = getValueByPath(fromObject, ["apiKeyConfig"]);
    if (fromApiKeyConfig != null) {
      setValueByPath(toObject, ["apiKeyConfig"], apiKeyConfigToVertex(fromApiKeyConfig));
    }
    const fromAuthType = getValueByPath(fromObject, ["authType"]);
    if (fromAuthType != null) {
      setValueByPath(toObject, ["authType"], fromAuthType);
    }
    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [
      "googleServiceAccountConfig"
    ]);
    if (fromGoogleServiceAccountConfig != null) {
      setValueByPath(toObject, ["googleServiceAccountConfig"], fromGoogleServiceAccountConfig);
    }
    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [
      "httpBasicAuthConfig"
    ]);
    if (fromHttpBasicAuthConfig != null) {
      setValueByPath(toObject, ["httpBasicAuthConfig"], fromHttpBasicAuthConfig);
    }
    const fromOauthConfig = getValueByPath(fromObject, ["oauthConfig"]);
    if (fromOauthConfig != null) {
      setValueByPath(toObject, ["oauthConfig"], fromOauthConfig);
    }
    const fromOidcConfig = getValueByPath(fromObject, ["oidcConfig"]);
    if (fromOidcConfig != null) {
      setValueByPath(toObject, ["oidcConfig"], fromOidcConfig);
    }
    return toObject;
  }
  function blobFromMldev(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function blobFromVertex(fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function blobToMldev$1(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function blobToVertex(fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function candidateFromMldev(fromObject) {
    const toObject = {};
    const fromContent = getValueByPath(fromObject, ["content"]);
    if (fromContent != null) {
      setValueByPath(toObject, ["content"], contentFromMldev(fromContent));
    }
    const fromCitationMetadata = getValueByPath(fromObject, [
      "citationMetadata"
    ]);
    if (fromCitationMetadata != null) {
      setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev(fromCitationMetadata));
    }
    const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
    if (fromFinishReason != null) {
      setValueByPath(toObject, ["finishReason"], fromFinishReason);
    }
    const fromUrlContextMetadata = getValueByPath(fromObject, [
      "urlContextMetadata"
    ]);
    if (fromUrlContextMetadata != null) {
      setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromMldev(fromUrlContextMetadata));
    }
    const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
    if (fromAvgLogprobs != null) {
      setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromIndex = getValueByPath(fromObject, ["index"]);
    if (fromIndex != null) {
      setValueByPath(toObject, ["index"], fromIndex);
    }
    const fromLogprobsResult = getValueByPath(fromObject, [
      "logprobsResult"
    ]);
    if (fromLogprobsResult != null) {
      setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
    }
    const fromSafetyRatings = getValueByPath(fromObject, [
      "safetyRatings"
    ]);
    if (fromSafetyRatings != null) {
      setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
    }
    return toObject;
  }
  function candidateFromVertex(fromObject) {
    const toObject = {};
    const fromContent = getValueByPath(fromObject, ["content"]);
    if (fromContent != null) {
      setValueByPath(toObject, ["content"], contentFromVertex(fromContent));
    }
    const fromCitationMetadata = getValueByPath(fromObject, [
      "citationMetadata"
    ]);
    if (fromCitationMetadata != null) {
      setValueByPath(toObject, ["citationMetadata"], citationMetadataFromVertex(fromCitationMetadata));
    }
    const fromFinishMessage = getValueByPath(fromObject, [
      "finishMessage"
    ]);
    if (fromFinishMessage != null) {
      setValueByPath(toObject, ["finishMessage"], fromFinishMessage);
    }
    const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
    if (fromFinishReason != null) {
      setValueByPath(toObject, ["finishReason"], fromFinishReason);
    }
    const fromUrlContextMetadata = getValueByPath(fromObject, [
      "urlContextMetadata"
    ]);
    if (fromUrlContextMetadata != null) {
      setValueByPath(toObject, ["urlContextMetadata"], urlContextMetadataFromVertex(fromUrlContextMetadata));
    }
    const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
    if (fromAvgLogprobs != null) {
      setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromIndex = getValueByPath(fromObject, ["index"]);
    if (fromIndex != null) {
      setValueByPath(toObject, ["index"], fromIndex);
    }
    const fromLogprobsResult = getValueByPath(fromObject, [
      "logprobsResult"
    ]);
    if (fromLogprobsResult != null) {
      setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
    }
    const fromSafetyRatings = getValueByPath(fromObject, [
      "safetyRatings"
    ]);
    if (fromSafetyRatings != null) {
      setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
    }
    return toObject;
  }
  function checkpointFromVertex(fromObject) {
    const toObject = {};
    const fromCheckpointId = getValueByPath(fromObject, ["checkpointId"]);
    if (fromCheckpointId != null) {
      setValueByPath(toObject, ["checkpointId"], fromCheckpointId);
    }
    const fromEpoch = getValueByPath(fromObject, ["epoch"]);
    if (fromEpoch != null) {
      setValueByPath(toObject, ["epoch"], fromEpoch);
    }
    const fromStep = getValueByPath(fromObject, ["step"]);
    if (fromStep != null) {
      setValueByPath(toObject, ["step"], fromStep);
    }
    return toObject;
  }
  function citationMetadataFromMldev(fromObject) {
    const toObject = {};
    const fromCitations = getValueByPath(fromObject, ["citationSources"]);
    if (fromCitations != null) {
      setValueByPath(toObject, ["citations"], fromCitations);
    }
    return toObject;
  }
  function citationMetadataFromVertex(fromObject) {
    const toObject = {};
    const fromCitations = getValueByPath(fromObject, ["citations"]);
    if (fromCitations != null) {
      setValueByPath(toObject, ["citations"], fromCitations);
    }
    return toObject;
  }
  function computeTokensParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToVertex(item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    return toObject;
  }
  function computeTokensResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromTokensInfo = getValueByPath(fromObject, ["tokensInfo"]);
    if (fromTokensInfo != null) {
      setValueByPath(toObject, ["tokensInfo"], fromTokensInfo);
    }
    return toObject;
  }
  function contentEmbeddingFromMldev(fromObject) {
    const toObject = {};
    const fromValues = getValueByPath(fromObject, ["values"]);
    if (fromValues != null) {
      setValueByPath(toObject, ["values"], fromValues);
    }
    return toObject;
  }
  function contentEmbeddingFromVertex(fromObject) {
    const toObject = {};
    const fromValues = getValueByPath(fromObject, ["values"]);
    if (fromValues != null) {
      setValueByPath(toObject, ["values"], fromValues);
    }
    const fromStatistics = getValueByPath(fromObject, ["statistics"]);
    if (fromStatistics != null) {
      setValueByPath(toObject, ["statistics"], contentEmbeddingStatisticsFromVertex(fromStatistics));
    }
    return toObject;
  }
  function contentEmbeddingStatisticsFromVertex(fromObject) {
    const toObject = {};
    const fromTruncated = getValueByPath(fromObject, ["truncated"]);
    if (fromTruncated != null) {
      setValueByPath(toObject, ["truncated"], fromTruncated);
    }
    const fromTokenCount = getValueByPath(fromObject, ["token_count"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    return toObject;
  }
  function contentFromMldev(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partFromMldev(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function contentFromVertex(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partFromVertex(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function contentToMldev$1(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$1(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function contentToVertex(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToVertex(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function controlReferenceConfigToVertex(fromObject) {
    const toObject = {};
    const fromControlType = getValueByPath(fromObject, ["controlType"]);
    if (fromControlType != null) {
      setValueByPath(toObject, ["controlType"], fromControlType);
    }
    const fromEnableControlImageComputation = getValueByPath(fromObject, [
      "enableControlImageComputation"
    ]);
    if (fromEnableControlImageComputation != null) {
      setValueByPath(toObject, ["computeControl"], fromEnableControlImageComputation);
    }
    return toObject;
  }
  function countTokensConfigToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["systemInstruction"]) !== void 0) {
      throw new Error("systemInstruction parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["tools"]) !== void 0) {
      throw new Error("tools parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["generationConfig"]) !== void 0) {
      throw new Error("generationConfig parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function countTokensConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToVertex(tContent(fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = fromTools;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex(item);
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["generationConfig"], fromGenerationConfig);
    }
    return toObject;
  }
  function countTokensParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$1(item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      countTokensConfigToMldev(fromConfig);
    }
    return toObject;
  }
  function countTokensParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToVertex(item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      countTokensConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function countTokensResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
    if (fromTotalTokens != null) {
      setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
    }
    const fromCachedContentTokenCount = getValueByPath(fromObject, [
      "cachedContentTokenCount"
    ]);
    if (fromCachedContentTokenCount != null) {
      setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
    }
    return toObject;
  }
  function countTokensResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
    if (fromTotalTokens != null) {
      setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
    }
    return toObject;
  }
  function deleteModelParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    return toObject;
  }
  function deleteModelParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    return toObject;
  }
  function deleteModelResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function deleteModelResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function dynamicRetrievalConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function dynamicRetrievalConfigToVertex(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function editImageConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromGuidanceScale = getValueByPath(fromObject, [
      "guidanceScale"
    ]);
    if (parentObject !== void 0 && fromGuidanceScale != null) {
      setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
      "includeSafetyAttributes"
    ]);
    if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
      setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromLanguage = getValueByPath(fromObject, ["language"]);
    if (parentObject !== void 0 && fromLanguage != null) {
      setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
    if (parentObject !== void 0 && fromAddWatermark != null) {
      setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
    }
    const fromEditMode = getValueByPath(fromObject, ["editMode"]);
    if (parentObject !== void 0 && fromEditMode != null) {
      setValueByPath(parentObject, ["parameters", "editMode"], fromEditMode);
    }
    const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
    if (parentObject !== void 0 && fromBaseSteps != null) {
      setValueByPath(parentObject, ["parameters", "editConfig", "baseSteps"], fromBaseSteps);
    }
    return toObject;
  }
  function editImageParametersInternalToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromReferenceImages = getValueByPath(fromObject, [
      "referenceImages"
    ]);
    if (fromReferenceImages != null) {
      let transformedList = fromReferenceImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return referenceImageAPIInternalToVertex(item);
        });
      }
      setValueByPath(toObject, ["instances[0]", "referenceImages"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      editImageConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function editImageResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    return toObject;
  }
  function embedContentConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromTaskType = getValueByPath(fromObject, ["taskType"]);
    if (parentObject !== void 0 && fromTaskType != null) {
      setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (parentObject !== void 0 && fromTitle != null) {
      setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
    }
    const fromOutputDimensionality = getValueByPath(fromObject, [
      "outputDimensionality"
    ]);
    if (parentObject !== void 0 && fromOutputDimensionality != null) {
      setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
    }
    if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
      throw new Error("mimeType parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
      throw new Error("autoTruncate parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function embedContentConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromTaskType = getValueByPath(fromObject, ["taskType"]);
    if (parentObject !== void 0 && fromTaskType != null) {
      setValueByPath(parentObject, ["instances[]", "task_type"], fromTaskType);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (parentObject !== void 0 && fromTitle != null) {
      setValueByPath(parentObject, ["instances[]", "title"], fromTitle);
    }
    const fromOutputDimensionality = getValueByPath(fromObject, [
      "outputDimensionality"
    ]);
    if (parentObject !== void 0 && fromOutputDimensionality != null) {
      setValueByPath(parentObject, ["parameters", "outputDimensionality"], fromOutputDimensionality);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (parentObject !== void 0 && fromMimeType != null) {
      setValueByPath(parentObject, ["instances[]", "mimeType"], fromMimeType);
    }
    const fromAutoTruncate = getValueByPath(fromObject, ["autoTruncate"]);
    if (parentObject !== void 0 && fromAutoTruncate != null) {
      setValueByPath(parentObject, ["parameters", "autoTruncate"], fromAutoTruncate);
    }
    return toObject;
  }
  function embedContentMetadataFromMldev() {
    const toObject = {};
    return toObject;
  }
  function embedContentMetadataFromVertex(fromObject) {
    const toObject = {};
    const fromBillableCharacterCount = getValueByPath(fromObject, [
      "billableCharacterCount"
    ]);
    if (fromBillableCharacterCount != null) {
      setValueByPath(toObject, ["billableCharacterCount"], fromBillableCharacterCount);
    }
    return toObject;
  }
  function embedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      setValueByPath(toObject, ["requests[]", "content"], tContentsForEmbed(apiClient, fromContents));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      embedContentConfigToMldev(fromConfig, toObject);
    }
    const fromModelForEmbedContent = getValueByPath(fromObject, ["model"]);
    if (fromModelForEmbedContent !== void 0) {
      setValueByPath(toObject, ["requests[]", "model"], tModel(apiClient, fromModelForEmbedContent));
    }
    return toObject;
  }
  function embedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      setValueByPath(toObject, ["instances[]", "content"], tContentsForEmbed(apiClient, fromContents));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      embedContentConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function embedContentResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromEmbeddings = getValueByPath(fromObject, ["embeddings"]);
    if (fromEmbeddings != null) {
      let transformedList = fromEmbeddings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentEmbeddingFromMldev(item);
        });
      }
      setValueByPath(toObject, ["embeddings"], transformedList);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], embedContentMetadataFromMldev());
    }
    return toObject;
  }
  function embedContentResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromEmbeddings = getValueByPath(fromObject, [
      "predictions[]",
      "embeddings"
    ]);
    if (fromEmbeddings != null) {
      let transformedList = fromEmbeddings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentEmbeddingFromVertex(item);
        });
      }
      setValueByPath(toObject, ["embeddings"], transformedList);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], embedContentMetadataFromVertex(fromMetadata));
    }
    return toObject;
  }
  function endpointFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["endpoint"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDeployedModelId = getValueByPath(fromObject, [
      "deployedModelId"
    ]);
    if (fromDeployedModelId != null) {
      setValueByPath(toObject, ["deployedModelId"], fromDeployedModelId);
    }
    return toObject;
  }
  function enterpriseWebSearchToVertex(fromObject) {
    const toObject = {};
    const fromExcludeDomains = getValueByPath(fromObject, [
      "excludeDomains"
    ]);
    if (fromExcludeDomains != null) {
      setValueByPath(toObject, ["excludeDomains"], fromExcludeDomains);
    }
    return toObject;
  }
  function entityLabelFromVertex(fromObject) {
    const toObject = {};
    const fromLabel = getValueByPath(fromObject, ["label"]);
    if (fromLabel != null) {
      setValueByPath(toObject, ["label"], fromLabel);
    }
    const fromScore = getValueByPath(fromObject, ["score"]);
    if (fromScore != null) {
      setValueByPath(toObject, ["score"], fromScore);
    }
    return toObject;
  }
  function fileDataFromMldev(fromObject) {
    const toObject = {};
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataFromVertex(fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataToMldev$1(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function fileDataToVertex(fromObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallFromMldev(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionCallFromVertex(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionCallToMldev$1(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionCallToVertex(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionCallingConfigToMldev(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    return toObject;
  }
  function functionCallingConfigToVertex(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    return toObject;
  }
  function functionDeclarationToMldev$1(fromObject) {
    const toObject = {};
    const fromBehavior = getValueByPath(fromObject, ["behavior"]);
    if (fromBehavior != null) {
      setValueByPath(toObject, ["behavior"], fromBehavior);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function functionDeclarationToVertex(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
      throw new Error("behavior parameter is not supported in Vertex AI.");
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function generateContentConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToMldev$1(tContent(fromSystemInstruction)));
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], schemaToMldev(tSchema(fromResponseSchema)));
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
      throw new Error("routingConfig parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
      throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
    }
    const fromSafetySettings = getValueByPath(fromObject, [
      "safetySettings"
    ]);
    if (parentObject !== void 0 && fromSafetySettings != null) {
      let transformedList = fromSafetySettings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return safetySettingToMldev(item);
        });
      }
      setValueByPath(parentObject, ["safetySettings"], transformedList);
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$1(tTool(item));
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev(fromToolConfig));
    }
    if (getValueByPath(fromObject, ["labels"]) !== void 0) {
      throw new Error("labels parameter is not supported in Gemini API.");
    }
    const fromCachedContent = getValueByPath(fromObject, [
      "cachedContent"
    ]);
    if (parentObject !== void 0 && fromCachedContent != null) {
      setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], speechConfigToMldev$1(tSpeechConfig(fromSpeechConfig)));
    }
    if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
      throw new Error("audioTimestamp parameter is not supported in Gemini API.");
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToMldev(fromThinkingConfig));
    }
    return toObject;
  }
  function generateContentConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToVertex(tContent(fromSystemInstruction)));
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], schemaToVertex(tSchema(fromResponseSchema)));
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    const fromRoutingConfig = getValueByPath(fromObject, [
      "routingConfig"
    ]);
    if (fromRoutingConfig != null) {
      setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
    }
    const fromModelSelectionConfig = getValueByPath(fromObject, [
      "modelSelectionConfig"
    ]);
    if (fromModelSelectionConfig != null) {
      setValueByPath(toObject, ["modelConfig"], modelSelectionConfigToVertex(fromModelSelectionConfig));
    }
    const fromSafetySettings = getValueByPath(fromObject, [
      "safetySettings"
    ]);
    if (parentObject !== void 0 && fromSafetySettings != null) {
      let transformedList = fromSafetySettings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return safetySettingToVertex(item);
        });
      }
      setValueByPath(parentObject, ["safetySettings"], transformedList);
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex(tTool(item));
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToVertex(fromToolConfig));
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    const fromCachedContent = getValueByPath(fromObject, [
      "cachedContent"
    ]);
    if (parentObject !== void 0 && fromCachedContent != null) {
      setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));
    }
    const fromAudioTimestamp = getValueByPath(fromObject, [
      "audioTimestamp"
    ]);
    if (fromAudioTimestamp != null) {
      setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToVertex(fromThinkingConfig));
    }
    return toObject;
  }
  function generateContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$1(item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["generationConfig"], generateContentConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function generateContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToVertex(item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["generationConfig"], generateContentConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function generateContentResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromCandidates = getValueByPath(fromObject, ["candidates"]);
    if (fromCandidates != null) {
      let transformedList = fromCandidates;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return candidateFromMldev(item);
        });
      }
      setValueByPath(toObject, ["candidates"], transformedList);
    }
    const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
    if (fromModelVersion != null) {
      setValueByPath(toObject, ["modelVersion"], fromModelVersion);
    }
    const fromPromptFeedback = getValueByPath(fromObject, [
      "promptFeedback"
    ]);
    if (fromPromptFeedback != null) {
      setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
    }
    const fromResponseId = getValueByPath(fromObject, ["responseId"]);
    if (fromResponseId != null) {
      setValueByPath(toObject, ["responseId"], fromResponseId);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function generateContentResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromCandidates = getValueByPath(fromObject, ["candidates"]);
    if (fromCandidates != null) {
      let transformedList = fromCandidates;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return candidateFromVertex(item);
        });
      }
      setValueByPath(toObject, ["candidates"], transformedList);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
    if (fromModelVersion != null) {
      setValueByPath(toObject, ["modelVersion"], fromModelVersion);
    }
    const fromPromptFeedback = getValueByPath(fromObject, [
      "promptFeedback"
    ]);
    if (fromPromptFeedback != null) {
      setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
    }
    const fromResponseId = getValueByPath(fromObject, ["responseId"]);
    if (fromResponseId != null) {
      setValueByPath(toObject, ["responseId"], fromResponseId);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function generateImagesConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
      throw new Error("outputGcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["negativePrompt"]) !== void 0) {
      throw new Error("negativePrompt parameter is not supported in Gemini API.");
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromGuidanceScale = getValueByPath(fromObject, [
      "guidanceScale"
    ]);
    if (parentObject !== void 0 && fromGuidanceScale != null) {
      setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
    }
    if (getValueByPath(fromObject, ["seed"]) !== void 0) {
      throw new Error("seed parameter is not supported in Gemini API.");
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
      "includeSafetyAttributes"
    ]);
    if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
      setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromLanguage = getValueByPath(fromObject, ["language"]);
    if (parentObject !== void 0 && fromLanguage != null) {
      setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    if (getValueByPath(fromObject, ["addWatermark"]) !== void 0) {
      throw new Error("addWatermark parameter is not supported in Gemini API.");
    }
    const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
    if (parentObject !== void 0 && fromImageSize != null) {
      setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
    }
    if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) {
      throw new Error("enhancePrompt parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function generateImagesConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromGuidanceScale = getValueByPath(fromObject, [
      "guidanceScale"
    ]);
    if (parentObject !== void 0 && fromGuidanceScale != null) {
      setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
      "includeSafetyAttributes"
    ]);
    if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
      setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromLanguage = getValueByPath(fromObject, ["language"]);
    if (parentObject !== void 0 && fromLanguage != null) {
      setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
    if (parentObject !== void 0 && fromAddWatermark != null) {
      setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
    }
    const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
    if (parentObject !== void 0 && fromImageSize != null) {
      setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    return toObject;
  }
  function generateImagesParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      generateImagesConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function generateImagesParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      generateImagesConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function generateImagesResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromMldev(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
      "positivePromptSafetyAttributes"
    ]);
    if (fromPositivePromptSafetyAttributes != null) {
      setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));
    }
    return toObject;
  }
  function generateImagesResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
      "positivePromptSafetyAttributes"
    ]);
    if (fromPositivePromptSafetyAttributes != null) {
      setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));
    }
    return toObject;
  }
  function generateVideosConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromNumberOfVideos = getValueByPath(fromObject, [
      "numberOfVideos"
    ]);
    if (parentObject !== void 0 && fromNumberOfVideos != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
    }
    if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
      throw new Error("outputGcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["fps"]) !== void 0) {
      throw new Error("fps parameter is not supported in Gemini API.");
    }
    const fromDurationSeconds = getValueByPath(fromObject, [
      "durationSeconds"
    ]);
    if (parentObject !== void 0 && fromDurationSeconds != null) {
      setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
    }
    if (getValueByPath(fromObject, ["seed"]) !== void 0) {
      throw new Error("seed parameter is not supported in Gemini API.");
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromResolution = getValueByPath(fromObject, ["resolution"]);
    if (parentObject !== void 0 && fromResolution != null) {
      setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    if (getValueByPath(fromObject, ["pubsubTopic"]) !== void 0) {
      throw new Error("pubsubTopic parameter is not supported in Gemini API.");
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    if (getValueByPath(fromObject, ["generateAudio"]) !== void 0) {
      throw new Error("generateAudio parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["lastFrame"]) !== void 0) {
      throw new Error("lastFrame parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["referenceImages"]) !== void 0) {
      throw new Error("referenceImages parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["mask"]) !== void 0) {
      throw new Error("mask parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["compressionQuality"]) !== void 0) {
      throw new Error("compressionQuality parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function generateVideosConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromNumberOfVideos = getValueByPath(fromObject, [
      "numberOfVideos"
    ]);
    if (parentObject !== void 0 && fromNumberOfVideos != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
    }
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (parentObject !== void 0 && fromFps != null) {
      setValueByPath(parentObject, ["parameters", "fps"], fromFps);
    }
    const fromDurationSeconds = getValueByPath(fromObject, [
      "durationSeconds"
    ]);
    if (parentObject !== void 0 && fromDurationSeconds != null) {
      setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromResolution = getValueByPath(fromObject, ["resolution"]);
    if (parentObject !== void 0 && fromResolution != null) {
      setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromPubsubTopic = getValueByPath(fromObject, ["pubsubTopic"]);
    if (parentObject !== void 0 && fromPubsubTopic != null) {
      setValueByPath(parentObject, ["parameters", "pubsubTopic"], fromPubsubTopic);
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    const fromGenerateAudio = getValueByPath(fromObject, [
      "generateAudio"
    ]);
    if (parentObject !== void 0 && fromGenerateAudio != null) {
      setValueByPath(parentObject, ["parameters", "generateAudio"], fromGenerateAudio);
    }
    const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
    if (parentObject !== void 0 && fromLastFrame != null) {
      setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToVertex(fromLastFrame));
    }
    const fromReferenceImages = getValueByPath(fromObject, [
      "referenceImages"
    ]);
    if (parentObject !== void 0 && fromReferenceImages != null) {
      let transformedList = fromReferenceImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return videoGenerationReferenceImageToVertex(item);
        });
      }
      setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
    }
    const fromMask = getValueByPath(fromObject, ["mask"]);
    if (parentObject !== void 0 && fromMask != null) {
      setValueByPath(parentObject, ["instances[0]", "mask"], videoGenerationMaskToVertex(fromMask));
    }
    const fromCompressionQuality = getValueByPath(fromObject, [
      "compressionQuality"
    ]);
    if (parentObject !== void 0 && fromCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "compressionQuality"], fromCompressionQuality);
    }
    return toObject;
  }
  function generateVideosOperationFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, [
      "response",
      "generateVideoResponse"
    ]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromMldev(fromResponse));
    }
    return toObject;
  }
  function generateVideosOperationFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromVertex(fromResponse));
    }
    return toObject;
  }
  function generateVideosParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["instances[0]", "image"], imageToMldev(fromImage));
    }
    if (getValueByPath(fromObject, ["video"]) !== void 0) {
      throw new Error("video parameter is not supported in Gemini API.");
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      generateVideosSourceToMldev(fromSource, toObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      generateVideosConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function generateVideosParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["instances[0]", "video"], videoToVertex(fromVideo));
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      generateVideosSourceToVertex(fromSource, toObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      generateVideosConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function generateVideosResponseFromMldev(fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, [
      "generatedSamples"
    ]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromMldev(item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosResponseFromVertex(fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosSourceToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (parentObject !== void 0 && fromPrompt != null) {
      setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (parentObject !== void 0 && fromImage != null) {
      setValueByPath(parentObject, ["instances[0]", "image"], imageToMldev(fromImage));
    }
    if (getValueByPath(fromObject, ["video"]) !== void 0) {
      throw new Error("video parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function generateVideosSourceToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (parentObject !== void 0 && fromPrompt != null) {
      setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (parentObject !== void 0 && fromImage != null) {
      setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (parentObject !== void 0 && fromVideo != null) {
      setValueByPath(parentObject, ["instances[0]", "video"], videoToVertex(fromVideo));
    }
    return toObject;
  }
  function generatedImageFromMldev(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["_self"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageFromMldev(fromImage));
    }
    const fromRaiFilteredReason = getValueByPath(fromObject, [
      "raiFilteredReason"
    ]);
    if (fromRaiFilteredReason != null) {
      setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
    }
    const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
    if (fromSafetyAttributes != null) {
      setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromMldev(fromSafetyAttributes));
    }
    return toObject;
  }
  function generatedImageFromVertex(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["_self"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageFromVertex(fromImage));
    }
    const fromRaiFilteredReason = getValueByPath(fromObject, [
      "raiFilteredReason"
    ]);
    if (fromRaiFilteredReason != null) {
      setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
    }
    const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
    if (fromSafetyAttributes != null) {
      setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromVertex(fromSafetyAttributes));
    }
    const fromEnhancedPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromEnhancedPrompt != null) {
      setValueByPath(toObject, ["enhancedPrompt"], fromEnhancedPrompt);
    }
    return toObject;
  }
  function generatedImageMaskFromVertex(fromObject) {
    const toObject = {};
    const fromMask = getValueByPath(fromObject, ["_self"]);
    if (fromMask != null) {
      setValueByPath(toObject, ["mask"], imageFromVertex(fromMask));
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      let transformedList = fromLabels;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return entityLabelFromVertex(item);
        });
      }
      setValueByPath(toObject, ["labels"], transformedList);
    }
    return toObject;
  }
  function generatedVideoFromMldev(fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["_self"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromMldev(fromVideo));
    }
    return toObject;
  }
  function generatedVideoFromVertex(fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["_self"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromVertex(fromVideo));
    }
    return toObject;
  }
  function getModelParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    return toObject;
  }
  function getModelParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    return toObject;
  }
  function googleMapsToVertex(fromObject) {
    const toObject = {};
    const fromAuthConfig = getValueByPath(fromObject, ["authConfig"]);
    if (fromAuthConfig != null) {
      setValueByPath(toObject, ["authConfig"], authConfigToVertex(fromAuthConfig));
    }
    return toObject;
  }
  function googleSearchRetrievalToMldev$1(fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$1(fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function googleSearchRetrievalToVertex(fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex(fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function googleSearchToMldev$1(fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev$1(fromTimeRangeFilter));
    }
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function googleSearchToVertex(fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToVertex(fromTimeRangeFilter));
    }
    const fromExcludeDomains = getValueByPath(fromObject, [
      "excludeDomains"
    ]);
    if (fromExcludeDomains != null) {
      setValueByPath(toObject, ["excludeDomains"], fromExcludeDomains);
    }
    return toObject;
  }
  function imageFromMldev(fromObject) {
    const toObject = {};
    const fromImageBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function imageFromVertex(fromObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromImageBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function imageToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
      throw new Error("gcsUri parameter is not supported in Gemini API.");
    }
    const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function imageToVertex(fromObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function intervalToMldev$1(fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function intervalToVertex(fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function latLngToMldev(fromObject) {
    const toObject = {};
    const fromLatitude = getValueByPath(fromObject, ["latitude"]);
    if (fromLatitude != null) {
      setValueByPath(toObject, ["latitude"], fromLatitude);
    }
    const fromLongitude = getValueByPath(fromObject, ["longitude"]);
    if (fromLongitude != null) {
      setValueByPath(toObject, ["longitude"], fromLongitude);
    }
    return toObject;
  }
  function latLngToVertex(fromObject) {
    const toObject = {};
    const fromLatitude = getValueByPath(fromObject, ["latitude"]);
    if (fromLatitude != null) {
      setValueByPath(toObject, ["latitude"], fromLatitude);
    }
    const fromLongitude = getValueByPath(fromObject, ["longitude"]);
    if (fromLongitude != null) {
      setValueByPath(toObject, ["longitude"], fromLongitude);
    }
    return toObject;
  }
  function listModelsConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
    if (parentObject !== void 0 && fromQueryBase != null) {
      setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
    }
    return toObject;
  }
  function listModelsConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
    if (parentObject !== void 0 && fromQueryBase != null) {
      setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
    }
    return toObject;
  }
  function listModelsParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listModelsConfigToMldev(apiClient, fromConfig, toObject);
    }
    return toObject;
  }
  function listModelsParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listModelsConfigToVertex(apiClient, fromConfig, toObject);
    }
    return toObject;
  }
  function listModelsResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromModels = getValueByPath(fromObject, ["_self"]);
    if (fromModels != null) {
      let transformedList = tExtractModels(fromModels);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modelFromMldev(item);
        });
      }
      setValueByPath(toObject, ["models"], transformedList);
    }
    return toObject;
  }
  function listModelsResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromModels = getValueByPath(fromObject, ["_self"]);
    if (fromModels != null) {
      let transformedList = tExtractModels(fromModels);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modelFromVertex(item);
        });
      }
      setValueByPath(toObject, ["models"], transformedList);
    }
    return toObject;
  }
  function maskReferenceConfigToVertex(fromObject) {
    const toObject = {};
    const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
    if (fromMaskMode != null) {
      setValueByPath(toObject, ["maskMode"], fromMaskMode);
    }
    const fromSegmentationClasses = getValueByPath(fromObject, [
      "segmentationClasses"
    ]);
    if (fromSegmentationClasses != null) {
      setValueByPath(toObject, ["maskClasses"], fromSegmentationClasses);
    }
    const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
    if (fromMaskDilation != null) {
      setValueByPath(toObject, ["dilation"], fromMaskDilation);
    }
    return toObject;
  }
  function modelFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromVersion = getValueByPath(fromObject, ["version"]);
    if (fromVersion != null) {
      setValueByPath(toObject, ["version"], fromVersion);
    }
    const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
    if (fromTunedModelInfo != null) {
      setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromMldev(fromTunedModelInfo));
    }
    const fromInputTokenLimit = getValueByPath(fromObject, [
      "inputTokenLimit"
    ]);
    if (fromInputTokenLimit != null) {
      setValueByPath(toObject, ["inputTokenLimit"], fromInputTokenLimit);
    }
    const fromOutputTokenLimit = getValueByPath(fromObject, [
      "outputTokenLimit"
    ]);
    if (fromOutputTokenLimit != null) {
      setValueByPath(toObject, ["outputTokenLimit"], fromOutputTokenLimit);
    }
    const fromSupportedActions = getValueByPath(fromObject, [
      "supportedGenerationMethods"
    ]);
    if (fromSupportedActions != null) {
      setValueByPath(toObject, ["supportedActions"], fromSupportedActions);
    }
    return toObject;
  }
  function modelFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromVersion = getValueByPath(fromObject, ["versionId"]);
    if (fromVersion != null) {
      setValueByPath(toObject, ["version"], fromVersion);
    }
    const fromEndpoints = getValueByPath(fromObject, ["deployedModels"]);
    if (fromEndpoints != null) {
      let transformedList = fromEndpoints;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return endpointFromVertex(item);
        });
      }
      setValueByPath(toObject, ["endpoints"], transformedList);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      setValueByPath(toObject, ["labels"], fromLabels);
    }
    const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
    if (fromTunedModelInfo != null) {
      setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromVertex(fromTunedModelInfo));
    }
    const fromDefaultCheckpointId = getValueByPath(fromObject, [
      "defaultCheckpointId"
    ]);
    if (fromDefaultCheckpointId != null) {
      setValueByPath(toObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
    }
    const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
    if (fromCheckpoints != null) {
      let transformedList = fromCheckpoints;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return checkpointFromVertex(item);
        });
      }
      setValueByPath(toObject, ["checkpoints"], transformedList);
    }
    return toObject;
  }
  function modelSelectionConfigToVertex(fromObject) {
    const toObject = {};
    const fromFeatureSelectionPreference = getValueByPath(fromObject, [
      "featureSelectionPreference"
    ]);
    if (fromFeatureSelectionPreference != null) {
      setValueByPath(toObject, ["featureSelectionPreference"], fromFeatureSelectionPreference);
    }
    return toObject;
  }
  function multiSpeakerVoiceConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
      "speakerVoiceConfigs"
    ]);
    if (fromSpeakerVoiceConfigs != null) {
      let transformedList = fromSpeakerVoiceConfigs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return speakerVoiceConfigToMldev$1(item);
        });
      }
      setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
    }
    return toObject;
  }
  function partFromMldev(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataFromMldev(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobFromMldev(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataFromMldev(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallFromMldev(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function partFromVertex(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataFromVertex(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobFromVertex(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataFromVertex(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallFromVertex(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function partToMldev$1(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev$1(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$1(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$1(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev$1(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function partToVertex(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToVertex(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToVertex(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToVertex(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToVertex(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function prebuiltVoiceConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
    if (fromVoiceName != null) {
      setValueByPath(toObject, ["voiceName"], fromVoiceName);
    }
    return toObject;
  }
  function prebuiltVoiceConfigToVertex(fromObject) {
    const toObject = {};
    const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
    if (fromVoiceName != null) {
      setValueByPath(toObject, ["voiceName"], fromVoiceName);
    }
    return toObject;
  }
  function productImageToVertex(fromObject) {
    const toObject = {};
    const fromProductImage = getValueByPath(fromObject, ["productImage"]);
    if (fromProductImage != null) {
      setValueByPath(toObject, ["image"], imageToVertex(fromProductImage));
    }
    return toObject;
  }
  function recontextImageConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
    if (parentObject !== void 0 && fromBaseSteps != null) {
      setValueByPath(parentObject, ["parameters", "editConfig", "baseSteps"], fromBaseSteps);
    }
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
    if (parentObject !== void 0 && fromAddWatermark != null) {
      setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    return toObject;
  }
  function recontextImageParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      recontextImageSourceToVertex(fromSource, toObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      recontextImageConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function recontextImageResponseFromVertex(fromObject) {
    const toObject = {};
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    return toObject;
  }
  function recontextImageSourceToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (parentObject !== void 0 && fromPrompt != null) {
      setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromPersonImage = getValueByPath(fromObject, ["personImage"]);
    if (parentObject !== void 0 && fromPersonImage != null) {
      setValueByPath(parentObject, ["instances[0]", "personImage", "image"], imageToVertex(fromPersonImage));
    }
    const fromProductImages = getValueByPath(fromObject, [
      "productImages"
    ]);
    if (parentObject !== void 0 && fromProductImages != null) {
      let transformedList = fromProductImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return productImageToVertex(item);
        });
      }
      setValueByPath(parentObject, ["instances[0]", "productImages"], transformedList);
    }
    return toObject;
  }
  function referenceImageAPIInternalToVertex(fromObject) {
    const toObject = {};
    const fromReferenceImage = getValueByPath(fromObject, [
      "referenceImage"
    ]);
    if (fromReferenceImage != null) {
      setValueByPath(toObject, ["referenceImage"], imageToVertex(fromReferenceImage));
    }
    const fromReferenceId = getValueByPath(fromObject, ["referenceId"]);
    if (fromReferenceId != null) {
      setValueByPath(toObject, ["referenceId"], fromReferenceId);
    }
    const fromReferenceType = getValueByPath(fromObject, [
      "referenceType"
    ]);
    if (fromReferenceType != null) {
      setValueByPath(toObject, ["referenceType"], fromReferenceType);
    }
    const fromMaskImageConfig = getValueByPath(fromObject, [
      "maskImageConfig"
    ]);
    if (fromMaskImageConfig != null) {
      setValueByPath(toObject, ["maskImageConfig"], maskReferenceConfigToVertex(fromMaskImageConfig));
    }
    const fromControlImageConfig = getValueByPath(fromObject, [
      "controlImageConfig"
    ]);
    if (fromControlImageConfig != null) {
      setValueByPath(toObject, ["controlImageConfig"], controlReferenceConfigToVertex(fromControlImageConfig));
    }
    const fromStyleImageConfig = getValueByPath(fromObject, [
      "styleImageConfig"
    ]);
    if (fromStyleImageConfig != null) {
      setValueByPath(toObject, ["styleImageConfig"], styleReferenceConfigToVertex(fromStyleImageConfig));
    }
    const fromSubjectImageConfig = getValueByPath(fromObject, [
      "subjectImageConfig"
    ]);
    if (fromSubjectImageConfig != null) {
      setValueByPath(toObject, ["subjectImageConfig"], subjectReferenceConfigToVertex(fromSubjectImageConfig));
    }
    return toObject;
  }
  function retrievalConfigToMldev(fromObject) {
    const toObject = {};
    const fromLatLng = getValueByPath(fromObject, ["latLng"]);
    if (fromLatLng != null) {
      setValueByPath(toObject, ["latLng"], latLngToMldev(fromLatLng));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function retrievalConfigToVertex(fromObject) {
    const toObject = {};
    const fromLatLng = getValueByPath(fromObject, ["latLng"]);
    if (fromLatLng != null) {
      setValueByPath(toObject, ["latLng"], latLngToVertex(fromLatLng));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function safetyAttributesFromMldev(fromObject) {
    const toObject = {};
    const fromCategories = getValueByPath(fromObject, [
      "safetyAttributes",
      "categories"
    ]);
    if (fromCategories != null) {
      setValueByPath(toObject, ["categories"], fromCategories);
    }
    const fromScores = getValueByPath(fromObject, [
      "safetyAttributes",
      "scores"
    ]);
    if (fromScores != null) {
      setValueByPath(toObject, ["scores"], fromScores);
    }
    const fromContentType = getValueByPath(fromObject, ["contentType"]);
    if (fromContentType != null) {
      setValueByPath(toObject, ["contentType"], fromContentType);
    }
    return toObject;
  }
  function safetyAttributesFromVertex(fromObject) {
    const toObject = {};
    const fromCategories = getValueByPath(fromObject, [
      "safetyAttributes",
      "categories"
    ]);
    if (fromCategories != null) {
      setValueByPath(toObject, ["categories"], fromCategories);
    }
    const fromScores = getValueByPath(fromObject, [
      "safetyAttributes",
      "scores"
    ]);
    if (fromScores != null) {
      setValueByPath(toObject, ["scores"], fromScores);
    }
    const fromContentType = getValueByPath(fromObject, ["contentType"]);
    if (fromContentType != null) {
      setValueByPath(toObject, ["contentType"], fromContentType);
    }
    return toObject;
  }
  function safetySettingToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["method"]) !== void 0) {
      throw new Error("method parameter is not supported in Gemini API.");
    }
    const fromCategory = getValueByPath(fromObject, ["category"]);
    if (fromCategory != null) {
      setValueByPath(toObject, ["category"], fromCategory);
    }
    const fromThreshold = getValueByPath(fromObject, ["threshold"]);
    if (fromThreshold != null) {
      setValueByPath(toObject, ["threshold"], fromThreshold);
    }
    return toObject;
  }
  function safetySettingToVertex(fromObject) {
    const toObject = {};
    const fromMethod = getValueByPath(fromObject, ["method"]);
    if (fromMethod != null) {
      setValueByPath(toObject, ["method"], fromMethod);
    }
    const fromCategory = getValueByPath(fromObject, ["category"]);
    if (fromCategory != null) {
      setValueByPath(toObject, ["category"], fromCategory);
    }
    const fromThreshold = getValueByPath(fromObject, ["threshold"]);
    if (fromThreshold != null) {
      setValueByPath(toObject, ["threshold"], fromThreshold);
    }
    return toObject;
  }
  function schemaToMldev(fromObject) {
    const toObject = {};
    const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
    if (fromAnyOf != null) {
      setValueByPath(toObject, ["anyOf"], fromAnyOf);
    }
    const fromDefault = getValueByPath(fromObject, ["default"]);
    if (fromDefault != null) {
      setValueByPath(toObject, ["default"], fromDefault);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromEnum = getValueByPath(fromObject, ["enum"]);
    if (fromEnum != null) {
      setValueByPath(toObject, ["enum"], fromEnum);
    }
    const fromExample = getValueByPath(fromObject, ["example"]);
    if (fromExample != null) {
      setValueByPath(toObject, ["example"], fromExample);
    }
    const fromFormat = getValueByPath(fromObject, ["format"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["format"], fromFormat);
    }
    const fromItems = getValueByPath(fromObject, ["items"]);
    if (fromItems != null) {
      setValueByPath(toObject, ["items"], fromItems);
    }
    const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
    if (fromMaxItems != null) {
      setValueByPath(toObject, ["maxItems"], fromMaxItems);
    }
    const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
    if (fromMaxLength != null) {
      setValueByPath(toObject, ["maxLength"], fromMaxLength);
    }
    const fromMaxProperties = getValueByPath(fromObject, [
      "maxProperties"
    ]);
    if (fromMaxProperties != null) {
      setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
    }
    const fromMaximum = getValueByPath(fromObject, ["maximum"]);
    if (fromMaximum != null) {
      setValueByPath(toObject, ["maximum"], fromMaximum);
    }
    const fromMinItems = getValueByPath(fromObject, ["minItems"]);
    if (fromMinItems != null) {
      setValueByPath(toObject, ["minItems"], fromMinItems);
    }
    const fromMinLength = getValueByPath(fromObject, ["minLength"]);
    if (fromMinLength != null) {
      setValueByPath(toObject, ["minLength"], fromMinLength);
    }
    const fromMinProperties = getValueByPath(fromObject, [
      "minProperties"
    ]);
    if (fromMinProperties != null) {
      setValueByPath(toObject, ["minProperties"], fromMinProperties);
    }
    const fromMinimum = getValueByPath(fromObject, ["minimum"]);
    if (fromMinimum != null) {
      setValueByPath(toObject, ["minimum"], fromMinimum);
    }
    const fromNullable = getValueByPath(fromObject, ["nullable"]);
    if (fromNullable != null) {
      setValueByPath(toObject, ["nullable"], fromNullable);
    }
    const fromPattern = getValueByPath(fromObject, ["pattern"]);
    if (fromPattern != null) {
      setValueByPath(toObject, ["pattern"], fromPattern);
    }
    const fromProperties = getValueByPath(fromObject, ["properties"]);
    if (fromProperties != null) {
      setValueByPath(toObject, ["properties"], fromProperties);
    }
    const fromPropertyOrdering = getValueByPath(fromObject, [
      "propertyOrdering"
    ]);
    if (fromPropertyOrdering != null) {
      setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
    }
    const fromRequired = getValueByPath(fromObject, ["required"]);
    if (fromRequired != null) {
      setValueByPath(toObject, ["required"], fromRequired);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (fromTitle != null) {
      setValueByPath(toObject, ["title"], fromTitle);
    }
    const fromType = getValueByPath(fromObject, ["type"]);
    if (fromType != null) {
      setValueByPath(toObject, ["type"], fromType);
    }
    return toObject;
  }
  function schemaToVertex(fromObject) {
    const toObject = {};
    const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
    if (fromAnyOf != null) {
      setValueByPath(toObject, ["anyOf"], fromAnyOf);
    }
    const fromDefault = getValueByPath(fromObject, ["default"]);
    if (fromDefault != null) {
      setValueByPath(toObject, ["default"], fromDefault);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromEnum = getValueByPath(fromObject, ["enum"]);
    if (fromEnum != null) {
      setValueByPath(toObject, ["enum"], fromEnum);
    }
    const fromExample = getValueByPath(fromObject, ["example"]);
    if (fromExample != null) {
      setValueByPath(toObject, ["example"], fromExample);
    }
    const fromFormat = getValueByPath(fromObject, ["format"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["format"], fromFormat);
    }
    const fromItems = getValueByPath(fromObject, ["items"]);
    if (fromItems != null) {
      setValueByPath(toObject, ["items"], fromItems);
    }
    const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
    if (fromMaxItems != null) {
      setValueByPath(toObject, ["maxItems"], fromMaxItems);
    }
    const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
    if (fromMaxLength != null) {
      setValueByPath(toObject, ["maxLength"], fromMaxLength);
    }
    const fromMaxProperties = getValueByPath(fromObject, [
      "maxProperties"
    ]);
    if (fromMaxProperties != null) {
      setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
    }
    const fromMaximum = getValueByPath(fromObject, ["maximum"]);
    if (fromMaximum != null) {
      setValueByPath(toObject, ["maximum"], fromMaximum);
    }
    const fromMinItems = getValueByPath(fromObject, ["minItems"]);
    if (fromMinItems != null) {
      setValueByPath(toObject, ["minItems"], fromMinItems);
    }
    const fromMinLength = getValueByPath(fromObject, ["minLength"]);
    if (fromMinLength != null) {
      setValueByPath(toObject, ["minLength"], fromMinLength);
    }
    const fromMinProperties = getValueByPath(fromObject, [
      "minProperties"
    ]);
    if (fromMinProperties != null) {
      setValueByPath(toObject, ["minProperties"], fromMinProperties);
    }
    const fromMinimum = getValueByPath(fromObject, ["minimum"]);
    if (fromMinimum != null) {
      setValueByPath(toObject, ["minimum"], fromMinimum);
    }
    const fromNullable = getValueByPath(fromObject, ["nullable"]);
    if (fromNullable != null) {
      setValueByPath(toObject, ["nullable"], fromNullable);
    }
    const fromPattern = getValueByPath(fromObject, ["pattern"]);
    if (fromPattern != null) {
      setValueByPath(toObject, ["pattern"], fromPattern);
    }
    const fromProperties = getValueByPath(fromObject, ["properties"]);
    if (fromProperties != null) {
      setValueByPath(toObject, ["properties"], fromProperties);
    }
    const fromPropertyOrdering = getValueByPath(fromObject, [
      "propertyOrdering"
    ]);
    if (fromPropertyOrdering != null) {
      setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
    }
    const fromRequired = getValueByPath(fromObject, ["required"]);
    if (fromRequired != null) {
      setValueByPath(toObject, ["required"], fromRequired);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (fromTitle != null) {
      setValueByPath(toObject, ["title"], fromTitle);
    }
    const fromType = getValueByPath(fromObject, ["type"]);
    if (fromType != null) {
      setValueByPath(toObject, ["type"], fromType);
    }
    return toObject;
  }
  function scribbleImageToVertex(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageToVertex(fromImage));
    }
    return toObject;
  }
  function segmentImageConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (parentObject !== void 0 && fromMode != null) {
      setValueByPath(parentObject, ["parameters", "mode"], fromMode);
    }
    const fromMaxPredictions = getValueByPath(fromObject, [
      "maxPredictions"
    ]);
    if (parentObject !== void 0 && fromMaxPredictions != null) {
      setValueByPath(parentObject, ["parameters", "maxPredictions"], fromMaxPredictions);
    }
    const fromConfidenceThreshold = getValueByPath(fromObject, [
      "confidenceThreshold"
    ]);
    if (parentObject !== void 0 && fromConfidenceThreshold != null) {
      setValueByPath(parentObject, ["parameters", "confidenceThreshold"], fromConfidenceThreshold);
    }
    const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
    if (parentObject !== void 0 && fromMaskDilation != null) {
      setValueByPath(parentObject, ["parameters", "maskDilation"], fromMaskDilation);
    }
    const fromBinaryColorThreshold = getValueByPath(fromObject, [
      "binaryColorThreshold"
    ]);
    if (parentObject !== void 0 && fromBinaryColorThreshold != null) {
      setValueByPath(parentObject, ["parameters", "binaryColorThreshold"], fromBinaryColorThreshold);
    }
    return toObject;
  }
  function segmentImageParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      segmentImageSourceToVertex(fromSource, toObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      segmentImageConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function segmentImageResponseFromVertex(fromObject) {
    const toObject = {};
    const fromGeneratedMasks = getValueByPath(fromObject, ["predictions"]);
    if (fromGeneratedMasks != null) {
      let transformedList = fromGeneratedMasks;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageMaskFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedMasks"], transformedList);
    }
    return toObject;
  }
  function segmentImageSourceToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (parentObject !== void 0 && fromPrompt != null) {
      setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (parentObject !== void 0 && fromImage != null) {
      setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
    }
    const fromScribbleImage = getValueByPath(fromObject, [
      "scribbleImage"
    ]);
    if (parentObject !== void 0 && fromScribbleImage != null) {
      setValueByPath(parentObject, ["instances[0]", "scribble"], scribbleImageToVertex(fromScribbleImage));
    }
    return toObject;
  }
  function speakerVoiceConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
    if (fromSpeaker != null) {
      setValueByPath(toObject, ["speaker"], fromSpeaker);
    }
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$1(fromVoiceConfig));
    }
    return toObject;
  }
  function speechConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev$1(fromVoiceConfig));
    }
    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
      "multiSpeakerVoiceConfig"
    ]);
    if (fromMultiSpeakerVoiceConfig != null) {
      setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev$1(fromMultiSpeakerVoiceConfig));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function speechConfigToVertex(fromObject) {
    const toObject = {};
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToVertex(fromVoiceConfig));
    }
    if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
      throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function styleReferenceConfigToVertex(fromObject) {
    const toObject = {};
    const fromStyleDescription = getValueByPath(fromObject, [
      "styleDescription"
    ]);
    if (fromStyleDescription != null) {
      setValueByPath(toObject, ["styleDescription"], fromStyleDescription);
    }
    return toObject;
  }
  function subjectReferenceConfigToVertex(fromObject) {
    const toObject = {};
    const fromSubjectType = getValueByPath(fromObject, ["subjectType"]);
    if (fromSubjectType != null) {
      setValueByPath(toObject, ["subjectType"], fromSubjectType);
    }
    const fromSubjectDescription = getValueByPath(fromObject, [
      "subjectDescription"
    ]);
    if (fromSubjectDescription != null) {
      setValueByPath(toObject, ["subjectDescription"], fromSubjectDescription);
    }
    return toObject;
  }
  function thinkingConfigToMldev(fromObject) {
    const toObject = {};
    const fromIncludeThoughts = getValueByPath(fromObject, [
      "includeThoughts"
    ]);
    if (fromIncludeThoughts != null) {
      setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
    }
    const fromThinkingBudget = getValueByPath(fromObject, [
      "thinkingBudget"
    ]);
    if (fromThinkingBudget != null) {
      setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
    }
    return toObject;
  }
  function thinkingConfigToVertex(fromObject) {
    const toObject = {};
    const fromIncludeThoughts = getValueByPath(fromObject, [
      "includeThoughts"
    ]);
    if (fromIncludeThoughts != null) {
      setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
    }
    const fromThinkingBudget = getValueByPath(fromObject, [
      "thinkingBudget"
    ]);
    if (fromThinkingBudget != null) {
      setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
    }
    return toObject;
  }
  function toolComputerUseToMldev$1(fromObject) {
    const toObject = {};
    const fromEnvironment = getValueByPath(fromObject, ["environment"]);
    if (fromEnvironment != null) {
      setValueByPath(toObject, ["environment"], fromEnvironment);
    }
    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [
      "excludedPredefinedFunctions"
    ]);
    if (fromExcludedPredefinedFunctions != null) {
      setValueByPath(toObject, ["excludedPredefinedFunctions"], fromExcludedPredefinedFunctions);
    }
    return toObject;
  }
  function toolComputerUseToVertex(fromObject) {
    const toObject = {};
    const fromEnvironment = getValueByPath(fromObject, ["environment"]);
    if (fromEnvironment != null) {
      setValueByPath(toObject, ["environment"], fromEnvironment);
    }
    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [
      "excludedPredefinedFunctions"
    ]);
    if (fromExcludedPredefinedFunctions != null) {
      setValueByPath(toObject, ["excludedPredefinedFunctions"], fromExcludedPredefinedFunctions);
    }
    return toObject;
  }
  function toolConfigToMldev(fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev(fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToMldev(fromRetrievalConfig));
    }
    return toObject;
  }
  function toolConfigToVertex(fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToVertex(fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], retrievalConfigToVertex(fromRetrievalConfig));
    }
    return toObject;
  }
  function toolToMldev$1(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToMldev$1(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$1(fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$1(fromGoogleSearchRetrieval));
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
      throw new Error("googleMaps parameter is not supported in Gemini API.");
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], urlContextToMldev$1());
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], toolComputerUseToMldev$1(fromComputerUse));
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function toolToVertex(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToVertex(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
    if (fromRetrieval != null) {
      setValueByPath(toObject, ["retrieval"], fromRetrieval);
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToVertex(fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex(fromGoogleSearchRetrieval));
    }
    const fromEnterpriseWebSearch = getValueByPath(fromObject, [
      "enterpriseWebSearch"
    ]);
    if (fromEnterpriseWebSearch != null) {
      setValueByPath(toObject, ["enterpriseWebSearch"], enterpriseWebSearchToVertex(fromEnterpriseWebSearch));
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToVertex(fromGoogleMaps));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], urlContextToVertex());
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], toolComputerUseToVertex(fromComputerUse));
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function tunedModelInfoFromMldev(fromObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    return toObject;
  }
  function tunedModelInfoFromVertex(fromObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, [
      "labels",
      "google-vertex-llm-tuning-base-model-id"
    ]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    return toObject;
  }
  function updateModelConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (parentObject !== void 0 && fromDescription != null) {
      setValueByPath(parentObject, ["description"], fromDescription);
    }
    const fromDefaultCheckpointId = getValueByPath(fromObject, [
      "defaultCheckpointId"
    ]);
    if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
      setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
    }
    return toObject;
  }
  function updateModelConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (parentObject !== void 0 && fromDescription != null) {
      setValueByPath(parentObject, ["description"], fromDescription);
    }
    const fromDefaultCheckpointId = getValueByPath(fromObject, [
      "defaultCheckpointId"
    ]);
    if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
      setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
    }
    return toObject;
  }
  function updateModelParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      updateModelConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function updateModelParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      updateModelConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromEnhanceInputImage = getValueByPath(fromObject, [
      "enhanceInputImage"
    ]);
    if (parentObject !== void 0 && fromEnhanceInputImage != null) {
      setValueByPath(parentObject, ["parameters", "upscaleConfig", "enhanceInputImage"], fromEnhanceInputImage);
    }
    const fromImagePreservationFactor = getValueByPath(fromObject, [
      "imagePreservationFactor"
    ]);
    if (parentObject !== void 0 && fromImagePreservationFactor != null) {
      setValueByPath(parentObject, ["parameters", "upscaleConfig", "imagePreservationFactor"], fromImagePreservationFactor);
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (parentObject !== void 0 && fromMode != null) {
      setValueByPath(parentObject, ["parameters", "mode"], fromMode);
    }
    return toObject;
  }
  function upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
    }
    const fromUpscaleFactor = getValueByPath(fromObject, [
      "upscaleFactor"
    ]);
    if (fromUpscaleFactor != null) {
      setValueByPath(toObject, ["parameters", "upscaleConfig", "upscaleFactor"], fromUpscaleFactor);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function upscaleImageResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    return toObject;
  }
  function urlContextMetadataFromMldev(fromObject) {
    const toObject = {};
    const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
    if (fromUrlMetadata != null) {
      let transformedList = fromUrlMetadata;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return urlMetadataFromMldev(item);
        });
      }
      setValueByPath(toObject, ["urlMetadata"], transformedList);
    }
    return toObject;
  }
  function urlContextMetadataFromVertex(fromObject) {
    const toObject = {};
    const fromUrlMetadata = getValueByPath(fromObject, ["urlMetadata"]);
    if (fromUrlMetadata != null) {
      let transformedList = fromUrlMetadata;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return urlMetadataFromVertex(item);
        });
      }
      setValueByPath(toObject, ["urlMetadata"], transformedList);
    }
    return toObject;
  }
  function urlContextToMldev$1() {
    const toObject = {};
    return toObject;
  }
  function urlContextToVertex() {
    const toObject = {};
    return toObject;
  }
  function urlMetadataFromMldev(fromObject) {
    const toObject = {};
    const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
    if (fromRetrievedUrl != null) {
      setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
    }
    const fromUrlRetrievalStatus = getValueByPath(fromObject, [
      "urlRetrievalStatus"
    ]);
    if (fromUrlRetrievalStatus != null) {
      setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
    }
    return toObject;
  }
  function urlMetadataFromVertex(fromObject) {
    const toObject = {};
    const fromRetrievedUrl = getValueByPath(fromObject, ["retrievedUrl"]);
    if (fromRetrievedUrl != null) {
      setValueByPath(toObject, ["retrievedUrl"], fromRetrievedUrl);
    }
    const fromUrlRetrievalStatus = getValueByPath(fromObject, [
      "urlRetrievalStatus"
    ]);
    if (fromUrlRetrievalStatus != null) {
      setValueByPath(toObject, ["urlRetrievalStatus"], fromUrlRetrievalStatus);
    }
    return toObject;
  }
  function videoFromMldev(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["video", "uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, [
      "video",
      "encodedVideo"
    ]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["encoding"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function videoFromVertex(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function videoGenerationMaskToVertex(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["_self"], imageToVertex(fromImage));
    }
    const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
    if (fromMaskMode != null) {
      setValueByPath(toObject, ["maskMode"], fromMaskMode);
    }
    return toObject;
  }
  function videoGenerationReferenceImageToVertex(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageToVertex(fromImage));
    }
    const fromReferenceType = getValueByPath(fromObject, [
      "referenceType"
    ]);
    if (fromReferenceType != null) {
      setValueByPath(toObject, ["referenceType"], fromReferenceType);
    }
    return toObject;
  }
  function videoMetadataFromMldev(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function videoMetadataFromVertex(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function videoMetadataToMldev$1(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function videoMetadataToVertex(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function videoToVertex(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function voiceConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
      "prebuiltVoiceConfig"
    ]);
    if (fromPrebuiltVoiceConfig != null) {
      setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev$1(fromPrebuiltVoiceConfig));
    }
    return toObject;
  }
  function voiceConfigToVertex(fromObject) {
    const toObject = {};
    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
      "prebuiltVoiceConfig"
    ]);
    if (fromPrebuiltVoiceConfig != null) {
      setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToVertex(fromPrebuiltVoiceConfig));
    }
    return toObject;
  }
  var CONTENT_TYPE_HEADER = "Content-Type";
  var SERVER_TIMEOUT_HEADER = "X-Server-Timeout";
  var USER_AGENT_HEADER = "User-Agent";
  var GOOGLE_API_CLIENT_HEADER = "x-goog-api-client";
  var SDK_VERSION = "1.21.0";
  var LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;
  var VERTEX_AI_API_DEFAULT_VERSION = "v1beta1";
  var GOOGLE_AI_API_DEFAULT_VERSION = "v1beta";
  var responseLineRE = /^\s*data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
  var ApiClient = class {
    constructor(opts) {
      var _a, _b;
      this.clientOptions = Object.assign(Object.assign({}, opts), { project: opts.project, location: opts.location, apiKey: opts.apiKey, vertexai: opts.vertexai });
      const initHttpOptions = {};
      if (this.clientOptions.vertexai) {
        initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;
        initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();
        this.normalizeAuthParameters();
      } else {
        initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;
        initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;
      }
      initHttpOptions.headers = this.getDefaultHeaders();
      this.clientOptions.httpOptions = initHttpOptions;
      if (opts.httpOptions) {
        this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);
      }
    }
    /**
     * Determines the base URL for Vertex AI based on project and location.
     * Uses the global endpoint if location is 'global' or if project/location
     * are not specified (implying API key usage).
     * @private
     */
    baseUrlFromProjectLocation() {
      if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global") {
        return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;
      }
      return `https://aiplatform.googleapis.com/`;
    }
    /**
     * Normalizes authentication parameters for Vertex AI.
     * If project and location are provided, API key is cleared.
     * If project and location are not provided (implying API key usage),
     * project and location are cleared.
     * @private
     */
    normalizeAuthParameters() {
      if (this.clientOptions.project && this.clientOptions.location) {
        this.clientOptions.apiKey = void 0;
        return;
      }
      this.clientOptions.project = void 0;
      this.clientOptions.location = void 0;
    }
    isVertexAI() {
      var _a;
      return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;
    }
    getProject() {
      return this.clientOptions.project;
    }
    getLocation() {
      return this.clientOptions.location;
    }
    getApiVersion() {
      if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) {
        return this.clientOptions.httpOptions.apiVersion;
      }
      throw new Error("API version is not set.");
    }
    getBaseUrl() {
      if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) {
        return this.clientOptions.httpOptions.baseUrl;
      }
      throw new Error("Base URL is not set.");
    }
    getRequestUrl() {
      return this.getRequestUrlInternal(this.clientOptions.httpOptions);
    }
    getHeaders() {
      if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) {
        return this.clientOptions.httpOptions.headers;
      } else {
        throw new Error("Headers are not set.");
      }
    }
    getRequestUrlInternal(httpOptions) {
      if (!httpOptions || httpOptions.baseUrl === void 0 || httpOptions.apiVersion === void 0) {
        throw new Error("HTTP options are not correctly set.");
      }
      const baseUrl = httpOptions.baseUrl.endsWith("/") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;
      const urlElement = [baseUrl];
      if (httpOptions.apiVersion && httpOptions.apiVersion !== "") {
        urlElement.push(httpOptions.apiVersion);
      }
      return urlElement.join("/");
    }
    getBaseResourcePath() {
      return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
    }
    getApiKey() {
      return this.clientOptions.apiKey;
    }
    getWebsocketBaseUrl() {
      const baseUrl = this.getBaseUrl();
      const urlParts = new URL(baseUrl);
      urlParts.protocol = urlParts.protocol == "http:" ? "ws" : "wss";
      return urlParts.toString();
    }
    setBaseUrl(url) {
      if (this.clientOptions.httpOptions) {
        this.clientOptions.httpOptions.baseUrl = url;
      } else {
        throw new Error("HTTP options are not correctly set.");
      }
    }
    constructUrl(path, httpOptions, prependProjectLocation) {
      const urlElement = [this.getRequestUrlInternal(httpOptions)];
      if (prependProjectLocation) {
        urlElement.push(this.getBaseResourcePath());
      }
      if (path !== "") {
        urlElement.push(path);
      }
      const url = new URL(`${urlElement.join("/")}`);
      return url;
    }
    shouldPrependVertexProjectPath(request) {
      if (this.clientOptions.apiKey) {
        return false;
      }
      if (!this.clientOptions.vertexai) {
        return false;
      }
      if (request.path.startsWith("projects/")) {
        return false;
      }
      if (request.httpMethod === "GET" && request.path.startsWith("publishers/google/models")) {
        return false;
      }
      return true;
    }
    async request(request) {
      let patchedHttpOptions = this.clientOptions.httpOptions;
      if (request.httpOptions) {
        patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
      }
      const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
      const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
      if (request.queryParams) {
        for (const [key, value] of Object.entries(request.queryParams)) {
          url.searchParams.append(key, String(value));
        }
      }
      let requestInit = {};
      if (request.httpMethod === "GET") {
        if (request.body && request.body !== "{}") {
          throw new Error("Request body should be empty for GET request, but got non empty request body");
        }
      } else {
        requestInit.body = request.body;
      }
      requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);
      return this.unaryApiCall(url, requestInit, request.httpMethod);
    }
    patchHttpOptions(baseHttpOptions, requestHttpOptions) {
      const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));
      for (const [key, value] of Object.entries(requestHttpOptions)) {
        if (typeof value === "object") {
          patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);
        } else if (value !== void 0) {
          patchedHttpOptions[key] = value;
        }
      }
      return patchedHttpOptions;
    }
    async requestStream(request) {
      let patchedHttpOptions = this.clientOptions.httpOptions;
      if (request.httpOptions) {
        patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
      }
      const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
      const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
      if (!url.searchParams.has("alt") || url.searchParams.get("alt") !== "sse") {
        url.searchParams.set("alt", "sse");
      }
      let requestInit = {};
      requestInit.body = request.body;
      requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);
      return this.streamApiCall(url, requestInit, request.httpMethod);
    }
    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, abortSignal) {
      if (httpOptions && httpOptions.timeout || abortSignal) {
        const abortController = new AbortController();
        const signal = abortController.signal;
        if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {
          const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);
          if (timeoutHandle && typeof timeoutHandle.unref === "function") {
            timeoutHandle.unref();
          }
        }
        if (abortSignal) {
          abortSignal.addEventListener("abort", () => {
            abortController.abort();
          });
        }
        requestInit.signal = signal;
      }
      if (httpOptions && httpOptions.extraBody !== null) {
        includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);
      }
      requestInit.headers = await this.getHeadersInternal(httpOptions);
      return requestInit;
    }
    async unaryApiCall(url, requestInit, httpMethod) {
      return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
        await throwErrorIfNotOK(response);
        return new HttpResponse(response);
      }).catch((e) => {
        if (e instanceof Error) {
          throw e;
        } else {
          throw new Error(JSON.stringify(e));
        }
      });
    }
    async streamApiCall(url, requestInit, httpMethod) {
      return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
        await throwErrorIfNotOK(response);
        return this.processStreamResponse(response);
      }).catch((e) => {
        if (e instanceof Error) {
          throw e;
        } else {
          throw new Error(JSON.stringify(e));
        }
      });
    }
    processStreamResponse(response) {
      var _a;
      return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
        const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();
        const decoder = new TextDecoder("utf-8");
        if (!reader) {
          throw new Error("Response body is empty");
        }
        try {
          let buffer = "";
          while (true) {
            const { done, value } = yield __await(reader.read());
            if (done) {
              if (buffer.trim().length > 0) {
                throw new Error("Incomplete JSON segment at the end");
              }
              break;
            }
            const chunkString = decoder.decode(value, { stream: true });
            try {
              const chunkJson = JSON.parse(chunkString);
              if ("error" in chunkJson) {
                const errorJson = JSON.parse(JSON.stringify(chunkJson["error"]));
                const status = errorJson["status"];
                const code = errorJson["code"];
                const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;
                if (code >= 400 && code < 600) {
                  const apiError = new ApiError({
                    message: errorMessage,
                    status: code
                  });
                  throw apiError;
                }
              }
            } catch (e) {
              const error = e;
              if (error.name === "ApiError") {
                throw e;
              }
            }
            buffer += chunkString;
            let match = buffer.match(responseLineRE);
            while (match) {
              const processedChunkString = match[1];
              try {
                const partialResponse = new Response(processedChunkString, {
                  headers: response === null || response === void 0 ? void 0 : response.headers,
                  status: response === null || response === void 0 ? void 0 : response.status,
                  statusText: response === null || response === void 0 ? void 0 : response.statusText
                });
                yield yield __await(new HttpResponse(partialResponse));
                buffer = buffer.slice(match[0].length);
                match = buffer.match(responseLineRE);
              } catch (e) {
                throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);
              }
            }
          }
        } finally {
          reader.releaseLock();
        }
      });
    }
    async apiCall(url, requestInit) {
      return fetch(url, requestInit).catch((e) => {
        throw new Error(`exception ${e} sending request`);
      });
    }
    getDefaultHeaders() {
      const headers = {};
      const versionHeaderValue = LIBRARY_LABEL + " " + this.clientOptions.userAgentExtra;
      headers[USER_AGENT_HEADER] = versionHeaderValue;
      headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;
      headers[CONTENT_TYPE_HEADER] = "application/json";
      return headers;
    }
    async getHeadersInternal(httpOptions) {
      const headers = new Headers();
      if (httpOptions && httpOptions.headers) {
        for (const [key, value] of Object.entries(httpOptions.headers)) {
          headers.append(key, value);
        }
        if (httpOptions.timeout && httpOptions.timeout > 0) {
          headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1e3)));
        }
      }
      await this.clientOptions.auth.addAuthHeaders(headers);
      return headers;
    }
    /**
     * Uploads a file asynchronously using Gemini API only, this is not supported
     * in Vertex AI.
     *
     * @param file The string path to the file to be uploaded or a Blob object.
     * @param config Optional parameters specified in the `UploadFileConfig`
     *     interface. @see {@link UploadFileConfig}
     * @return A promise that resolves to a `File` object.
     * @throws An error if called on a Vertex AI client.
     * @throws An error if the `mimeType` is not provided and can not be inferred,
     */
    async uploadFile(file, config) {
      var _a;
      const fileToUpload = {};
      if (config != null) {
        fileToUpload.mimeType = config.mimeType;
        fileToUpload.name = config.name;
        fileToUpload.displayName = config.displayName;
      }
      if (fileToUpload.name && !fileToUpload.name.startsWith("files/")) {
        fileToUpload.name = `files/${fileToUpload.name}`;
      }
      const uploader = this.clientOptions.uploader;
      const fileStat = await uploader.stat(file);
      fileToUpload.sizeBytes = String(fileStat.size);
      const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;
      if (mimeType === void 0 || mimeType === "") {
        throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
      }
      fileToUpload.mimeType = mimeType;
      const uploadUrl = await this.fetchUploadUrl(fileToUpload, config);
      return uploader.upload(file, uploadUrl, this);
    }
    /**
     * Downloads a file asynchronously to the specified path.
     *
     * @params params - The parameters for the download request, see {@link
     * DownloadFileParameters}
     */
    async downloadFile(params) {
      const downloader = this.clientOptions.downloader;
      await downloader.download(params, this);
    }
    async fetchUploadUrl(file, config) {
      var _a;
      let httpOptions = {};
      if (config === null || config === void 0 ? void 0 : config.httpOptions) {
        httpOptions = config.httpOptions;
      } else {
        httpOptions = {
          apiVersion: "",
          headers: {
            "Content-Type": "application/json",
            "X-Goog-Upload-Protocol": "resumable",
            "X-Goog-Upload-Command": "start",
            "X-Goog-Upload-Header-Content-Length": `${file.sizeBytes}`,
            "X-Goog-Upload-Header-Content-Type": `${file.mimeType}`
          }
        };
      }
      const body = {
        "file": file
      };
      const httpResponse = await this.request({
        path: formatMap("upload/v1beta/files", body["_url"]),
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions
      });
      if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {
        throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
      }
      const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a["x-goog-upload-url"];
      if (uploadUrl === void 0) {
        throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
      }
      return uploadUrl;
    }
  };
  async function throwErrorIfNotOK(response) {
    var _a;
    if (response === void 0) {
      throw new Error("response is undefined");
    }
    if (!response.ok) {
      const status = response.status;
      let errorBody;
      if ((_a = response.headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.includes("application/json")) {
        errorBody = await response.json();
      } else {
        errorBody = {
          error: {
            message: await response.text(),
            code: response.status,
            status: response.statusText
          }
        };
      }
      const errorMessage = JSON.stringify(errorBody);
      if (status >= 400 && status < 600) {
        const apiError = new ApiError({
          message: errorMessage,
          status
        });
        throw apiError;
      }
      throw new Error(errorMessage);
    }
  }
  function includeExtraBodyToRequestInit(requestInit, extraBody) {
    if (!extraBody || Object.keys(extraBody).length === 0) {
      return;
    }
    if (requestInit.body instanceof Blob) {
      console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");
      return;
    }
    let currentBodyObject = {};
    if (typeof requestInit.body === "string" && requestInit.body.length > 0) {
      try {
        const parsedBody = JSON.parse(requestInit.body);
        if (typeof parsedBody === "object" && parsedBody !== null && !Array.isArray(parsedBody)) {
          currentBodyObject = parsedBody;
        } else {
          console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");
          return;
        }
      } catch (e) {
        console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");
        return;
      }
    }
    function deepMerge(target, source) {
      const output = Object.assign({}, target);
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          const sourceValue = source[key];
          const targetValue = output[key];
          if (sourceValue && typeof sourceValue === "object" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === "object" && !Array.isArray(targetValue)) {
            output[key] = deepMerge(targetValue, sourceValue);
          } else {
            if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {
              console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${key}". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);
            }
            output[key] = sourceValue;
          }
        }
      }
      return output;
    }
    const mergedBody = deepMerge(currentBodyObject, extraBody);
    requestInit.body = JSON.stringify(mergedBody);
  }
  var MCP_LABEL = "mcp_used/unknown";
  var hasMcpToolUsageFromMcpToTool = false;
  function hasMcpToolUsage(tools) {
    for (const tool of tools) {
      if (isMcpCallableTool(tool)) {
        return true;
      }
      if (typeof tool === "object" && "inputSchema" in tool) {
        return true;
      }
    }
    return hasMcpToolUsageFromMcpToTool;
  }
  function setMcpUsageHeader(headers) {
    var _a;
    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : "";
    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();
  }
  function isMcpCallableTool(object) {
    return object !== null && typeof object === "object" && object instanceof McpCallableTool;
  }
  function listAllTools(mcpClient, maxTools = 100) {
    return __asyncGenerator(this, arguments, function* listAllTools_1() {
      let cursor = void 0;
      let numTools = 0;
      while (numTools < maxTools) {
        const t = yield __await(mcpClient.listTools({ cursor }));
        for (const tool of t.tools) {
          yield yield __await(tool);
          numTools++;
        }
        if (!t.nextCursor) {
          break;
        }
        cursor = t.nextCursor;
      }
    });
  }
  var McpCallableTool = class _McpCallableTool {
    constructor(mcpClients = [], config) {
      this.mcpTools = [];
      this.functionNameToMcpClient = {};
      this.mcpClients = mcpClients;
      this.config = config;
    }
    /**
     * Creates a McpCallableTool.
     */
    static create(mcpClients, config) {
      return new _McpCallableTool(mcpClients, config);
    }
    /**
     * Validates the function names are not duplicate and initialize the function
     * name to MCP client mapping.
     *
     * @throws {Error} if the MCP tools from the MCP clients have duplicate tool
     *     names.
     */
    async initialize() {
      var _a, e_1, _b, _c;
      if (this.mcpTools.length > 0) {
        return;
      }
      const functionMap = {};
      const mcpTools = [];
      for (const mcpClient of this.mcpClients) {
        try {
          for (var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const mcpTool = _c;
            mcpTools.push(mcpTool);
            const mcpToolName = mcpTool.name;
            if (functionMap[mcpToolName]) {
              throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
            }
            functionMap[mcpToolName] = mcpClient;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
      this.mcpTools = mcpTools;
      this.functionNameToMcpClient = functionMap;
    }
    async tool() {
      await this.initialize();
      return mcpToolsToGeminiTool(this.mcpTools, this.config);
    }
    async callTool(functionCalls) {
      await this.initialize();
      const functionCallResponseParts = [];
      for (const functionCall of functionCalls) {
        if (functionCall.name in this.functionNameToMcpClient) {
          const mcpClient = this.functionNameToMcpClient[functionCall.name];
          let requestOptions = void 0;
          if (this.config.timeout) {
            requestOptions = {
              timeout: this.config.timeout
            };
          }
          const callToolResponse = await mcpClient.callTool(
            {
              name: functionCall.name,
              arguments: functionCall.args
            },
            // Set the result schema to undefined to allow MCP to rely on the
            // default schema.
            void 0,
            requestOptions
          );
          functionCallResponseParts.push({
            functionResponse: {
              name: functionCall.name,
              response: callToolResponse.isError ? { error: callToolResponse } : callToolResponse
            }
          });
        }
      }
      return functionCallResponseParts;
    }
  };
  async function handleWebSocketMessage$1(apiClient, onmessage, event) {
    const serverMessage = new LiveMusicServerMessage();
    let data;
    if (event.data instanceof Blob) {
      data = JSON.parse(await event.data.text());
    } else {
      data = JSON.parse(event.data);
    }
    const response = liveMusicServerMessageFromMldev(data);
    Object.assign(serverMessage, response);
    onmessage(serverMessage);
  }
  var LiveMusic = class {
    constructor(apiClient, auth, webSocketFactory) {
      this.apiClient = apiClient;
      this.auth = auth;
      this.webSocketFactory = webSocketFactory;
    }
    /**
         Establishes a connection to the specified model and returns a
         LiveMusicSession object representing that connection.
    
         @experimental
    
         @remarks
    
         @param params - The parameters for establishing a connection to the model.
         @return A live session.
    
         @example
         ```ts
         let model = 'models/lyria-realtime-exp';
         const session = await ai.live.music.connect({
           model: model,
           callbacks: {
             onmessage: (e: MessageEvent) => {
               console.log('Received message from the server: %s\n', debug(e.data));
             },
             onerror: (e: ErrorEvent) => {
               console.log('Error occurred: %s\n', debug(e.error));
             },
             onclose: (e: CloseEvent) => {
               console.log('Connection closed.');
             },
           },
         });
         ```
        */
    async connect(params) {
      var _a, _b;
      if (this.apiClient.isVertexAI()) {
        throw new Error("Live music is not supported for Vertex AI.");
      }
      console.warn("Live music generation is experimental and may change in future versions.");
      const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
      const apiVersion = this.apiClient.getApiVersion();
      const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());
      const apiKey = this.apiClient.getApiKey();
      const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;
      let onopenResolve = () => {
      };
      const onopenPromise = new Promise((resolve) => {
        onopenResolve = resolve;
      });
      const callbacks = params.callbacks;
      const onopenAwaitedCallback = function() {
        onopenResolve({});
      };
      const apiClient = this.apiClient;
      const websocketCallbacks = {
        onopen: onopenAwaitedCallback,
        onmessage: (event) => {
          void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);
        },
        onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {
        },
        onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
        }
      };
      const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);
      conn.connect();
      await onopenPromise;
      const model = tModel(this.apiClient, params.model);
      const setup = liveMusicClientSetupToMldev({
        model
      });
      const clientMessage = liveMusicClientMessageToMldev({ setup });
      conn.send(JSON.stringify(clientMessage));
      return new LiveMusicSession(conn, this.apiClient);
    }
  };
  var LiveMusicSession = class {
    constructor(conn, apiClient) {
      this.conn = conn;
      this.apiClient = apiClient;
    }
    /**
        Sets inputs to steer music generation. Updates the session's current
        weighted prompts.
    
        @param params - Contains one property, `weightedPrompts`.
    
          - `weightedPrompts` to send to the model; weights are normalized to
            sum to 1.0.
    
        @experimental
       */
    async setWeightedPrompts(params) {
      if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {
        throw new Error("Weighted prompts must be set and contain at least one entry.");
      }
      const setWeightedPromptsParameters = liveMusicSetWeightedPromptsParametersToMldev(params);
      const clientContent = liveMusicClientContentToMldev(setWeightedPromptsParameters);
      this.conn.send(JSON.stringify({ clientContent }));
    }
    /**
        Sets a configuration to the model. Updates the session's current
        music generation config.
    
        @param params - Contains one property, `musicGenerationConfig`.
    
          - `musicGenerationConfig` to set in the model. Passing an empty or
        undefined config to the model will reset the config to defaults.
    
        @experimental
       */
    async setMusicGenerationConfig(params) {
      if (!params.musicGenerationConfig) {
        params.musicGenerationConfig = {};
      }
      const setConfigParameters = liveMusicSetConfigParametersToMldev(params);
      const clientMessage = liveMusicClientMessageToMldev(setConfigParameters);
      this.conn.send(JSON.stringify(clientMessage));
    }
    sendPlaybackControl(playbackControl) {
      const clientMessage = liveMusicClientMessageToMldev({
        playbackControl
      });
      this.conn.send(JSON.stringify(clientMessage));
    }
    /**
     * Start the music stream.
     *
     * @experimental
     */
    play() {
      this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);
    }
    /**
     * Temporarily halt the music stream. Use `play` to resume from the current
     * position.
     *
     * @experimental
     */
    pause() {
      this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);
    }
    /**
     * Stop the music stream and reset the state. Retains the current prompts
     * and config.
     *
     * @experimental
     */
    stop() {
      this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);
    }
    /**
     * Resets the context of the music generation without stopping it.
     * Retains the current prompts and config.
     *
     * @experimental
     */
    resetContext() {
      this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);
    }
    /**
         Terminates the WebSocket connection.
    
         @experimental
       */
    close() {
      this.conn.close();
    }
  };
  function headersToMap$1(headers) {
    const headerMap = {};
    headers.forEach((value, key) => {
      headerMap[key] = value;
    });
    return headerMap;
  }
  function mapToHeaders$1(map) {
    const headers = new Headers();
    for (const [key, value] of Object.entries(map)) {
      headers.append(key, value);
    }
    return headers;
  }
  var FUNCTION_RESPONSE_REQUIRES_ID = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
  async function handleWebSocketMessage(apiClient, onmessage, event) {
    const serverMessage = new LiveServerMessage();
    let jsonData;
    if (event.data instanceof Blob) {
      jsonData = await event.data.text();
    } else if (event.data instanceof ArrayBuffer) {
      jsonData = new TextDecoder().decode(event.data);
    } else {
      jsonData = event.data;
    }
    const data = JSON.parse(jsonData);
    if (apiClient.isVertexAI()) {
      const resp = liveServerMessageFromVertex(data);
      Object.assign(serverMessage, resp);
    } else {
      const resp = liveServerMessageFromMldev(data);
      Object.assign(serverMessage, resp);
    }
    onmessage(serverMessage);
  }
  var Live = class {
    constructor(apiClient, auth, webSocketFactory) {
      this.apiClient = apiClient;
      this.auth = auth;
      this.webSocketFactory = webSocketFactory;
      this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);
    }
    /**
         Establishes a connection to the specified model with the given
         configuration and returns a Session object representing that connection.
    
         @experimental Built-in MCP support is an experimental feature, may change in
         future versions.
    
         @remarks
    
         @param params - The parameters for establishing a connection to the model.
         @return A live session.
    
         @example
         ```ts
         let model: string;
         if (GOOGLE_GENAI_USE_VERTEXAI) {
           model = 'gemini-2.0-flash-live-preview-04-09';
         } else {
           model = 'gemini-live-2.5-flash-preview';
         }
         const session = await ai.live.connect({
           model: model,
           config: {
             responseModalities: [Modality.AUDIO],
           },
           callbacks: {
             onopen: () => {
               console.log('Connected to the socket.');
             },
             onmessage: (e: MessageEvent) => {
               console.log('Received message from the server: %s\n', debug(e.data));
             },
             onerror: (e: ErrorEvent) => {
               console.log('Error occurred: %s\n', debug(e.error));
             },
             onclose: (e: CloseEvent) => {
               console.log('Connection closed.');
             },
           },
         });
         ```
        */
    async connect(params) {
      var _a, _b, _c, _d, _e, _f;
      if (params.config && params.config.httpOptions) {
        throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead.");
      }
      const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
      const apiVersion = this.apiClient.getApiVersion();
      let url;
      const clientHeaders = this.apiClient.getHeaders();
      if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
        setMcpUsageHeader(clientHeaders);
      }
      const headers = mapToHeaders(clientHeaders);
      if (this.apiClient.isVertexAI()) {
        url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;
        await this.auth.addAuthHeaders(headers);
      } else {
        const apiKey = this.apiClient.getApiKey();
        let method = "BidiGenerateContent";
        let keyName = "key";
        if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith("auth_tokens/")) {
          console.warn("Warning: Ephemeral token support is experimental and may change in future versions.");
          if (apiVersion !== "v1alpha") {
            console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.");
          }
          method = "BidiGenerateContentConstrained";
          keyName = "access_token";
        }
        url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;
      }
      let onopenResolve = () => {
      };
      const onopenPromise = new Promise((resolve) => {
        onopenResolve = resolve;
      });
      const callbacks = params.callbacks;
      const onopenAwaitedCallback = function() {
        var _a2;
        (_a2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a2 === void 0 ? void 0 : _a2.call(callbacks);
        onopenResolve({});
      };
      const apiClient = this.apiClient;
      const websocketCallbacks = {
        onopen: onopenAwaitedCallback,
        onmessage: (event) => {
          void handleWebSocketMessage(apiClient, callbacks.onmessage, event);
        },
        onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {
        },
        onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
        }
      };
      const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);
      conn.connect();
      await onopenPromise;
      let transformedModel = tModel(this.apiClient, params.model);
      if (this.apiClient.isVertexAI() && transformedModel.startsWith("publishers/")) {
        const project = this.apiClient.getProject();
        const location = this.apiClient.getLocation();
        transformedModel = `projects/${project}/locations/${location}/` + transformedModel;
      }
      let clientMessage = {};
      if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === void 0) {
        if (params.config === void 0) {
          params.config = { responseModalities: [Modality.AUDIO] };
        } else {
          params.config.responseModalities = [Modality.AUDIO];
        }
      }
      if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {
        console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
      }
      const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];
      const convertedTools = [];
      for (const tool of inputTools) {
        if (this.isCallableTool(tool)) {
          const callableTool = tool;
          convertedTools.push(await callableTool.tool());
        } else {
          convertedTools.push(tool);
        }
      }
      if (convertedTools.length > 0) {
        params.config.tools = convertedTools;
      }
      const liveConnectParameters = {
        model: transformedModel,
        config: params.config,
        callbacks: params.callbacks
      };
      if (this.apiClient.isVertexAI()) {
        clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);
      } else {
        clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);
      }
      delete clientMessage["config"];
      conn.send(JSON.stringify(clientMessage));
      return new Session(conn, this.apiClient);
    }
    // TODO: b/416041229 - Abstract this method to a common place.
    isCallableTool(tool) {
      return "callTool" in tool && typeof tool.callTool === "function";
    }
  };
  var defaultLiveSendClientContentParamerters = {
    turnComplete: true
  };
  var Session = class {
    constructor(conn, apiClient) {
      this.conn = conn;
      this.apiClient = apiClient;
    }
    tLiveClientContent(apiClient, params) {
      if (params.turns !== null && params.turns !== void 0) {
        let contents = [];
        try {
          contents = tContents(params.turns);
          if (apiClient.isVertexAI()) {
            contents = contents.map((item) => contentToVertex(item));
          } else {
            contents = contents.map((item) => contentToMldev$1(item));
          }
        } catch (_a) {
          throw new Error(`Failed to parse client content "turns", type: '${typeof params.turns}'`);
        }
        return {
          clientContent: { turns: contents, turnComplete: params.turnComplete }
        };
      }
      return {
        clientContent: { turnComplete: params.turnComplete }
      };
    }
    tLiveClienttToolResponse(apiClient, params) {
      let functionResponses = [];
      if (params.functionResponses == null) {
        throw new Error("functionResponses is required.");
      }
      if (!Array.isArray(params.functionResponses)) {
        functionResponses = [params.functionResponses];
      } else {
        functionResponses = params.functionResponses;
      }
      if (functionResponses.length === 0) {
        throw new Error("functionResponses is required.");
      }
      for (const functionResponse of functionResponses) {
        if (typeof functionResponse !== "object" || functionResponse === null || !("name" in functionResponse) || !("response" in functionResponse)) {
          throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);
        }
        if (!apiClient.isVertexAI() && !("id" in functionResponse)) {
          throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);
        }
      }
      const clientMessage = {
        toolResponse: { functionResponses }
      };
      return clientMessage;
    }
    /**
        Send a message over the established connection.
    
        @param params - Contains two **optional** properties, `turns` and
            `turnComplete`.
    
          - `turns` will be converted to a `Content[]`
          - `turnComplete: true` [default] indicates that you are done sending
            content and expect a response. If `turnComplete: false`, the server
            will wait for additional messages before starting generation.
    
        @experimental
    
        @remarks
        There are two ways to send messages to the live API:
        `sendClientContent` and `sendRealtimeInput`.
    
        `sendClientContent` messages are added to the model context **in order**.
        Having a conversation using `sendClientContent` messages is roughly
        equivalent to using the `Chat.sendMessageStream`, except that the state of
        the `chat` history is stored on the API server instead of locally.
    
        Because of `sendClientContent`'s order guarantee, the model cannot respons
        as quickly to `sendClientContent` messages as to `sendRealtimeInput`
        messages. This makes the biggest difference when sending objects that have
        significant preprocessing time (typically images).
    
        The `sendClientContent` message sends a `Content[]`
        which has more options than the `Blob` sent by `sendRealtimeInput`.
    
        So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
    
        - Sending anything that can't be represented as a `Blob` (text,
        `sendClientContent({turns="Hello?"}`)).
        - Managing turns when not using audio input and voice activity detection.
          (`sendClientContent({turnComplete:true})` or the short form
        `sendClientContent()`)
        - Prefilling a conversation context
          ```
          sendClientContent({
              turns: [
                Content({role:user, parts:...}),
                Content({role:user, parts:...}),
                ...
              ]
          })
          ```
        @experimental
       */
    sendClientContent(params) {
      params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);
      const clientMessage = this.tLiveClientContent(this.apiClient, params);
      this.conn.send(JSON.stringify(clientMessage));
    }
    /**
        Send a realtime message over the established connection.
    
        @param params - Contains one property, `media`.
    
          - `media` will be converted to a `Blob`
    
        @experimental
    
        @remarks
        Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
    
        With `sendRealtimeInput` the api will respond to audio automatically
        based on voice activity detection (VAD).
    
        `sendRealtimeInput` is optimized for responsivness at the expense of
        deterministic ordering guarantees. Audio and video tokens are to the
        context when they become available.
    
        Note: The Call signature expects a `Blob` object, but only a subset
        of audio and image mimetypes are allowed.
       */
    sendRealtimeInput(params) {
      let clientMessage = {};
      if (this.apiClient.isVertexAI()) {
        clientMessage = {
          "realtimeInput": liveSendRealtimeInputParametersToVertex(params)
        };
      } else {
        clientMessage = {
          "realtimeInput": liveSendRealtimeInputParametersToMldev(params)
        };
      }
      this.conn.send(JSON.stringify(clientMessage));
    }
    /**
        Send a function response message over the established connection.
    
        @param params - Contains property `functionResponses`.
    
          - `functionResponses` will be converted to a `functionResponses[]`
    
        @remarks
        Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
    
        Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
    
        @experimental
       */
    sendToolResponse(params) {
      if (params.functionResponses == null) {
        throw new Error("Tool response parameters are required.");
      }
      const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);
      this.conn.send(JSON.stringify(clientMessage));
    }
    /**
         Terminates the WebSocket connection.
    
         @experimental
    
         @example
         ```ts
         let model: string;
         if (GOOGLE_GENAI_USE_VERTEXAI) {
           model = 'gemini-2.0-flash-live-preview-04-09';
         } else {
           model = 'gemini-live-2.5-flash-preview';
         }
         const session = await ai.live.connect({
           model: model,
           config: {
             responseModalities: [Modality.AUDIO],
           }
         });
    
         session.close();
         ```
       */
    close() {
      this.conn.close();
    }
  };
  function headersToMap(headers) {
    const headerMap = {};
    headers.forEach((value, key) => {
      headerMap[key] = value;
    });
    return headerMap;
  }
  function mapToHeaders(map) {
    const headers = new Headers();
    for (const [key, value] of Object.entries(map)) {
      headers.append(key, value);
    }
    return headers;
  }
  var DEFAULT_MAX_REMOTE_CALLS = 10;
  function shouldDisableAfc(config) {
    var _a, _b, _c;
    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {
      return true;
    }
    let callableToolsPresent = false;
    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {
      if (isCallableTool(tool)) {
        callableToolsPresent = true;
        break;
      }
    }
    if (!callableToolsPresent) {
      return true;
    }
    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;
    if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {
      console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", maxCalls);
      return true;
    }
    return false;
  }
  function isCallableTool(tool) {
    return "callTool" in tool && typeof tool.callTool === "function";
  }
  function hasCallableTools(params) {
    var _a, _b, _c;
    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
  }
  function hasNonCallableTools(params) {
    var _a, _b, _c;
    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => !isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
  }
  function shouldAppendAfcHistory(config) {
    var _a;
    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);
  }
  var Models = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
      this.generateContent = async (params) => {
        var _a, _b, _c, _d, _e;
        const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
        this.maybeMoveToResponseJsonSchem(params);
        if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {
          return await this.generateContentInternal(transformedParams);
        }
        if (hasNonCallableTools(params)) {
          throw new Error("Automatic function calling with CallableTools and Tools is not yet supported.");
        }
        let response;
        let functionResponseContent;
        const automaticFunctionCallingHistory = tContents(transformedParams.contents);
        const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
        let remoteCalls = 0;
        while (remoteCalls < maxRemoteCalls) {
          response = await this.generateContentInternal(transformedParams);
          if (!response.functionCalls || response.functionCalls.length === 0) {
            break;
          }
          const responseContent = response.candidates[0].content;
          const functionResponseParts = [];
          for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) {
            if (isCallableTool(tool)) {
              const callableTool = tool;
              const parts = await callableTool.callTool(response.functionCalls);
              functionResponseParts.push(...parts);
            }
          }
          remoteCalls++;
          functionResponseContent = {
            role: "user",
            parts: functionResponseParts
          };
          transformedParams.contents = tContents(transformedParams.contents);
          transformedParams.contents.push(responseContent);
          transformedParams.contents.push(functionResponseContent);
          if (shouldAppendAfcHistory(transformedParams.config)) {
            automaticFunctionCallingHistory.push(responseContent);
            automaticFunctionCallingHistory.push(functionResponseContent);
          }
        }
        if (shouldAppendAfcHistory(transformedParams.config)) {
          response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;
        }
        return response;
      };
      this.generateContentStream = async (params) => {
        this.maybeMoveToResponseJsonSchem(params);
        if (shouldDisableAfc(params.config)) {
          const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
          return await this.generateContentStreamInternal(transformedParams);
        } else {
          return await this.processAfcStream(params);
        }
      };
      this.generateImages = async (params) => {
        return await this.generateImagesInternal(params).then((apiResponse) => {
          var _a;
          let positivePromptSafetyAttributes;
          const generatedImages = [];
          if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {
            for (const generatedImage of apiResponse.generatedImages) {
              if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === "Positive Prompt") {
                positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;
              } else {
                generatedImages.push(generatedImage);
              }
            }
          }
          let response;
          if (positivePromptSafetyAttributes) {
            response = {
              generatedImages,
              positivePromptSafetyAttributes,
              sdkHttpResponse: apiResponse.sdkHttpResponse
            };
          } else {
            response = {
              generatedImages,
              sdkHttpResponse: apiResponse.sdkHttpResponse
            };
          }
          return response;
        });
      };
      this.list = async (params) => {
        var _a;
        const defaultConfig = {
          queryBase: true
        };
        const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);
        const actualParams = {
          config: actualConfig
        };
        if (this.apiClient.isVertexAI()) {
          if (!actualParams.config.queryBase) {
            if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {
              throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
            } else {
              actualParams.config.filter = "labels.tune-type:*";
            }
          }
        }
        return new Pager(PagedItem.PAGED_ITEM_MODELS, (x3) => this.listInternal(x3), await this.listInternal(actualParams), actualParams);
      };
      this.editImage = async (params) => {
        const paramsInternal = {
          model: params.model,
          prompt: params.prompt,
          referenceImages: [],
          config: params.config
        };
        if (params.referenceImages) {
          if (params.referenceImages) {
            paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());
          }
        }
        return await this.editImageInternal(paramsInternal);
      };
      this.upscaleImage = async (params) => {
        let apiConfig = {
          numberOfImages: 1,
          mode: "upscale"
        };
        if (params.config) {
          apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);
        }
        const apiParams = {
          model: params.model,
          image: params.image,
          upscaleFactor: params.upscaleFactor,
          config: apiConfig
        };
        return await this.upscaleImageInternal(apiParams);
      };
      this.generateVideos = async (params) => {
        if ((params.prompt || params.image || params.video) && params.source) {
          throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source.");
        }
        return await this.generateVideosInternal(params);
      };
    }
    /**
     * This logic is needed for GenerateContentConfig only.
     * Previously we made GenerateContentConfig.responseSchema field to accept
     * unknown. Since v1.9.0, we switch to use backend JSON schema support.
     * To maintain backward compatibility, we move the data that was treated as
     * JSON schema from the responseSchema field to the responseJsonSchema field.
     */
    maybeMoveToResponseJsonSchem(params) {
      if (params.config && params.config.responseSchema) {
        if (!params.config.responseJsonSchema) {
          if (Object.keys(params.config.responseSchema).includes("$schema")) {
            params.config.responseJsonSchema = params.config.responseSchema;
            delete params.config.responseSchema;
          }
        }
      }
      return;
    }
    /**
     * Transforms the CallableTools in the parameters to be simply Tools, it
     * copies the params into a new object and replaces the tools, it does not
     * modify the original params. Also sets the MCP usage header if there are
     * MCP tools in the parameters.
     */
    async processParamsMaybeAddMcpUsage(params) {
      var _a, _b, _c;
      const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;
      if (!tools) {
        return params;
      }
      const transformedTools = await Promise.all(tools.map(async (tool) => {
        if (isCallableTool(tool)) {
          const callableTool = tool;
          return await callableTool.tool();
        }
        return tool;
      }));
      const newParams = {
        model: params.model,
        contents: params.contents,
        config: Object.assign(Object.assign({}, params.config), { tools: transformedTools })
      };
      newParams.config.tools = transformedTools;
      if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
        const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};
        let newHeaders = Object.assign({}, headers);
        if (Object.keys(newHeaders).length === 0) {
          newHeaders = this.apiClient.getDefaultHeaders();
        }
        setMcpUsageHeader(newHeaders);
        newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });
      }
      return newParams;
    }
    async initAfcToolsMap(params) {
      var _a, _b, _c;
      const afcTools = /* @__PURE__ */ new Map();
      for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []) {
        if (isCallableTool(tool)) {
          const callableTool = tool;
          const toolDeclaration = await callableTool.tool();
          for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {
            if (!declaration.name) {
              throw new Error("Function declaration name is required.");
            }
            if (afcTools.has(declaration.name)) {
              throw new Error(`Duplicate tool declaration name: ${declaration.name}`);
            }
            afcTools.set(declaration.name, callableTool);
          }
        }
      }
      return afcTools;
    }
    async processAfcStream(params) {
      var _a, _b, _c;
      const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
      let wereFunctionsCalled = false;
      let remoteCallCount = 0;
      const afcToolsMap = await this.initAfcToolsMap(params);
      return (function(models, afcTools, params2) {
        var _a2, _b2;
        return __asyncGenerator(this, arguments, function* () {
          var _c2, e_1, _d, _e;
          while (remoteCallCount < maxRemoteCalls) {
            if (wereFunctionsCalled) {
              remoteCallCount++;
              wereFunctionsCalled = false;
            }
            const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params2));
            const response = yield __await(models.generateContentStreamInternal(transformedParams));
            const functionResponses = [];
            const responseContents = [];
            try {
              for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c2 = response_1_1.done, !_c2; _f = true) {
                _e = response_1_1.value;
                _f = false;
                const chunk = _e;
                yield yield __await(chunk);
                if (chunk.candidates && ((_a2 = chunk.candidates[0]) === null || _a2 === void 0 ? void 0 : _a2.content)) {
                  responseContents.push(chunk.candidates[0].content);
                  for (const part of (_b2 = chunk.candidates[0].content.parts) !== null && _b2 !== void 0 ? _b2 : []) {
                    if (remoteCallCount < maxRemoteCalls && part.functionCall) {
                      if (!part.functionCall.name) {
                        throw new Error("Function call name was not returned by the model.");
                      }
                      if (!afcTools.has(part.functionCall.name)) {
                        throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);
                      } else {
                        const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([part.functionCall]));
                        functionResponses.push(...responseParts);
                      }
                    }
                  }
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (!_f && !_c2 && (_d = response_1.return)) yield __await(_d.call(response_1));
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            if (functionResponses.length > 0) {
              wereFunctionsCalled = true;
              const typedResponseChunk = new GenerateContentResponse();
              typedResponseChunk.candidates = [
                {
                  content: {
                    role: "user",
                    parts: functionResponses
                  }
                }
              ];
              yield yield __await(typedResponseChunk);
              const newContents = [];
              newContents.push(...responseContents);
              newContents.push({
                role: "user",
                parts: functionResponses
              });
              const updatedContents = tContents(params2.contents).concat(newContents);
              params2.contents = updatedContents;
            } else {
              break;
            }
          }
        });
      })(this, afcToolsMap, params);
    }
    async generateContentInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = generateContentParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:generateContent", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = generateContentResponseFromVertex(apiResponse);
          const typedResp = new GenerateContentResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = generateContentParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:generateContent", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = generateContentResponseFromMldev(apiResponse);
          const typedResp = new GenerateContentResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    async generateContentStreamInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = generateContentParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        const apiClient = this.apiClient;
        response = apiClient.requestStream({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        });
        return response.then(function(apiResponse) {
          return __asyncGenerator(this, arguments, function* () {
            var _a2, e_2, _b2, _c2;
            try {
              for (var _d2 = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a2 = apiResponse_1_1.done, !_a2; _d2 = true) {
                _c2 = apiResponse_1_1.value;
                _d2 = false;
                const chunk = _c2;
                const resp = generateContentResponseFromVertex(yield __await(chunk.json()));
                resp["sdkHttpResponse"] = {
                  headers: chunk.headers
                };
                const typedResp = new GenerateContentResponse();
                Object.assign(typedResp, resp);
                yield yield __await(typedResp);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (!_d2 && !_a2 && (_b2 = apiResponse_1.return)) yield __await(_b2.call(apiResponse_1));
              } finally {
                if (e_2) throw e_2.error;
              }
            }
          });
        });
      } else {
        const body = generateContentParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        const apiClient = this.apiClient;
        response = apiClient.requestStream({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        });
        return response.then(function(apiResponse) {
          return __asyncGenerator(this, arguments, function* () {
            var _a2, e_3, _b2, _c2;
            try {
              for (var _d2 = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a2 = apiResponse_2_1.done, !_a2; _d2 = true) {
                _c2 = apiResponse_2_1.value;
                _d2 = false;
                const chunk = _c2;
                const resp = generateContentResponseFromMldev(yield __await(chunk.json()));
                resp["sdkHttpResponse"] = {
                  headers: chunk.headers
                };
                const typedResp = new GenerateContentResponse();
                Object.assign(typedResp, resp);
                yield yield __await(typedResp);
              }
            } catch (e_3_1) {
              e_3 = { error: e_3_1 };
            } finally {
              try {
                if (!_d2 && !_a2 && (_b2 = apiResponse_2.return)) yield __await(_b2.call(apiResponse_2));
              } finally {
                if (e_3) throw e_3.error;
              }
            }
          });
        });
      }
    }
    /**
     * Calculates embeddings for the given contents. Only text is supported.
     *
     * @param params - The parameters for embedding contents.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response = await ai.models.embedContent({
     *  model: 'text-embedding-004',
     *  contents: [
     *    'What is your name?',
     *    'What is your favorite color?',
     *  ],
     *  config: {
     *    outputDimensionality: 64,
     *  },
     * });
     * console.log(response);
     * ```
     */
    async embedContent(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = embedContentParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = embedContentResponseFromVertex(apiResponse);
          const typedResp = new EmbedContentResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = embedContentParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:batchEmbedContents", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = embedContentResponseFromMldev(apiResponse);
          const typedResp = new EmbedContentResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Private method for generating images.
     */
    async generateImagesInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = generateImagesParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = generateImagesResponseFromVertex(apiResponse);
          const typedResp = new GenerateImagesResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = generateImagesParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = generateImagesResponseFromMldev(apiResponse);
          const typedResp = new GenerateImagesResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Private method for editing an image.
     */
    async editImageInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = editImageParametersInternalToVertex(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = editImageResponseFromVertex(apiResponse);
          const typedResp = new EditImageResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
    /**
     * Private method for upscaling an image.
     */
    async upscaleImageInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = upscaleImageResponseFromVertex(apiResponse);
          const typedResp = new UpscaleImageResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
    /**
     * Recontextualizes an image.
     *
     * There are two types of recontextualization currently supported:
     * 1) Imagen Product Recontext - Generate images of products in new scenes
     *    and contexts.
     * 2) Virtual Try-On: Generate images of persons modeling fashion products.
     *
     * @param params - The parameters for recontextualizing an image.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response1 = await ai.models.recontextImage({
     *  model: 'imagen-product-recontext-preview-06-30',
     *  source: {
     *    prompt: 'In a modern kitchen setting.',
     *    productImages: [productImage],
     *  },
     *  config: {
     *    numberOfImages: 1,
     *  },
     * });
     * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);
     *
     * const response2 = await ai.models.recontextImage({
     *  model: 'virtual-try-on-preview-08-04',
     *  source: {
     *    personImage: personImage,
     *    productImages: [productImage],
     *  },
     *  config: {
     *    numberOfImages: 1,
     *  },
     * });
     * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);
     * ```
     */
    async recontextImage(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = recontextImageParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = recontextImageResponseFromVertex(apiResponse);
          const typedResp = new RecontextImageResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
    /**
     * Segments an image, creating a mask of a specified area.
     *
     * @param params - The parameters for segmenting an image.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response = await ai.models.segmentImage({
     *  model: 'image-segmentation-001',
     *  source: {
     *    image: image,
     *  },
     *  config: {
     *    mode: 'foreground',
     *  },
     * });
     * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);
     * ```
     */
    async segmentImage(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = segmentImageParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:predict", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = segmentImageResponseFromVertex(apiResponse);
          const typedResp = new SegmentImageResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
    /**
     * Fetches information about a model by name.
     *
     * @example
     * ```ts
     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
     * ```
     */
    async get(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = getModelParametersToVertex(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = modelFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = getModelParametersToMldev(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = modelFromMldev(apiResponse);
          return resp;
        });
      }
    }
    async listInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = listModelsParametersToVertex(this.apiClient, params);
        path = formatMap("{models_url}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listModelsResponseFromVertex(apiResponse);
          const typedResp = new ListModelsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = listModelsParametersToMldev(this.apiClient, params);
        path = formatMap("{models_url}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listModelsResponseFromMldev(apiResponse);
          const typedResp = new ListModelsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Updates a tuned model by its name.
     *
     * @param params - The parameters for updating the model.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response = await ai.models.update({
     *   model: 'tuned-model-name',
     *   config: {
     *     displayName: 'New display name',
     *     description: 'New description',
     *   },
     * });
     * ```
     */
    async update(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = updateModelParametersToVertex(this.apiClient, params);
        path = formatMap("{model}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "PATCH",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = modelFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = updateModelParametersToMldev(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "PATCH",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = modelFromMldev(apiResponse);
          return resp;
        });
      }
    }
    /**
     * Deletes a tuned model by its name.
     *
     * @param params - The parameters for deleting the model.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response = await ai.models.delete({model: 'tuned-model-name'});
     * ```
     */
    async delete(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = deleteModelParametersToVertex(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteModelResponseFromVertex(apiResponse);
          const typedResp = new DeleteModelResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = deleteModelParametersToMldev(this.apiClient, params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "DELETE",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = deleteModelResponseFromMldev(apiResponse);
          const typedResp = new DeleteModelResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Counts the number of tokens in the given contents. Multimodal input is
     * supported for Gemini models.
     *
     * @param params - The parameters for counting tokens.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response = await ai.models.countTokens({
     *  model: 'gemini-2.0-flash',
     *  contents: 'The quick brown fox jumps over the lazy dog.'
     * });
     * console.log(response);
     * ```
     */
    async countTokens(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = countTokensParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:countTokens", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = countTokensResponseFromVertex(apiResponse);
          const typedResp = new CountTokensResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = countTokensParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:countTokens", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = countTokensResponseFromMldev(apiResponse);
          const typedResp = new CountTokensResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Given a list of contents, returns a corresponding TokensInfo containing
     * the list of tokens and list of token ids.
     *
     * This method is not supported by the Gemini Developer API.
     *
     * @param params - The parameters for computing tokens.
     * @return The response from the API.
     *
     * @example
     * ```ts
     * const response = await ai.models.computeTokens({
     *  model: 'gemini-2.0-flash',
     *  contents: 'What is your name?'
     * });
     * console.log(response);
     * ```
     */
    async computeTokens(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = computeTokensParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:computeTokens", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = computeTokensResponseFromVertex(apiResponse);
          const typedResp = new ComputeTokensResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
    /**
     * Private method for generating videos.
     */
    async generateVideosInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = generateVideosParametersToVertex(this.apiClient, params);
        path = formatMap("{model}:predictLongRunning", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = generateVideosOperationFromVertex(apiResponse);
          const typedResp = new GenerateVideosOperation();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = generateVideosParametersToMldev(this.apiClient, params);
        path = formatMap("{model}:predictLongRunning", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = generateVideosOperationFromMldev(apiResponse);
          const typedResp = new GenerateVideosOperation();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
  };
  var Operations = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
    }
    /**
     * Gets the status of a long-running operation.
     *
     * @param parameters The parameters for the get operation request.
     * @return The updated Operation object, with the latest status or result.
     */
    async getVideosOperation(parameters) {
      const operation = parameters.operation;
      const config = parameters.config;
      if (operation.name === void 0 || operation.name === "") {
        throw new Error("Operation name is required.");
      }
      if (this.apiClient.isVertexAI()) {
        const resourceName2 = operation.name.split("/operations/")[0];
        let httpOptions = void 0;
        if (config && "httpOptions" in config) {
          httpOptions = config.httpOptions;
        }
        const rawOperation = await this.fetchPredictVideosOperationInternal({
          operationName: operation.name,
          resourceName: resourceName2,
          config: { httpOptions }
        });
        return operation._fromAPIResponse({
          apiResponse: rawOperation,
          isVertexAI: true
        });
      } else {
        const rawOperation = await this.getVideosOperationInternal({
          operationName: operation.name,
          config
        });
        return operation._fromAPIResponse({
          apiResponse: rawOperation,
          isVertexAI: false
        });
      }
    }
    /**
     * Gets the status of a long-running operation.
     *
     * @param parameters The parameters for the get operation request.
     * @return The updated Operation object, with the latest status or result.
     */
    async get(parameters) {
      const operation = parameters.operation;
      const config = parameters.config;
      if (operation.name === void 0 || operation.name === "") {
        throw new Error("Operation name is required.");
      }
      if (this.apiClient.isVertexAI()) {
        const resourceName2 = operation.name.split("/operations/")[0];
        let httpOptions = void 0;
        if (config && "httpOptions" in config) {
          httpOptions = config.httpOptions;
        }
        const rawOperation = await this.fetchPredictVideosOperationInternal({
          operationName: operation.name,
          resourceName: resourceName2,
          config: { httpOptions }
        });
        return operation._fromAPIResponse({
          apiResponse: rawOperation,
          isVertexAI: true
        });
      } else {
        const rawOperation = await this.getVideosOperationInternal({
          operationName: operation.name,
          config
        });
        return operation._fromAPIResponse({
          apiResponse: rawOperation,
          isVertexAI: false
        });
      }
    }
    async getVideosOperationInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = getOperationParametersToVertex(params);
        path = formatMap("{operationName}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response;
      } else {
        const body = getOperationParametersToMldev(params);
        path = formatMap("{operationName}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response;
      }
    }
    async fetchPredictVideosOperationInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = fetchPredictOperationParametersToVertex(params);
        path = formatMap("{resourceName}:fetchPredictOperation", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response;
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
  };
  function audioTranscriptionConfigToMldev() {
    const toObject = {};
    return toObject;
  }
  function authTokenFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function automaticActivityDetectionToMldev(fromObject) {
    const toObject = {};
    const fromDisabled = getValueByPath(fromObject, ["disabled"]);
    if (fromDisabled != null) {
      setValueByPath(toObject, ["disabled"], fromDisabled);
    }
    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [
      "startOfSpeechSensitivity"
    ]);
    if (fromStartOfSpeechSensitivity != null) {
      setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
    }
    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [
      "endOfSpeechSensitivity"
    ]);
    if (fromEndOfSpeechSensitivity != null) {
      setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
    }
    const fromPrefixPaddingMs = getValueByPath(fromObject, [
      "prefixPaddingMs"
    ]);
    if (fromPrefixPaddingMs != null) {
      setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
    }
    const fromSilenceDurationMs = getValueByPath(fromObject, [
      "silenceDurationMs"
    ]);
    if (fromSilenceDurationMs != null) {
      setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
    }
    return toObject;
  }
  function blobToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function contentToMldev(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function contextWindowCompressionConfigToMldev(fromObject) {
    const toObject = {};
    const fromTriggerTokens = getValueByPath(fromObject, [
      "triggerTokens"
    ]);
    if (fromTriggerTokens != null) {
      setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
    }
    const fromSlidingWindow = getValueByPath(fromObject, [
      "slidingWindow"
    ]);
    if (fromSlidingWindow != null) {
      setValueByPath(toObject, ["slidingWindow"], slidingWindowToMldev(fromSlidingWindow));
    }
    return toObject;
  }
  function createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    const fromNewSessionExpireTime = getValueByPath(fromObject, [
      "newSessionExpireTime"
    ]);
    if (parentObject !== void 0 && fromNewSessionExpireTime != null) {
      setValueByPath(parentObject, ["newSessionExpireTime"], fromNewSessionExpireTime);
    }
    const fromUses = getValueByPath(fromObject, ["uses"]);
    if (parentObject !== void 0 && fromUses != null) {
      setValueByPath(parentObject, ["uses"], fromUses);
    }
    const fromLiveConnectConstraints = getValueByPath(fromObject, [
      "liveConnectConstraints"
    ]);
    if (parentObject !== void 0 && fromLiveConnectConstraints != null) {
      setValueByPath(parentObject, ["bidiGenerateContentSetup"], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));
    }
    const fromLockAdditionalFields = getValueByPath(fromObject, [
      "lockAdditionalFields"
    ]);
    if (parentObject !== void 0 && fromLockAdditionalFields != null) {
      setValueByPath(parentObject, ["fieldMask"], fromLockAdditionalFields);
    }
    return toObject;
  }
  function createAuthTokenParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function dynamicRetrievalConfigToMldev(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromDynamicThreshold = getValueByPath(fromObject, [
      "dynamicThreshold"
    ]);
    if (fromDynamicThreshold != null) {
      setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
    }
    return toObject;
  }
  function fileDataToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallToMldev(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    return toObject;
  }
  function functionDeclarationToMldev(fromObject) {
    const toObject = {};
    const fromBehavior = getValueByPath(fromObject, ["behavior"]);
    if (fromBehavior != null) {
      setValueByPath(toObject, ["behavior"], fromBehavior);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function googleSearchRetrievalToMldev(fromObject) {
    const toObject = {};
    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [
      "dynamicRetrievalConfig"
    ]);
    if (fromDynamicRetrievalConfig != null) {
      setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev(fromDynamicRetrievalConfig));
    }
    return toObject;
  }
  function googleSearchToMldev(fromObject) {
    const toObject = {};
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], intervalToMldev(fromTimeRangeFilter));
    }
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function intervalToMldev(fromObject) {
    const toObject = {};
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    return toObject;
  }
  function liveConnectConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (parentObject !== void 0 && fromResponseModalities != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (parentObject !== void 0 && fromTemperature != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (parentObject !== void 0 && fromTopP != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (parentObject !== void 0 && fromTopK != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (parentObject !== void 0 && fromMaxOutputTokens != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (parentObject !== void 0 && fromMediaResolution != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (parentObject !== void 0 && fromSpeechConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToMldev(tLiveSpeechConfig(fromSpeechConfig)));
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev(tContent(fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev(tTool(item));
        });
      }
      setValueByPath(parentObject, ["setup", "tools"], transformedList);
    }
    const fromSessionResumption = getValueByPath(fromObject, [
      "sessionResumption"
    ]);
    if (parentObject !== void 0 && fromSessionResumption != null) {
      setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev(fromSessionResumption));
    }
    const fromInputAudioTranscription = getValueByPath(fromObject, [
      "inputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromInputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "inputAudioTranscription"], audioTranscriptionConfigToMldev());
    }
    const fromOutputAudioTranscription = getValueByPath(fromObject, [
      "outputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToMldev());
    }
    const fromRealtimeInputConfig = getValueByPath(fromObject, [
      "realtimeInputConfig"
    ]);
    if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
      setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToMldev(fromRealtimeInputConfig));
    }
    const fromContextWindowCompression = getValueByPath(fromObject, [
      "contextWindowCompression"
    ]);
    if (parentObject !== void 0 && fromContextWindowCompression != null) {
      setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToMldev(fromContextWindowCompression));
    }
    const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
    if (parentObject !== void 0 && fromProactivity != null) {
      setValueByPath(parentObject, ["setup", "proactivity"], proactivityConfigToMldev(fromProactivity));
    }
    return toObject;
  }
  function liveConnectConstraintsToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], liveConnectConfigToMldev(fromConfig, toObject));
    }
    return toObject;
  }
  function multiSpeakerVoiceConfigToMldev(fromObject) {
    const toObject = {};
    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [
      "speakerVoiceConfigs"
    ]);
    if (fromSpeakerVoiceConfigs != null) {
      let transformedList = fromSpeakerVoiceConfigs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return speakerVoiceConfigToMldev(item);
        });
      }
      setValueByPath(toObject, ["speakerVoiceConfigs"], transformedList);
    }
    return toObject;
  }
  function partToMldev(fromObject) {
    const toObject = {};
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], videoMetadataToMldev(fromVideoMetadata));
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev(fromInlineData));
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev(fromFileData));
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev(fromFunctionCall));
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    return toObject;
  }
  function prebuiltVoiceConfigToMldev(fromObject) {
    const toObject = {};
    const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
    if (fromVoiceName != null) {
      setValueByPath(toObject, ["voiceName"], fromVoiceName);
    }
    return toObject;
  }
  function proactivityConfigToMldev(fromObject) {
    const toObject = {};
    const fromProactiveAudio = getValueByPath(fromObject, [
      "proactiveAudio"
    ]);
    if (fromProactiveAudio != null) {
      setValueByPath(toObject, ["proactiveAudio"], fromProactiveAudio);
    }
    return toObject;
  }
  function realtimeInputConfigToMldev(fromObject) {
    const toObject = {};
    const fromAutomaticActivityDetection = getValueByPath(fromObject, [
      "automaticActivityDetection"
    ]);
    if (fromAutomaticActivityDetection != null) {
      setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToMldev(fromAutomaticActivityDetection));
    }
    const fromActivityHandling = getValueByPath(fromObject, [
      "activityHandling"
    ]);
    if (fromActivityHandling != null) {
      setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
    }
    const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
    if (fromTurnCoverage != null) {
      setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
    }
    return toObject;
  }
  function sessionResumptionConfigToMldev(fromObject) {
    const toObject = {};
    const fromHandle = getValueByPath(fromObject, ["handle"]);
    if (fromHandle != null) {
      setValueByPath(toObject, ["handle"], fromHandle);
    }
    if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
      throw new Error("transparent parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function slidingWindowToMldev(fromObject) {
    const toObject = {};
    const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
    if (fromTargetTokens != null) {
      setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
    }
    return toObject;
  }
  function speakerVoiceConfigToMldev(fromObject) {
    const toObject = {};
    const fromSpeaker = getValueByPath(fromObject, ["speaker"]);
    if (fromSpeaker != null) {
      setValueByPath(toObject, ["speaker"], fromSpeaker);
    }
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev(fromVoiceConfig));
    }
    return toObject;
  }
  function speechConfigToMldev(fromObject) {
    const toObject = {};
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev(fromVoiceConfig));
    }
    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [
      "multiSpeakerVoiceConfig"
    ]);
    if (fromMultiSpeakerVoiceConfig != null) {
      setValueByPath(toObject, ["multiSpeakerVoiceConfig"], multiSpeakerVoiceConfigToMldev(fromMultiSpeakerVoiceConfig));
    }
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    return toObject;
  }
  function toolComputerUseToMldev(fromObject) {
    const toObject = {};
    const fromEnvironment = getValueByPath(fromObject, ["environment"]);
    if (fromEnvironment != null) {
      setValueByPath(toObject, ["environment"], fromEnvironment);
    }
    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [
      "excludedPredefinedFunctions"
    ]);
    if (fromExcludedPredefinedFunctions != null) {
      setValueByPath(toObject, ["excludedPredefinedFunctions"], fromExcludedPredefinedFunctions);
    }
    return toObject;
  }
  function toolToMldev(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToMldev(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev(fromGoogleSearch));
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev(fromGoogleSearchRetrieval));
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["googleMaps"]) !== void 0) {
      throw new Error("googleMaps parameter is not supported in Gemini API.");
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], urlContextToMldev());
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], toolComputerUseToMldev(fromComputerUse));
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    return toObject;
  }
  function urlContextToMldev() {
    const toObject = {};
    return toObject;
  }
  function videoMetadataToMldev(fromObject) {
    const toObject = {};
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (fromFps != null) {
      setValueByPath(toObject, ["fps"], fromFps);
    }
    const fromEndOffset = getValueByPath(fromObject, ["endOffset"]);
    if (fromEndOffset != null) {
      setValueByPath(toObject, ["endOffset"], fromEndOffset);
    }
    const fromStartOffset = getValueByPath(fromObject, ["startOffset"]);
    if (fromStartOffset != null) {
      setValueByPath(toObject, ["startOffset"], fromStartOffset);
    }
    return toObject;
  }
  function voiceConfigToMldev(fromObject) {
    const toObject = {};
    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [
      "prebuiltVoiceConfig"
    ]);
    if (fromPrebuiltVoiceConfig != null) {
      setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev(fromPrebuiltVoiceConfig));
    }
    return toObject;
  }
  function getFieldMasks(setup) {
    const fields = [];
    for (const key in setup) {
      if (Object.prototype.hasOwnProperty.call(setup, key)) {
        const value = setup[key];
        if (typeof value === "object" && value != null && Object.keys(value).length > 0) {
          const field = Object.keys(value).map((kk) => `${key}.${kk}`);
          fields.push(...field);
        } else {
          fields.push(key);
        }
      }
    }
    return fields.join(",");
  }
  function convertBidiSetupToTokenSetup(requestDict, config) {
    let setupForMaskGeneration = null;
    const bidiGenerateContentSetupValue = requestDict["bidiGenerateContentSetup"];
    if (typeof bidiGenerateContentSetupValue === "object" && bidiGenerateContentSetupValue !== null && "setup" in bidiGenerateContentSetupValue) {
      const innerSetup = bidiGenerateContentSetupValue.setup;
      if (typeof innerSetup === "object" && innerSetup !== null) {
        requestDict["bidiGenerateContentSetup"] = innerSetup;
        setupForMaskGeneration = innerSetup;
      } else {
        delete requestDict["bidiGenerateContentSetup"];
      }
    } else if (bidiGenerateContentSetupValue !== void 0) {
      delete requestDict["bidiGenerateContentSetup"];
    }
    const preExistingFieldMask = requestDict["fieldMask"];
    if (setupForMaskGeneration) {
      const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);
      if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {
        if (generatedMaskFromBidi) {
          requestDict["fieldMask"] = generatedMaskFromBidi;
        } else {
          delete requestDict["fieldMask"];
        }
      } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
        const generationConfigFields = [
          "temperature",
          "topK",
          "topP",
          "maxOutputTokens",
          "responseModalities",
          "seed",
          "speechConfig"
        ];
        let mappedFieldsFromPreExisting = [];
        if (preExistingFieldMask.length > 0) {
          mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {
            if (generationConfigFields.includes(field)) {
              return `generationConfig.${field}`;
            }
            return field;
          });
        }
        const finalMaskParts = [];
        if (generatedMaskFromBidi) {
          finalMaskParts.push(generatedMaskFromBidi);
        }
        if (mappedFieldsFromPreExisting.length > 0) {
          finalMaskParts.push(...mappedFieldsFromPreExisting);
        }
        if (finalMaskParts.length > 0) {
          requestDict["fieldMask"] = finalMaskParts.join(",");
        } else {
          delete requestDict["fieldMask"];
        }
      } else {
        delete requestDict["fieldMask"];
      }
    } else {
      if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
        requestDict["fieldMask"] = preExistingFieldMask.join(",");
      } else {
        delete requestDict["fieldMask"];
      }
    }
    return requestDict;
  }
  var Tokens = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
    }
    /**
     * Creates an ephemeral auth token resource.
     *
     * @experimental
     *
     * @remarks
     * Ephemeral auth tokens is only supported in the Gemini Developer API.
     * It can be used for the session connection to the Live constrained API.
     * Support in v1alpha only.
     *
     * @param params - The parameters for the create request.
     * @return The created auth token.
     *
     * @example
     * ```ts
     * const ai = new GoogleGenAI({
     *     apiKey: token.name,
     *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.
     * });
     *
     * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig
     * // when using the token in Live API sessions. Each session connection can
     * // use a different configuration.
     * const config: CreateAuthTokenConfig = {
     *     uses: 3,
     *     expireTime: '2025-05-01T00:00:00Z',
     * }
     * const token = await ai.tokens.create(config);
     *
     * // Case 2: If LiveEphemeralParameters is set, lock all fields in
     * // LiveConnectConfig when using the token in Live API sessions. For
     * // example, changing `outputAudioTranscription` in the Live API
     * // connection will be ignored by the API.
     * const config: CreateAuthTokenConfig =
     *     uses: 3,
     *     expireTime: '2025-05-01T00:00:00Z',
     *     LiveEphemeralParameters: {
     *        model: 'gemini-2.0-flash-001',
     *        config: {
     *           'responseModalities': ['AUDIO'],
     *           'systemInstruction': 'Always answer in English.',
     *        }
     *     }
     * }
     * const token = await ai.tokens.create(config);
     *
     * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is
     * // set, lock LiveConnectConfig with set and additional fields (e.g.
     * // responseModalities, systemInstruction, temperature in this example) when
     * // using the token in Live API sessions.
     * const config: CreateAuthTokenConfig =
     *     uses: 3,
     *     expireTime: '2025-05-01T00:00:00Z',
     *     LiveEphemeralParameters: {
     *        model: 'gemini-2.0-flash-001',
     *        config: {
     *           'responseModalities': ['AUDIO'],
     *           'systemInstruction': 'Always answer in English.',
     *        }
     *     },
     *     lockAdditionalFields: ['temperature'],
     * }
     * const token = await ai.tokens.create(config);
     *
     * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is
     * // empty array, lock LiveConnectConfig with set fields (e.g.
     * // responseModalities, systemInstruction in this example) when using the
     * // token in Live API sessions.
     * const config: CreateAuthTokenConfig =
     *     uses: 3,
     *     expireTime: '2025-05-01T00:00:00Z',
     *     LiveEphemeralParameters: {
     *        model: 'gemini-2.0-flash-001',
     *        config: {
     *           'responseModalities': ['AUDIO'],
     *           'systemInstruction': 'Always answer in English.',
     *        }
     *     },
     *     lockAdditionalFields: [],
     * }
     * const token = await ai.tokens.create(config);
     * ```
     */
    async create(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");
      } else {
        const body = createAuthTokenParametersToMldev(this.apiClient, params);
        path = formatMap("auth_tokens", body["_url"]);
        queryParams = body["_query"];
        delete body["config"];
        delete body["_url"];
        delete body["_query"];
        const transformedBody = convertBidiSetupToTokenSetup(body, params.config);
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(transformedBody),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json();
        });
        return response.then((apiResponse) => {
          const resp = authTokenFromMldev(apiResponse);
          return resp;
        });
      }
    }
  };
  function cancelTuningJobParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function cancelTuningJobParametersToVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function createTuningJobConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["validationDataset"]) !== void 0) {
      throw new Error("validationDataset parameter is not supported in Gemini API.");
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromTunedModelDisplayName);
    }
    if (getValueByPath(fromObject, ["description"]) !== void 0) {
      throw new Error("description parameter is not supported in Gemini API.");
    }
    const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
    if (parentObject !== void 0 && fromEpochCount != null) {
      setValueByPath(parentObject, ["tuningTask", "hyperparameters", "epochCount"], fromEpochCount);
    }
    const fromLearningRateMultiplier = getValueByPath(fromObject, [
      "learningRateMultiplier"
    ]);
    if (fromLearningRateMultiplier != null) {
      setValueByPath(toObject, ["tuningTask", "hyperparameters", "learningRateMultiplier"], fromLearningRateMultiplier);
    }
    if (getValueByPath(fromObject, ["exportLastCheckpointOnly"]) !== void 0) {
      throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["preTunedModelCheckpointId"]) !== void 0) {
      throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["adapterSize"]) !== void 0) {
      throw new Error("adapterSize parameter is not supported in Gemini API.");
    }
    const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
    if (parentObject !== void 0 && fromBatchSize != null) {
      setValueByPath(parentObject, ["tuningTask", "hyperparameters", "batchSize"], fromBatchSize);
    }
    const fromLearningRate = getValueByPath(fromObject, ["learningRate"]);
    if (parentObject !== void 0 && fromLearningRate != null) {
      setValueByPath(parentObject, ["tuningTask", "hyperparameters", "learningRate"], fromLearningRate);
    }
    if (getValueByPath(fromObject, ["labels"]) !== void 0) {
      throw new Error("labels parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function createTuningJobConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromValidationDataset = getValueByPath(fromObject, [
      "validationDataset"
    ]);
    if (parentObject !== void 0 && fromValidationDataset != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec"], tuningValidationDatasetToVertex(fromValidationDataset, toObject));
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
      setValueByPath(parentObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (parentObject !== void 0 && fromDescription != null) {
      setValueByPath(parentObject, ["description"], fromDescription);
    }
    const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
    if (parentObject !== void 0 && fromEpochCount != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "epochCount"], fromEpochCount);
    }
    const fromLearningRateMultiplier = getValueByPath(fromObject, [
      "learningRateMultiplier"
    ]);
    if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], fromLearningRateMultiplier);
    }
    const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
      "exportLastCheckpointOnly"
    ]);
    if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
    }
    const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
    if (parentObject !== void 0 && fromAdapterSize != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
    }
    if (getValueByPath(fromObject, ["batchSize"]) !== void 0) {
      throw new Error("batchSize parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["learningRate"]) !== void 0) {
      throw new Error("learningRate parameter is not supported in Vertex AI.");
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    return toObject;
  }
  function createTuningJobParametersPrivateToMldev(fromObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromPreTunedModel = getValueByPath(fromObject, [
      "preTunedModel"
    ]);
    if (fromPreTunedModel != null) {
      setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
    }
    const fromTrainingDataset = getValueByPath(fromObject, [
      "trainingDataset"
    ]);
    if (fromTrainingDataset != null) {
      setValueByPath(toObject, ["tuningTask", "trainingData"], tuningDatasetToMldev(fromTrainingDataset));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createTuningJobConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function createTuningJobParametersPrivateToVertex(fromObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromPreTunedModel = getValueByPath(fromObject, [
      "preTunedModel"
    ]);
    if (fromPreTunedModel != null) {
      setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
    }
    const fromTrainingDataset = getValueByPath(fromObject, [
      "trainingDataset"
    ]);
    if (fromTrainingDataset != null) {
      setValueByPath(toObject, ["supervisedTuningSpec", "trainingDatasetUri"], tuningDatasetToVertex(fromTrainingDataset, toObject));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createTuningJobConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function getTuningJobParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function getTuningJobParametersToVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function listTuningJobsConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    return toObject;
  }
  function listTuningJobsConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    return toObject;
  }
  function listTuningJobsParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listTuningJobsConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listTuningJobsParametersToVertex(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listTuningJobsConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function listTuningJobsResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromTuningJobs = getValueByPath(fromObject, ["tunedModels"]);
    if (fromTuningJobs != null) {
      let transformedList = fromTuningJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return tuningJobFromMldev(item);
        });
      }
      setValueByPath(toObject, ["tuningJobs"], transformedList);
    }
    return toObject;
  }
  function listTuningJobsResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromTuningJobs = getValueByPath(fromObject, ["tuningJobs"]);
    if (fromTuningJobs != null) {
      let transformedList = fromTuningJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return tuningJobFromVertex(item);
        });
      }
      setValueByPath(toObject, ["tuningJobs"], transformedList);
    }
    return toObject;
  }
  function tunedModelCheckpointFromVertex(fromObject) {
    const toObject = {};
    const fromCheckpointId = getValueByPath(fromObject, ["checkpointId"]);
    if (fromCheckpointId != null) {
      setValueByPath(toObject, ["checkpointId"], fromCheckpointId);
    }
    const fromEpoch = getValueByPath(fromObject, ["epoch"]);
    if (fromEpoch != null) {
      setValueByPath(toObject, ["epoch"], fromEpoch);
    }
    const fromStep = getValueByPath(fromObject, ["step"]);
    if (fromStep != null) {
      setValueByPath(toObject, ["step"], fromStep);
    }
    const fromEndpoint = getValueByPath(fromObject, ["endpoint"]);
    if (fromEndpoint != null) {
      setValueByPath(toObject, ["endpoint"], fromEndpoint);
    }
    return toObject;
  }
  function tunedModelFromMldev(fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["name"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromEndpoint = getValueByPath(fromObject, ["name"]);
    if (fromEndpoint != null) {
      setValueByPath(toObject, ["endpoint"], fromEndpoint);
    }
    return toObject;
  }
  function tunedModelFromVertex(fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromEndpoint = getValueByPath(fromObject, ["endpoint"]);
    if (fromEndpoint != null) {
      setValueByPath(toObject, ["endpoint"], fromEndpoint);
    }
    const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
    if (fromCheckpoints != null) {
      let transformedList = fromCheckpoints;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return tunedModelCheckpointFromVertex(item);
        });
      }
      setValueByPath(toObject, ["checkpoints"], transformedList);
    }
    return toObject;
  }
  function tuningDatasetToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
      throw new Error("gcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["vertexDatasetResource"]) !== void 0) {
      throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");
    }
    const fromExamples = getValueByPath(fromObject, ["examples"]);
    if (fromExamples != null) {
      let transformedList = fromExamples;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return tuningExampleToMldev(item);
        });
      }
      setValueByPath(toObject, ["examples", "examples"], transformedList);
    }
    return toObject;
  }
  function tuningDatasetToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (parentObject !== void 0 && fromGcsUri != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromGcsUri);
    }
    const fromVertexDatasetResource = getValueByPath(fromObject, [
      "vertexDatasetResource"
    ]);
    if (parentObject !== void 0 && fromVertexDatasetResource != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
    }
    if (getValueByPath(fromObject, ["examples"]) !== void 0) {
      throw new Error("examples parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function tuningExampleToMldev(fromObject) {
    const toObject = {};
    const fromTextInput = getValueByPath(fromObject, ["textInput"]);
    if (fromTextInput != null) {
      setValueByPath(toObject, ["textInput"], fromTextInput);
    }
    const fromOutput = getValueByPath(fromObject, ["output"]);
    if (fromOutput != null) {
      setValueByPath(toObject, ["output"], fromOutput);
    }
    return toObject;
  }
  function tuningJobFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromStartTime = getValueByPath(fromObject, [
      "tuningTask",
      "startTime"
    ]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, [
      "tuningTask",
      "completeTime"
    ]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromTunedModel = getValueByPath(fromObject, ["_self"]);
    if (fromTunedModel != null) {
      setValueByPath(toObject, ["tunedModel"], tunedModelFromMldev(fromTunedModel));
    }
    const fromCustomBaseModel = getValueByPath(fromObject, [
      "customBaseModel"
    ]);
    if (fromCustomBaseModel != null) {
      setValueByPath(toObject, ["customBaseModel"], fromCustomBaseModel);
    }
    const fromExperiment = getValueByPath(fromObject, ["experiment"]);
    if (fromExperiment != null) {
      setValueByPath(toObject, ["experiment"], fromExperiment);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      setValueByPath(toObject, ["labels"], fromLabels);
    }
    const fromOutputUri = getValueByPath(fromObject, ["outputUri"]);
    if (fromOutputUri != null) {
      setValueByPath(toObject, ["outputUri"], fromOutputUri);
    }
    const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
    if (fromPipelineJob != null) {
      setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
    }
    const fromServiceAccount = getValueByPath(fromObject, [
      "serviceAccount"
    ]);
    if (fromServiceAccount != null) {
      setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (fromTunedModelDisplayName != null) {
      setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
    }
    return toObject;
  }
  function tuningJobFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromTunedModel = getValueByPath(fromObject, ["tunedModel"]);
    if (fromTunedModel != null) {
      setValueByPath(toObject, ["tunedModel"], tunedModelFromVertex(fromTunedModel));
    }
    const fromPreTunedModel = getValueByPath(fromObject, [
      "preTunedModel"
    ]);
    if (fromPreTunedModel != null) {
      setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
    }
    const fromSupervisedTuningSpec = getValueByPath(fromObject, [
      "supervisedTuningSpec"
    ]);
    if (fromSupervisedTuningSpec != null) {
      setValueByPath(toObject, ["supervisedTuningSpec"], fromSupervisedTuningSpec);
    }
    const fromTuningDataStats = getValueByPath(fromObject, [
      "tuningDataStats"
    ]);
    if (fromTuningDataStats != null) {
      setValueByPath(toObject, ["tuningDataStats"], fromTuningDataStats);
    }
    const fromEncryptionSpec = getValueByPath(fromObject, [
      "encryptionSpec"
    ]);
    if (fromEncryptionSpec != null) {
      setValueByPath(toObject, ["encryptionSpec"], fromEncryptionSpec);
    }
    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [
      "partnerModelTuningSpec"
    ]);
    if (fromPartnerModelTuningSpec != null) {
      setValueByPath(toObject, ["partnerModelTuningSpec"], fromPartnerModelTuningSpec);
    }
    const fromCustomBaseModel = getValueByPath(fromObject, [
      "customBaseModel"
    ]);
    if (fromCustomBaseModel != null) {
      setValueByPath(toObject, ["customBaseModel"], fromCustomBaseModel);
    }
    const fromExperiment = getValueByPath(fromObject, ["experiment"]);
    if (fromExperiment != null) {
      setValueByPath(toObject, ["experiment"], fromExperiment);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      setValueByPath(toObject, ["labels"], fromLabels);
    }
    const fromOutputUri = getValueByPath(fromObject, ["outputUri"]);
    if (fromOutputUri != null) {
      setValueByPath(toObject, ["outputUri"], fromOutputUri);
    }
    const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
    if (fromPipelineJob != null) {
      setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
    }
    const fromServiceAccount = getValueByPath(fromObject, [
      "serviceAccount"
    ]);
    if (fromServiceAccount != null) {
      setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (fromTunedModelDisplayName != null) {
      setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
    }
    return toObject;
  }
  function tuningOperationFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    return toObject;
  }
  function tuningValidationDatasetToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["validationDatasetUri"], fromGcsUri);
    }
    const fromVertexDatasetResource = getValueByPath(fromObject, [
      "vertexDatasetResource"
    ]);
    if (parentObject !== void 0 && fromVertexDatasetResource != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
    }
    return toObject;
  }
  var Tunings = class extends BaseModule {
    constructor(apiClient) {
      super();
      this.apiClient = apiClient;
      this.get = async (params) => {
        return await this.getInternal(params);
      };
      this.list = async (params = {}) => {
        return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x3) => this.listInternal(x3), await this.listInternal(params), params);
      };
      this.tune = async (params) => {
        var _a;
        if (this.apiClient.isVertexAI()) {
          if (params.baseModel.startsWith("projects/")) {
            const preTunedModel = {
              tunedModelName: params.baseModel
            };
            if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {
              preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;
            }
            const paramsPrivate = Object.assign(Object.assign({}, params), { preTunedModel });
            paramsPrivate.baseModel = void 0;
            return await this.tuneInternal(paramsPrivate);
          } else {
            const paramsPrivate = Object.assign({}, params);
            return await this.tuneInternal(paramsPrivate);
          }
        } else {
          const paramsPrivate = Object.assign({}, params);
          const operation = await this.tuneMldevInternal(paramsPrivate);
          let tunedModelName = "";
          if (operation["metadata"] !== void 0 && operation["metadata"]["tunedModel"] !== void 0) {
            tunedModelName = operation["metadata"]["tunedModel"];
          } else if (operation["name"] !== void 0 && operation["name"].includes("/operations/")) {
            tunedModelName = operation["name"].split("/operations/")[0];
          }
          const tuningJob = {
            name: tunedModelName,
            state: JobState.JOB_STATE_QUEUED
          };
          return tuningJob;
        }
      };
    }
    async getInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = getTuningJobParametersToVertex(params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = tuningJobFromVertex(apiResponse);
          return resp;
        });
      } else {
        const body = getTuningJobParametersToMldev(params);
        path = formatMap("{name}", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = tuningJobFromMldev(apiResponse);
          return resp;
        });
      }
    }
    async listInternal(params) {
      var _a, _b, _c, _d;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = listTuningJobsParametersToVertex(params);
        path = formatMap("tuningJobs", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listTuningJobsResponseFromVertex(apiResponse);
          const typedResp = new ListTuningJobsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      } else {
        const body = listTuningJobsParametersToMldev(params);
        path = formatMap("tunedModels", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "GET",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = listTuningJobsResponseFromMldev(apiResponse);
          const typedResp = new ListTuningJobsResponse();
          Object.assign(typedResp, resp);
          return typedResp;
        });
      }
    }
    /**
     * Cancels a tuning job.
     *
     * @param params - The parameters for the cancel request.
     * @return The empty response returned by the API.
     *
     * @example
     * ```ts
     * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.
     * ```
     */
    async cancel(params) {
      var _a, _b, _c, _d;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = cancelTuningJobParametersToVertex(params);
        path = formatMap("{name}:cancel", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        await this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        });
      } else {
        const body = cancelTuningJobParametersToMldev(params);
        path = formatMap("{name}:cancel", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        await this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
          abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
        });
      }
    }
    async tuneInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        const body = createTuningJobParametersPrivateToVertex(params);
        path = formatMap("tuningJobs", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = tuningJobFromVertex(apiResponse);
          return resp;
        });
      } else {
        throw new Error("This method is only supported by the Vertex AI.");
      }
    }
    async tuneMldevInternal(params) {
      var _a, _b;
      let response;
      let path = "";
      let queryParams = {};
      if (this.apiClient.isVertexAI()) {
        throw new Error("This method is only supported by the Gemini Developer API.");
      } else {
        const body = createTuningJobParametersPrivateToMldev(params);
        path = formatMap("tunedModels", body["_url"]);
        queryParams = body["_query"];
        delete body["_url"];
        delete body["_query"];
        response = this.apiClient.request({
          path,
          queryParams,
          body: JSON.stringify(body),
          httpMethod: "POST",
          httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
          abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
        }).then((httpResponse) => {
          return httpResponse.json().then((jsonResponse) => {
            const response2 = jsonResponse;
            response2.sdkHttpResponse = {
              headers: httpResponse.headers
            };
            return response2;
          });
        });
        return response.then((apiResponse) => {
          const resp = tuningOperationFromMldev(apiResponse);
          return resp;
        });
      }
    }
  };
  var BrowserDownloader = class {
    async download(_params, _apiClient) {
      throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.");
    }
  };
  var MAX_CHUNK_SIZE = 1024 * 1024 * 8;
  var MAX_RETRY_COUNT = 3;
  var INITIAL_RETRY_DELAY_MS = 1e3;
  var DELAY_MULTIPLIER = 2;
  var X_GOOG_UPLOAD_STATUS_HEADER_FIELD = "x-goog-upload-status";
  async function uploadBlob(file, uploadUrl, apiClient) {
    var _a, _b, _c;
    let fileSize = 0;
    let offset = 0;
    let response = new HttpResponse(new Response());
    let uploadCommand = "upload";
    fileSize = file.size;
    while (offset < fileSize) {
      const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
      const chunk = file.slice(offset, offset + chunkSize);
      if (offset + chunkSize >= fileSize) {
        uploadCommand += ", finalize";
      }
      let retryCount = 0;
      let currentDelayMs = INITIAL_RETRY_DELAY_MS;
      while (retryCount < MAX_RETRY_COUNT) {
        response = await apiClient.request({
          path: "",
          body: chunk,
          httpMethod: "POST",
          httpOptions: {
            apiVersion: "",
            baseUrl: uploadUrl,
            headers: {
              "X-Goog-Upload-Command": uploadCommand,
              "X-Goog-Upload-Offset": String(offset),
              "Content-Length": String(chunkSize)
            }
          }
        });
        if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {
          break;
        }
        retryCount++;
        await sleep(currentDelayMs);
        currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
      }
      offset += chunkSize;
      if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") {
        break;
      }
      if (fileSize <= offset) {
        throw new Error("All content has been uploaded, but the upload status is not finalized.");
      }
    }
    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
    if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
      throw new Error("Failed to upload file: Upload status is not finalized.");
    }
    return responseJson["file"];
  }
  async function getBlobStat(file) {
    const fileStat = { size: file.size, type: file.type };
    return fileStat;
  }
  function sleep(ms) {
    return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));
  }
  var BrowserUploader = class {
    async upload(file, uploadUrl, apiClient) {
      if (typeof file === "string") {
        throw new Error("File path is not supported in browser uploader.");
      }
      return await uploadBlob(file, uploadUrl, apiClient);
    }
    async stat(file) {
      if (typeof file === "string") {
        throw new Error("File path is not supported in browser uploader.");
      } else {
        return await getBlobStat(file);
      }
    }
  };
  var BrowserWebSocketFactory = class {
    create(url, headers, callbacks) {
      return new BrowserWebSocket(url, headers, callbacks);
    }
  };
  var BrowserWebSocket = class {
    constructor(url, headers, callbacks) {
      this.url = url;
      this.headers = headers;
      this.callbacks = callbacks;
    }
    connect() {
      this.ws = new WebSocket(this.url);
      this.ws.onopen = this.callbacks.onopen;
      this.ws.onerror = this.callbacks.onerror;
      this.ws.onclose = this.callbacks.onclose;
      this.ws.onmessage = this.callbacks.onmessage;
    }
    send(message) {
      if (this.ws === void 0) {
        throw new Error("WebSocket is not connected");
      }
      this.ws.send(message);
    }
    close() {
      if (this.ws === void 0) {
        throw new Error("WebSocket is not connected");
      }
      this.ws.close();
    }
  };
  var GOOGLE_API_KEY_HEADER = "x-goog-api-key";
  var WebAuth = class {
    constructor(apiKey) {
      this.apiKey = apiKey;
    }
    async addAuthHeaders(headers) {
      if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {
        return;
      }
      if (this.apiKey.startsWith("auth_tokens/")) {
        throw new Error("Ephemeral tokens are only supported by the live API.");
      }
      if (!this.apiKey) {
        throw new Error("API key is missing. Please provide a valid API key.");
      }
      headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);
    }
  };
  var LANGUAGE_LABEL_PREFIX = "gl-node/";
  var GoogleGenAI = class {
    constructor(options) {
      var _a;
      if (options.apiKey == null) {
        throw new Error("An API Key must be set when running in a browser");
      }
      if (options.project || options.location) {
        throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");
      }
      this.vertexai = (_a = options.vertexai) !== null && _a !== void 0 ? _a : false;
      this.apiKey = options.apiKey;
      const baseUrl = getBaseUrl(
        options.httpOptions,
        options.vertexai,
        /*vertexBaseUrlFromEnv*/
        void 0,
        /*geminiBaseUrlFromEnv*/
        void 0
      );
      if (baseUrl) {
        if (options.httpOptions) {
          options.httpOptions.baseUrl = baseUrl;
        } else {
          options.httpOptions = { baseUrl };
        }
      }
      this.apiVersion = options.apiVersion;
      const auth = new WebAuth(this.apiKey);
      this.apiClient = new ApiClient({
        auth,
        apiVersion: this.apiVersion,
        apiKey: this.apiKey,
        vertexai: this.vertexai,
        httpOptions: options.httpOptions,
        userAgentExtra: LANGUAGE_LABEL_PREFIX + "web",
        uploader: new BrowserUploader(),
        downloader: new BrowserDownloader()
      });
      this.models = new Models(this.apiClient);
      this.live = new Live(this.apiClient, auth, new BrowserWebSocketFactory());
      this.batches = new Batches(this.apiClient);
      this.chats = new Chats(this.models, this.apiClient);
      this.caches = new Caches(this.apiClient);
      this.files = new Files(this.apiClient);
      this.operations = new Operations(this.apiClient);
      this.authTokens = new Tokens(this.apiClient);
      this.tunings = new Tunings(this.apiClient);
    }
  };

  // services/geminiService.ts
  var ApiKeyError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "ApiKeyError";
    }
  };
  var QuotaError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "QuotaError";
    }
  };
  var isApiKeyError = (error) => {
    if (error instanceof Error) {
      const message = error.message;
      return message.includes("API key not valid") || message.includes("permission denied") || message.includes("400 Bad Request");
    }
    return false;
  };
  var isQuotaError = (error) => {
    if (error instanceof Error) {
      const message = error.message;
      return message.includes("RESOURCE_EXHAUSTED") || message.includes("Quota exceeded");
    }
    return false;
  };
  var systemInstruction = `你是一位專為互動式文字冒險遊戲設計的故事大師。你的目標是創造身歷其境、引人入勝且連貫的場景。

**核心職責：**
1.  **生成場景**：根據使用者選擇的主題和後續的選擇，生成新場景的生動描述（約 2-3 個段落）。
2.  **提供選項**：提供 3 到 4 個不同且可操作的選項供玩家選擇。
3.  **管理玩家狀態**：
    *   **角色扮演**：遊戲中的主角是玩家。你應該在場景描述和對話中適時地使用玩家的姓名（如果提供），並將他們的腳色介紹融入敘事中，讓玩家感覺這就是他們自己的故事。
    *   **屬性系統**：玩家有六個核心屬性。你必須根據這些屬性來塑造故事和選項，並在故事進展中更新它們。
        *   **生命值 (Health)**: 範圍 0-100。代表玩家的生命力。降至 0 通常意味著遊戲結束。初始值為 100。
        *   **體力值 (Stamina)**: 範圍 0-100。代表玩家的精力，影響奔跑、攀爬等持續性活動。初始值為 100。
        *   **力量 (Strength)**: 範圍 1-20。代表玩家的物理力量。影響舉重、戰鬥、破壞等。
        *   **敏捷 (Agility)**: 範圍 1-20。代表玩家的靈巧、速度和反應。影響閃避、潛行、精細操作等。
        *   **體質 (Constitution)**: 範圍 1-20。代表玩家的耐力和抵抗力。影響對毒藥、疾病和惡劣環境的抵抗能力。
        *   **精神 (Spirit)**: 範圍 1-20。代表玩家的意志力、專注力和心靈韌性。影響抵抗心靈攻擊、解謎、保持冷靜等。
    *   **屬性等級參考**：1=嬰兒，8=正常成年人，12=頂級運動員，16=超人，20=神。玩家初始時各項非生命值屬性為 8。
    *   **動態更新**：根據玩家的選擇和故事進展，動態更新玩家的屬性或物品欄。例如，如果玩家撿起一把鑰匙，你必須在 \`playerStateUpdate.addItems\` 中新增它。如果玩家受傷，你必須在 \`playerStateUpdate.setAttributes\` 中更新生命值。一次艱苦的攀爬可能會暫時降低體質，或成功後永久增加力量。
    *   **狀態感知**：你的故事和選項必須反映玩家的當前狀態。如果玩家物品欄裡有繩子，你可以提供一個使用繩子的選項。如果玩家力量高，可以提供一個蠻力選項。如果玩家生命值低，場景描述應該反映出他們的虛弱。
4.  **管理 NPC 狀態**：
    *   識別場景中的重要 NPC（非玩家角色）。
    *   如果場景中有 NPC，你**必須**在 \`npcs\` 陣列中回傳他們的完整狀態。
    *   每個 NPC 的狀態**必須**包含：名稱、對玩家的 \`affinity\` (好感度)、一段關於其外觀或性格的簡短描述、以及他們的物品。
    *   **屬性**：你**必須**為每個 NPC 提供完整的核心屬性集。此欄位不應為空。
        *   **核心屬性**：每個 NPC **必須**包含 '生命值', '體力值', '力量', '敏捷', '體質', '精神' 這六個屬性。其數值範圍與玩家相同（力量/敏捷/體質/精神為 1-20，生命值/體力值為 0-100）。
        *   **其他屬性**：你也可以根據 NPC 的特性和情境添加其他描述性屬性，例如 '狀態: 正常', '情緒: 警惕' 等。
    *   **物品欄可見性**：NPC 的物品欄應只包含玩家已知或觀察到的物品。使用 \`unknownItemCount\` 欄位來表示 NPC 攜帶的、但玩家尚不知道的隱藏物品數量。例如，如果一個警衛帶著一把劍和一個隱藏的錢包，你應該回傳 \`inventory: [{name: '警衛的劍', ...}]\` 和 \`unknownItemCount: 1\`。
    *   NPC 的狀態（尤其是好感度）應該會根據玩家的行動而改變。
5.  **管理怪物狀態**：
    *   識別場景中的敵對生物或怪物。
    *   如果場景中有怪物，你**必須**在 \`monsters\` 陣列中回傳牠們的狀態。
    *   每個怪物的狀態**必須**包含：名稱、對其外觀和行為的簡短描述、以及牠的屬性（例如 '生命值', '力量', '敏捷'）。
    *   怪物通常是敵對的，不需要好感度或複雜的物品欄。
6.  **控制遊戲流程**：故事應是動態的，可以導向各種结局。當故事結束時（例如生命值降為 0），將 \`isGameOver\` 設為 true 並提供结局訊息。

**回應格式：**
你必須始終以指定的 JSON 格式回應。所有生成的故事、選項和訊息都必須使用**繁體中文**。`;
  var responseSchema = {
    type: Type.OBJECT,
    properties: {
      sceneDescription: {
        type: Type.STRING,
        description: "對當前場景及玩家上一個選擇結果的詳細、引人入勝的描述。這應該有 2-3 個段落長。必須使用繁體中文。"
      },
      choices: {
        type: Type.ARRAY,
        description: "一個包含 3 到 4 個不同選項的陣列供玩家選擇。如果遊戲結束，此陣列應為空。所有選項都必須使用繁體中文。",
        items: {
          type: Type.OBJECT,
          properties: {
            text: {
              type: Type.STRING,
              description: "呈現給玩家的選項文字。"
            }
          },
          required: ["text"]
        }
      },
      isGameOver: {
        type: Type.BOOLEAN,
        description: "一個布林值，表示遊戲是否已達到結局或遊戲結束狀態。"
      },
      gameOverMessage: {
        type: Type.STRING,
        description: "如果 isGameOver 為 true，則顯示一條結束訊息。這可以是勝利或失敗的訊息。必須使用繁體中文。"
      },
      playerStateUpdate: {
        type: Type.OBJECT,
        description: "一個包含對玩家狀態更新的物件。這是可選的，只有在需要改變玩家屬性或物品時才包含此欄位。",
        properties: {
          addItems: {
            type: Type.ARRAY,
            description: "要添加到玩家物品欄中的物品陣列。",
            items: {
              type: Type.OBJECT,
              properties: {
                name: { type: Type.STRING, description: "物品名稱。" },
                description: { type: Type.STRING, description: "物品的簡短描述。" }
              },
              required: ["name", "description"]
            }
          },
          removeItems: {
            type: Type.ARRAY,
            description: "要從玩家物品欄中移除的物品名稱陣列。",
            items: { type: Type.STRING }
          },
          setAttributes: {
            type: Type.ARRAY,
            description: '要更新或設定的玩家屬性陣列。例如：`[{"key": "生命值", "value": "80"}, {"key": "狀態", "value": "良好"}]`。',
            items: {
              type: Type.OBJECT,
              properties: {
                key: { type: Type.STRING, description: "屬性名稱。" },
                value: { type: Type.STRING, description: "屬性值（以字串形式）。" }
              },
              required: ["key", "value"]
            }
          }
        }
      },
      npcs: {
        type: Type.ARRAY,
        description: "場景中出現的 NPC 狀態陣列。如果沒有 NPC，則為空陣列。",
        items: {
          type: Type.OBJECT,
          properties: {
            name: { type: Type.STRING, description: "NPC 的名稱。" },
            description: { type: Type.STRING, description: "對 NPC 外觀、性格或背景的簡短描述。" },
            affinity: { type: Type.STRING, description: "NPC 對玩家的好感度 (例如 '友好', '中立', '敵對')。" },
            attributes: {
              type: Type.ARRAY,
              description: '一個包含 NPC 屬性的鍵值對陣列。例如：`[{"key": "狀態", "value": "警戒中"}]`',
              items: {
                type: Type.OBJECT,
                properties: {
                  key: { type: Type.STRING, description: "屬性名稱。" },
                  value: { type: Type.STRING, description: "屬性值（以字串形式）。" }
                },
                required: ["key", "value"]
              }
            },
            inventory: {
              type: Type.ARRAY,
              description: "NPC 攜帶的、玩家已知的物品陣列。",
              items: {
                type: Type.OBJECT,
                properties: {
                  name: { type: Type.STRING, description: "物品名稱。" },
                  description: { type: Type.STRING, description: "物品的簡短描述。" }
                },
                required: ["name", "description"]
              }
            },
            unknownItemCount: {
              type: Type.NUMBER,
              description: "NPC 攜帶的、但玩家未觀察到或未知的隱藏物品數量。"
            }
          },
          required: ["name", "description", "affinity", "attributes", "inventory", "unknownItemCount"]
        }
      },
      monsters: {
        type: Type.ARRAY,
        description: "場景中出現的怪物狀態陣列。如果沒有怪物，則為空陣列。",
        items: {
          type: Type.OBJECT,
          properties: {
            name: { type: Type.STRING, description: "怪物的名稱。" },
            description: { type: Type.STRING, description: "對怪物外觀和行為的簡短描述。" },
            attributes: {
              type: Type.ARRAY,
              description: '一個包含怪物屬性的鍵值對陣列。例如：`[{"key": "生命值", "value": "30"}]`',
              items: {
                type: Type.OBJECT,
                properties: {
                  key: { type: Type.STRING, description: "屬性名稱。" },
                  value: { type: Type.STRING, description: "屬性值（以字串形式）。" }
                },
                required: ["key", "value"]
              }
            }
          },
          required: ["name", "attributes", "description"]
        }
      }
    },
    required: ["sceneDescription", "choices", "isGameOver"]
  };
  function constructPrompt(history, playerState, npcs, monsters) {
    const historyText = history.map((step) => {
      if (step.type === "scene") return `場景：${step.content}`;
      if (step.type === "choice") return `玩家選擇了：「${step.content}」`;
      if (step.type === "theme") return `開始一個新冒險，主題是：「${step.content}」。`;
      return "";
    }).join("\n\n");
    let playerStateText = "玩家目前沒有任何狀態。這是冒險的開始。";
    if (playerState) {
      const name = playerState.name || "無名者";
      const background = playerState.background || "沒有特別的介紹。";
      const attributes = Object.entries(playerState.attributes).map(([key, value]) => `${key}: ${value}`).join(", ");
      const inventory = playerState.inventory.length > 0 ? playerState.inventory.map((item) => item.name).join(", ") : "空的";
      playerStateText = `玩家資訊：
- 姓名: ${name}
- 介紹: ${background}

玩家當前狀態：
- 屬性：${attributes}
- 物品欄：${inventory}`;
    }
    let npcStateText = "目前場景中沒有其他重要角色。";
    if (npcs && npcs.length > 0) {
      npcStateText = "場景中其他角色的狀態：\n" + npcs.map((npc) => {
        const attributes = Object.entries(npc.attributes).map(([key, value]) => `${key}: ${value}`).join(", ");
        const knownItems = npc.inventory.length > 0 ? npc.inventory.map((item) => item.name).join(", ") : "無";
        let inventoryText = `已知物品: ${knownItems}`;
        if (npc.unknownItemCount > 0) {
          inventoryText += ` | 未知物品數量: ${npc.unknownItemCount}`;
        }
        return `- ${npc.name} (好感度: ${npc.affinity}):
  - 屬性: ${attributes}
  - 物品欄: ${inventoryText}`;
      }).join("\n");
    }
    let monsterStateText = "目前場景中沒有敵對生物。";
    if (monsters && monsters.length > 0) {
      monsterStateText = "場景中敵對生物的狀態：\n" + monsters.map((monster) => {
        const attributes = Object.entries(monster.attributes).map(([key, value]) => `${key}: ${value}`).join(", ");
        return `- ${monster.name}:
  - 屬性: ${attributes}`;
      }).join("\n");
    }
    const userPrompt = `根據這段歷史和角色狀態繼續冒險：

**遊戲歷史**
${historyText}

**${playerStateText}**

**${npcStateText}**

**${monsterStateText}**

生成下一步。`;
    return userPrompt;
  }
  var generateThemeInspiration = async (apiKey) => {
    try {
      const ai = new GoogleGenAI({ apiKey });
      const instruction = `你是一位充滿創意的故事大師，專門為文字冒險遊戲發想獨特且引人入勝的主題。你的任務是生成一個單句、富有想像力的場景或概念作為遊戲的起點。請直接回傳主題文字，不要包含任何額外的解釋、引號或標籤。`;
      const prompt = `生成一個冒險主題靈感。`;
      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: { parts: [{ text: prompt }] },
        config: {
          systemInstruction: instruction,
          temperature: 1,
          topP: 0.95
        }
      });
      const themeText = response.text.trim();
      if (!themeText) {
        return null;
      }
      return themeText.replace(/^"|"$/g, "");
    } catch (error) {
      console.error("generateThemeInspiration 失敗:", error);
      if (isApiKeyError(error)) {
        throw new ApiKeyError("API 金鑰無效或已過期。");
      }
      throw error;
    }
  };
  var generateCharacterIntroduction = async (theme, apiKey) => {
    try {
      const ai = new GoogleGenAI({ apiKey });
      const instruction = `你是一位遊戲角色設定大師。你的任務是為玩家生成一段結構化、富有代入感的「腳色介紹」。
這個介紹應該像一份角色設定集，為玩家提供一個清晰且富有代入感的起點。請嚴格遵循以下結構和風格來生成內容，確保包含所有要點：

1.  **身份與年齡**: 描述角色的職業和大致年齡。
2.  **外觀與體格**: 描述髮色、眼睛顏色、身材等特徵。
3.  **出身與家庭**: 簡述出生地和家庭背景。
4.  **動機與渴望**: 解釋角色為何踏上冒險。
5.  **技能與弱點**: 點出角色擅長的能力和不擅長的事情。

**範例格式與風格參考（請根據使用者提供的主題生成原創內容）：**
「我是一名年僅 19 歲的見習冒險者。
有著一頭凌亂的棕色短髮與銳利的灰藍色眼睛，身材偏瘦卻敏捷。
出生於邊境小村，父親是獵人，母親則經營著一家小酒館。
雖然出身平凡，但始終渴望離開村莊，去外面的世界探索未知。
擅長弓術與追蹤，卻對近身戰鬥毫無把握。」

你的回應必須直接是生成的腳色介紹文字，不要包含任何標題、數字編號或額外的解釋。`;
      const prompt = `為一位即將在「${theme}」主題世界中展開冒險的玩家生成角色介紹。`;
      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: { parts: [{ text: prompt }] },
        config: {
          systemInstruction: instruction,
          temperature: 0.9,
          topP: 0.95
        }
      });
      const introductionText = response.text.trim();
      if (!introductionText) {
        throw new Error("AI 未能生成腳色介紹。");
      }
      return introductionText;
    } catch (error) {
      console.error("generateCharacterIntroduction 失敗:", error);
      if (isApiKeyError(error)) {
        throw new ApiKeyError("API 金鑰無效或已過期。");
      }
      return `一位來自未知之地，命運與「${theme}」緊密相連的神秘冒險者。`;
    }
  };
  var generateCharacterAvatar = async (introduction, apiKey) => {
    try {
      const ai = new GoogleGenAI({ apiKey });
      const prompt = `根據以下角色描述，生成一張 160x160 動漫風格的半身像。只要角色本身，背景為單純的純色背景。

描述：「${introduction}」`;
      const response = await ai.models.generateImages({
        model: "imagen-4.0-generate-001",
        prompt,
        config: {
          numberOfImages: 1,
          outputMimeType: "image/png"
        }
      });
      if (response.generatedImages && response.generatedImages.length > 0) {
        return response.generatedImages[0].image.imageBytes;
      }
      return null;
    } catch (error) {
      console.error("generateCharacterAvatar 失敗:", error);
      if (isQuotaError(error)) {
        throw new QuotaError("角色頭像生成失敗，因為已達到每日用量上限。");
      }
      return null;
    }
  };
  var attributesSchema = {
    type: Type.OBJECT,
    properties: {
      "力量": { type: Type.INTEGER, description: "角色的力量值" },
      "敏捷": { type: Type.INTEGER, description: "角色的敏捷值" },
      "體質": { type: Type.INTEGER, description: "角色的體質值" },
      "精神": { type: Type.INTEGER, description: "角色的精神值" }
    },
    required: ["力量", "敏捷", "體質", "精神"]
  };
  var generateInitialAttributes = async (introduction, theme, apiKey) => {
    try {
      const ai = new GoogleGenAI({ apiKey });
      const instruction = `你是一位遊戲大師，負責根據玩家的角色設定來分配初始屬性點數。

**分配規則：**
1.  **屬性**：你將分配「力量」、「敏捷」、「體質」和「精神」四項屬性。
2.  **數值範圍**：每項屬性的值必須介於 5 到 13 之間（包含 5 和 13）。
3.  **總和限制**：四項屬性的總和必須介於 32 到 44 之間（包含 32 和 44）。
4.  **邏輯性**：屬性分配應反映角色介紹中的描述。例如，身材瘦弱但敏捷的角色，其「敏捷」應較高，「力量」或「體質」可能較低；意志堅定的角色，「精神」應較高。
5.  **格式**：你必須以指定的 JSON 格式回傳結果。`;
      const prompt = `請仔細閱讀以下在「${theme}」世界中的角色介紹，並為其分配屬性。

**角色介紹：**
「${introduction}」`;
      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: { parts: [{ text: prompt }] },
        config: {
          systemInstruction: instruction,
          responseMimeType: "application/json",
          responseSchema: attributesSchema,
          temperature: 0.5
        }
      });
      const jsonText = response.text.trim();
      if (!jsonText) {
        throw new Error("AI 未能生成屬性。");
      }
      const parsedAttributes = JSON.parse(jsonText);
      const { "力量": str, "敏捷": agi, "體質": con, "精神": spr } = parsedAttributes;
      const total = str + agi + con + spr;
      if ([str, agi, con, spr].some((val) => val < 5 || val > 13) || total < 32 || total > 44) {
        console.warn("AI 生成的屬性超出規則範圍，將使用預設值。", parsedAttributes);
        return { "力量": 8, "敏捷": 8, "體質": 8, "精神": 8 };
      }
      return parsedAttributes;
    } catch (error) {
      console.error("generateInitialAttributes 失敗:", error);
      if (isApiKeyError(error)) {
        throw new ApiKeyError("API 金鑰無效或已過期。");
      }
      console.warn("因發生錯誤，將使用預設屬性。");
      return { "力量": 8, "敏捷": 8, "體質": 8, "精神": 8 };
    }
  };
  var validateApiKey = async (apiKey) => {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash?key=${apiKey}`;
    try {
      const response = await fetch(url);
      if (response.ok) {
        return true;
      } else {
        const errorData = await response.json().catch(() => ({ message: response.statusText }));
        console.error(`API 金鑰驗證失敗，狀態碼 ${response.status}:`, errorData);
        return false;
      }
    } catch (error) {
      console.error("API 金鑰驗證請求失敗，可能是網路或 fetch 錯誤:", error);
      return false;
    }
  };
  var generateAdventureStep = async (history, playerState, npcs, monsters, apiKey) => {
    try {
      const ai = new GoogleGenAI({ apiKey });
      const prompt = constructPrompt(history, playerState, npcs, monsters);
      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: { parts: [{ text: prompt }] },
        config: {
          systemInstruction,
          responseMimeType: "application/json",
          responseSchema,
          temperature: 0.8,
          topP: 0.95
        }
      });
      const jsonText = response.text.trim();
      if (!jsonText) {
        console.error("Gemini 回應為空:", response);
        throw new Error("說書人沒有回應。可能是內容被過濾。");
      }
      const parsedResponse = JSON.parse(jsonText);
      return parsedResponse;
    } catch (error) {
      console.error("generateAdventureStep 失敗:", error);
      if (isApiKeyError(error)) {
        throw new ApiKeyError("API 金鑰無效或已過期。");
      }
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(`與說書人的通訊出現問題: ${message}`);
    }
  };

  // services/storageService.ts
  var SAVE_GAME_KEY_PREFIX = "gemini-text-adventure-save-";
  var MAX_SAVE_SLOTS = 4;
  var saveGame = (saveData, slotIndex) => {
    if (slotIndex < 0 || slotIndex >= MAX_SAVE_SLOTS) {
      console.error(`無效的存檔欄位索引: ${slotIndex}`);
      return;
    }
    try {
      const data = JSON.stringify(saveData);
      localStorage.setItem(`${SAVE_GAME_KEY_PREFIX}${slotIndex}`, data);
    } catch (error) {
      console.error("無法儲存遊戲進度:", error);
    }
  };
  var loadGame = (slotIndex) => {
    if (slotIndex < 0 || slotIndex >= MAX_SAVE_SLOTS) {
      console.error(`無效的存檔欄位索引: ${slotIndex}`);
      return null;
    }
    try {
      const data = localStorage.getItem(`${SAVE_GAME_KEY_PREFIX}${slotIndex}`);
      if (data === null) {
        return null;
      }
      return JSON.parse(data);
    } catch (error) {
      console.error("無法讀取遊戲進度:", error);
      return null;
    }
  };
  var clearSave = (slotIndex) => {
    if (slotIndex < 0 || slotIndex >= MAX_SAVE_SLOTS) {
      console.error(`無效的存檔欄位索引: ${slotIndex}`);
      return;
    }
    try {
      localStorage.removeItem(`${SAVE_GAME_KEY_PREFIX}${slotIndex}`);
    } catch (error) {
      console.error("無法清除遊戲存檔:", error);
    }
  };
  var getAllSaves = () => {
    const saves = [];
    for (let i = 0; i < MAX_SAVE_SLOTS; i++) {
      saves.push(loadGame(i));
    }
    return saves;
  };

  // components/ThemeSelector.tsx
  var import_react = __toESM(require_react());
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  var classicThemes = [
    "與夥伴的末日求生之旅",
    "穿越到戀愛遊戲世界是否搞錯了什麼",
    "小人物的官場求生記",
    "修真世界裡，只有我是TRPG腳色",
    "一醒來，怪物在我面前出現，發現是新手教學",
    "一座下著酸雨的賽博龐克城市",
    "火星上最後的人類殖民地",
    "1940 年代紐約的黑色偵探故事",
    "在荒涼的熱帶島嶼上求生",
    "一艘探索未知星系的深空太空船"
  ];
  var ThemeSelector = ({ onThemeSelected, onGenerateInspiration }) => {
    const [theme, setTheme] = (0, import_react.useState)("");
    const [placeholder, setPlaceholder] = (0, import_react.useState)("一棟鬧鬼的維多利亞式豪宅...");
    const [isGenerating, setIsGenerating] = (0, import_react.useState)(false);
    const handleSubmit = (e) => {
      e.preventDefault();
      if (theme.trim()) {
        onThemeSelected(theme.trim());
      } else {
        onThemeSelected(placeholder.endsWith("...") ? placeholder.slice(0, -3) : placeholder);
      }
    };
    const handleInspirationClick = async () => {
      setIsGenerating(true);
      try {
        const inspiration = await onGenerateInspiration();
        if (inspiration) {
          setPlaceholder(inspiration);
        } else {
          setPlaceholder("無法獲取靈感，請檢查網路或 API 金鑰。");
        }
      } catch (error) {
        console.error("Error fetching inspiration:", error);
        setPlaceholder("生成靈感時發生錯誤...");
      } finally {
        setIsGenerating(false);
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { className: "bg-slate-800/50 p-8 rounded-lg shadow-2xl border border-slate-700 animate-fade-in-up backdrop-blur-sm", children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("h2", { className: "text-2xl font-semibold text-cyan-300 mb-4 text-center", children: "選擇你的冒險主題" }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", { className: "text-slate-400 mb-6 text-center", children: "自由發揮你的想像力，或從下方的經典主題中選擇。" }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("form", { onSubmit: handleSubmit, children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          "input",
          {
            type: "text",
            value: theme,
            onChange: (e) => setTheme(e.target.value),
            placeholder,
            className: "w-full bg-slate-900 border border-slate-600 rounded-md p-3 text-lg text-slate-200 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition duration-300 placeholder-slate-500"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", { className: "text-xs text-slate-500 text-center mt-2", children: [
          "不知道玩什麼？",
          " ",
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            "button",
            {
              type: "button",
              onClick: handleInspirationClick,
              className: "underline hover:text-cyan-400 disabled:text-slate-500 disabled:cursor-wait",
              disabled: isGenerating,
              children: "來點靈感"
            }
          )
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "mt-6 text-center", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          "button",
          {
            type: "submit",
            className: "bg-cyan-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-cyan-500 transition-all duration-300 transform hover:scale-105 active:scale-95 shadow-lg w-full md:w-auto flex items-center justify-center mx-auto",
            children: "確認主題"
          }
        ) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { className: "my-8 flex items-center", "aria-hidden": "true", children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("hr", { className: "flex-grow border-t border-slate-600" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: "mx-4 text-slate-400 text-sm", children: "或" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("hr", { className: "flex-grow border-t border-slate-600" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("h3", { className: "text-xl font-semibold text-cyan-300 mb-4 text-center", children: "從經典主題中選擇" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: classicThemes.map((classicTheme, index) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
          "button",
          {
            onClick: () => onThemeSelected(classicTheme),
            className: "text-left bg-slate-700/70 p-4 rounded-lg border border-slate-600 hover:bg-cyan-800/50 hover:border-cyan-600 transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-cyan-500 transform hover:-translate-y-1 active:scale-95 flex items-center justify-between",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: classicTheme }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", d: "M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z", clipRule: "evenodd" }) })
            ]
          },
          index
        )) })
      ] })
    ] });
  };
  var ThemeSelector_default = ThemeSelector;

  // components/GameScreen.tsx
  var import_react5 = __toESM(require_react());

  // components/LoadingIcon.tsx
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  var LoadingIcon = () => /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
    "svg",
    {
      className: "animate-spin -ml-1 mr-3 h-5 w-5 text-white",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
          "circle",
          {
            className: "opacity-25",
            cx: "12",
            cy: "12",
            r: "10",
            stroke: "currentColor",
            strokeWidth: "4"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
          "path",
          {
            className: "opacity-75",
            fill: "currentColor",
            d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          }
        )
      ]
    }
  );
  var LoadingIcon_default = LoadingIcon;

  // components/StoryLog.tsx
  var import_react3 = __toESM(require_react());

  // components/Typewriter.tsx
  var import_react2 = __toESM(require_react());
  var import_jsx_runtime3 = __toESM(require_jsx_runtime());
  var Typewriter = ({ text, speed = 25, onComplete, onUpdate }) => {
    const [displayedText, setDisplayedText] = (0, import_react2.useState)("");
    (0, import_react2.useEffect)(() => {
      if (speed <= 0) {
        setDisplayedText(text);
        if (onComplete) {
          onComplete();
        }
        return;
      }
      setDisplayedText("");
      let frameId;
      let startTime;
      let lastCharIndex = -1;
      const type = (currentTime) => {
        if (startTime === void 0) {
          startTime = currentTime;
        }
        const elapsed = currentTime - startTime;
        const currentCharIndex = Math.min(Math.floor(elapsed / speed), text.length);
        if (currentCharIndex > lastCharIndex) {
          setDisplayedText(text.substring(0, currentCharIndex));
          lastCharIndex = currentCharIndex;
        }
        if (currentCharIndex < text.length) {
          frameId = requestAnimationFrame(type);
        } else {
          if (onComplete) {
            onComplete();
          }
        }
      };
      frameId = requestAnimationFrame(type);
      return () => {
        cancelAnimationFrame(frameId);
      };
    }, [text, speed, onComplete]);
    (0, import_react2.useEffect)(() => {
      if (onUpdate) {
        onUpdate();
      }
    }, [displayedText, onUpdate]);
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { children: displayedText });
  };
  var Typewriter_default = Typewriter;

  // components/StoryLog.tsx
  var import_jsx_runtime4 = __toESM(require_jsx_runtime());
  var StoryLog = ({ storyLog, onTypingComplete, typewriterSpeed }) => {
    const scrollableContainerRef = (0, import_react3.useRef)(null);
    const scrollToBottom = () => {
      if (scrollableContainerRef.current) {
        scrollableContainerRef.current.scrollTop = scrollableContainerRef.current.scrollHeight;
      }
    };
    (0, import_react3.useEffect)(() => {
      scrollToBottom();
    }, [storyLog]);
    (0, import_react3.useEffect)(() => {
      const lastStep = storyLog[storyLog.length - 1];
      if (typewriterSpeed === 0 && lastStep?.type === "scene") {
        onTypingComplete();
      }
    }, [storyLog, typewriterSpeed, onTypingComplete]);
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      "div",
      {
        ref: scrollableContainerRef,
        className: "space-y-6 max-h-[50vh] overflow-y-auto pr-4 -mr-4",
        style: { scrollBehavior: "smooth" },
        children: storyLog.map((step, index) => {
          const isLastStep = index === storyLog.length - 1;
          if (step.type === "scene") {
            return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "text-slate-300 text-lg leading-relaxed whitespace-pre-wrap", children: isLastStep && typewriterSpeed > 0 ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Typewriter_default, { text: step.content, onComplete: onTypingComplete, onUpdate: scrollToBottom, speed: typewriterSpeed }) : step.content }, index);
          }
          if (step.type === "choice") {
            return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_react3.default.Fragment, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "text-right animate-fade-in", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("p", { className: "inline-block bg-cyan-900/50 text-cyan-200 italic px-4 py-2 rounded-lg border border-cyan-800", children: [
                "> ",
                step.content
              ] }) }),
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("hr", { className: "thematic-divider" })
            ] }, index);
          }
          return null;
        })
      }
    );
  };
  var StoryLog_default = StoryLog;

  // components/PlayerStatus.tsx
  var import_jsx_runtime5 = __toESM(require_jsx_runtime());
  var attributeDescriptions = {
    "生命值": "代表玩家的生命力。降至 0 通常意味著遊戲結束。",
    "體力值": "代表玩家的精力，影響奔跑、攀爬等持續性活動。",
    "力量": "代表玩家的物理力量，影響舉重、戰鬥、破壞等。",
    "敏捷": "代表玩家的靈巧、速度和反應，影響閃避、潛行、精細操作等。",
    "體質": "代表玩家的耐力和抵抗力，影響對毒藥、疾病和惡劣環境的抵抗能力。",
    "精神": "代表玩家的意志力、專注力和心靈韌性，影響抵抗心靈攻擊、解謎、保持冷靜等。"
  };
  var getAttributeLevelInfo = (key, value) => {
    const coreAttributes = ["力量", "敏捷", "體質", "精神"];
    const numericValue = Number(value);
    if (coreAttributes.includes(key) && !isNaN(numericValue)) {
      if (numericValue <= 5) return { level: "低", range: "1-5" };
      if (numericValue <= 10) return { level: "中", range: "6-10" };
      if (numericValue <= 15) return { level: "高", range: "11-15" };
      if (numericValue >= 16) return { level: "極高", range: "16-20" };
    }
    return { level: String(value), range: null };
  };
  var PlayerStatus = ({ playerState }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "relative z-10 bg-slate-800/50 p-6 rounded-lg shadow-2xl border border-slate-700 backdrop-blur-sm", children: [
      playerState?.avatar && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "mb-4 flex justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        "img",
        {
          src: `data:image/png;base64,${playerState.avatar}`,
          alt: `${playerState.name} 的頭像`,
          className: "w-[160px] h-[160px] rounded-md border-2 border-slate-600 shadow-lg pixelated-image",
          width: "160",
          height: "160"
        }
      ) }),
      playerState?.name ? /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "group relative mb-4 border-b border-slate-600 pb-2 cursor-help", children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("h3", { className: "text-xl font-bold text-cyan-300 text-center", children: playerState.name }),
        playerState.background && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "absolute left-1/2 -translate-x-1/2 top-full mt-2 w-max max-w-xs p-3 text-sm bg-slate-900 text-slate-300 rounded-lg shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-50 border border-slate-700 text-left", children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("p", { className: "font-bold text-cyan-400 mb-1", children: "腳色介紹" }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("p", { className: "whitespace-pre-wrap", children: playerState.background })
        ] })
      ] }) : /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("h3", { className: "text-xl font-bold text-cyan-300 mb-4 border-b border-slate-600 pb-2", children: "人物狀態" }),
      playerState ? /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "space-y-4", children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("h4", { className: "text-lg font-semibold text-slate-300 mb-2", children: "屬性" }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("ul", { className: "space-y-1 text-slate-400", children: Object.entries(playerState.attributes).map(([key, value]) => {
            const { level, range } = getAttributeLevelInfo(key, value);
            return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("li", { className: "flex justify-between items-center", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("span", { className: "group relative cursor-help border-b border-dotted border-slate-500", children: [
                key,
                ":",
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "absolute left-1/2 -translate-x-1/2 top-full mt-2 w-max max-w-xs p-3 text-sm bg-slate-900 text-slate-300 rounded-lg shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-50 border border-slate-700 text-left", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("p", { className: "font-bold text-cyan-400 mb-1", children: key }),
                  attributeDescriptions[key] || "一個神秘的屬性。"
                ] })
              ] }),
              range ? /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("span", { className: "group relative cursor-help font-mono font-bold text-cyan-400 border-b border-dotted border-slate-500", children: [
                value,
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "absolute right-0 top-full mt-2 w-max p-2 text-xs bg-slate-900 text-slate-300 rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-50 border border-slate-700", children: [
                  "等級: ",
                  level,
                  " (",
                  range,
                  ")"
                ] })
              ] }) : /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "font-mono font-bold text-cyan-400", children: value })
            ] }, key);
          }) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("hr", { className: "thematic-divider" }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("h4", { className: "text-lg font-semibold text-slate-300 mb-2", children: "物品欄" }),
          playerState.inventory.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("ul", { className: "space-y-2 text-slate-400", children: playerState.inventory.map((item) => /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("li", { className: "group relative", children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "font-semibold", children: item.name }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "absolute left-0 top-full mt-2 w-full max-w-xs p-2 text-sm bg-slate-900 text-slate-300 rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-50 border border-slate-700", children: item.description })
          ] }, item.name)) }) : /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("p", { className: "text-slate-500 italic", children: "你的口袋空空如也。" })
        ] })
      ] }) : /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("p", { className: "text-slate-500 italic", children: "正在等待冒險的召喚..." })
    ] });
  };
  var PlayerStatus_default = PlayerStatus;

  // components/NpcStatus.tsx
  var import_jsx_runtime6 = __toESM(require_jsx_runtime());
  var getAffinityColor = (affinity) => {
    switch (affinity) {
      case "友好":
        return "text-green-400";
      case "敵對":
        return "text-red-400";
      case "中立":
      default:
        return "text-yellow-400";
    }
  };
  var getAttributeLevelInfo2 = (key, value) => {
    const coreAttributes = ["力量", "敏捷", "體質", "精神"];
    const numericValue = Number(value);
    if (coreAttributes.includes(key) && !isNaN(numericValue)) {
      if (numericValue <= 5) return { level: "低", range: "1-5" };
      if (numericValue <= 10) return { level: "中", range: "6-10" };
      if (numericValue <= 15) return { level: "高", range: "11-15" };
      if (numericValue >= 16) return { level: "極高", range: "16-20" };
    }
    return { level: String(value), range: null };
  };
  var NpcStatus = ({ npcs }) => {
    if (!npcs || npcs.length === 0) {
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "bg-slate-800/50 p-6 rounded-lg shadow-2xl border border-slate-700 backdrop-blur-sm", children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("h3", { className: "text-xl font-bold text-cyan-300 mb-4 border-b border-slate-600 pb-2", children: "NPC 狀態" }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("p", { className: "text-slate-500 italic", children: "目前場景沒有其他角色。" })
      ] });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "bg-slate-800/50 p-6 rounded-lg shadow-2xl border border-slate-700 backdrop-blur-sm", children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("h3", { className: "text-xl font-bold text-cyan-300 mb-4 border-b border-slate-600 pb-2", children: "NPC 狀態" }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "space-y-6", children: npcs.map((npc, index) => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "group relative", children: [
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("h4", { className: "text-lg font-semibold text-cyan-200 mb-2", children: npc.name }),
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "absolute left-0 top-full mt-2 w-max max-w-xs p-3 text-sm bg-slate-900 text-slate-300 rounded-lg shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-50 border border-slate-700", children: npc.description || "一位神秘的人物。" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "space-y-3", children: [
          /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "flex justify-between items-center text-slate-400", children: [
            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { children: "好感度:" }),
            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: `font-mono font-bold ${getAffinityColor(npc.affinity)}`, children: npc.affinity })
          ] }),
          Object.keys(npc.attributes).length > 0 && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("ul", { className: "space-y-1 text-slate-400 border-t border-slate-700 pt-2", children: Object.entries(npc.attributes).map(([key, value]) => {
            const { level, range } = getAttributeLevelInfo2(key, value);
            return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("li", { className: "flex justify-between items-center text-sm", children: [
              /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("span", { children: [
                key,
                ":"
              ] }),
              range ? /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("span", { className: "group relative cursor-help font-mono font-bold text-cyan-400 border-b border-dotted border-slate-500", children: [
                level,
                /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "absolute right-0 top-full mt-2 w-max p-2 text-xs bg-slate-900 text-slate-300 rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-50 border border-slate-700", children: [
                  "數值範圍: ",
                  range
                ] })
              ] }) : /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "font-mono font-bold text-cyan-400", children: level })
            ] }, key);
          }) }),
          (npc.inventory.length > 0 || npc.unknownItemCount && npc.unknownItemCount > 0) && /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("h5", { className: "text-md font-semibold text-slate-300 mb-1 border-t border-slate-700 pt-2", children: "物品:" }),
            /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("ul", { className: "space-y-1 text-slate-400 text-sm", children: [
              npc.inventory.map((item) => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("li", { className: "group relative", children: [
                /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("span", { children: [
                  "- ",
                  item.name
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "absolute left-0 top-full mt-2 w-full max-w-xs p-2 text-xs bg-slate-900 text-slate-300 rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-50 border border-slate-700", children: item.description })
              ] }, item.name)),
              Array.from({ length: npc.unknownItemCount || 0 }).map((_2, i) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("li", { children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { children: "- 未知物品" }) }, `unknown-${npc.name}-${i}`))
            ] })
          ] })
        ] }),
        index < npcs.length - 1 && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("hr", { className: "thematic-divider mt-4" })
      ] }, index)) })
    ] });
  };
  var NpcStatus_default = NpcStatus;

  // components/MonsterStatus.tsx
  var import_react4 = __toESM(require_react());
  var import_jsx_runtime7 = __toESM(require_jsx_runtime());
  var MonsterStatus = ({ monsters }) => {
    const [expandedIndex, setExpandedIndex] = (0, import_react4.useState)(null);
    const handleToggle = (index) => {
      setExpandedIndex(expandedIndex === index ? null : index);
    };
    if (!monsters || monsters.length === 0) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "bg-red-900/20 p-6 rounded-lg shadow-2xl border border-red-700/50 backdrop-blur-sm", children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h3", { className: "text-xl font-bold text-red-300 mb-4 border-b border-red-600/50 pb-2", children: "遭遇威脅" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: "space-y-6", children: monsters.map((monster, index) => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
          "button",
          {
            onClick: () => handleToggle(index),
            className: "w-full text-left flex justify-between items-center group",
            "aria-expanded": expandedIndex === index,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h4", { className: "text-lg font-semibold text-red-200 group-hover:text-red-100 transition-colors", children: monster.name }),
              /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
                "svg",
                {
                  xmlns: "http://www.w3.org/2000/svg",
                  className: `h-5 w-5 text-red-300/80 transition-transform duration-300 ${expandedIndex === index ? "rotate-180" : ""}`,
                  viewBox: "0 0 20 20",
                  fill: "currentColor",
                  children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
                    "path",
                    {
                      fillRule: "evenodd",
                      d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z",
                      clipRule: "evenodd"
                    }
                  )
                }
              )
            ]
          }
        ),
        expandedIndex === index && monster.description && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: "mt-2 pl-2 border-l-2 border-red-500/30 animate-fade-in-fast", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("p", { className: "text-sm text-red-200/90 italic whitespace-pre-wrap", children: monster.description }) }),
        Object.keys(monster.attributes).length > 0 && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("ul", { className: "space-y-1 text-red-300/80 mt-2", children: Object.entries(monster.attributes).map(([key, value]) => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("li", { className: "flex justify-between items-center text-sm", children: [
          /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("span", { children: [
            key,
            ":"
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("span", { className: "font-mono font-bold text-red-200", children: value })
        ] }, key)) }),
        index < monsters.length - 1 && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("hr", { className: "border-t border-red-600/30 mt-4" })
      ] }, index)) })
    ] });
  };
  var MonsterStatus_default = MonsterStatus;

  // components/GameScreen.tsx
  var import_jsx_runtime8 = __toESM(require_jsx_runtime());
  var GameScreen = ({
    storyLog,
    choices,
    playerState,
    npcs,
    monsters,
    isLoading,
    isGameOver,
    gameOverMessage,
    error,
    warnings,
    onMakeChoice,
    onRestart,
    onOpenHistory,
    onClearWarning,
    typewriterSpeed
  }) => {
    const [isTyping, setIsTyping] = (0, import_react5.useState)(true);
    const [isCustomChoiceActive, setIsCustomChoiceActive] = (0, import_react5.useState)(false);
    const [customChoice, setCustomChoice] = (0, import_react5.useState)("");
    (0, import_react5.useEffect)(() => {
      if (!isLoading && storyLog.length > 0 && storyLog[storyLog.length - 1].type === "scene") {
        setIsTyping(true);
        setIsCustomChoiceActive(false);
        setCustomChoice("");
      }
    }, [isLoading, storyLog]);
    const handleTypingComplete = () => {
      setIsTyping(false);
    };
    const handleCustomChoiceSubmit = (e) => {
      e.preventDefault();
      if (customChoice.trim()) {
        onMakeChoice(customChoice.trim());
      }
    };
    const displayLog = (0, import_react5.useMemo)(() => {
      if (!storyLog || storyLog.length === 0) {
        return [];
      }
      const lastStep = storyLog[storyLog.length - 1];
      if (storyLog.length > 1 && storyLog[storyLog.length - 2].type === "choice") {
        return [storyLog[storyLog.length - 2], lastStep];
      }
      return [lastStep];
    }, [storyLog]);
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "grid grid-cols-1 md:grid-cols-3 md:gap-8 animate-fade-in", children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "md:col-span-2 bg-slate-800/50 p-6 md:p-8 rounded-lg shadow-2xl border border-slate-700 backdrop-blur-sm mb-6 md:mb-0", children: [
        warnings.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "mb-4 space-y-2", children: warnings.map((warning, index) => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "p-3 bg-yellow-900/50 border border-yellow-700 rounded-md text-yellow-300 flex justify-between items-center animate-fade-in-fast", children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { children: warning }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("button", { onClick: () => onClearWarning(index), className: "ml-4 text-yellow-400 hover:text-white p-1 rounded-full hover:bg-yellow-700/50", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) })
        ] }, index)) }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(StoryLog_default, { storyLog: displayLog, onTypingComplete: handleTypingComplete, typewriterSpeed }),
        error && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "my-4 p-4 bg-red-900/50 border border-red-700 rounded-md text-red-300 text-center", children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "font-semibold", children: "發生錯誤" }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { children: error })
        ] }),
        isLoading && !isGameOver && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex items-center justify-center text-slate-400 my-4 p-4 text-lg", children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(LoadingIcon_default, {}),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "ml-3", children: "說書人正在思考..." })
        ] }),
        !isLoading && !isGameOver && !isTyping && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "mt-6 animate-fade-in", children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h3", { className: "text-xl text-cyan-300 font-semibold mb-4 text-center", children: "你接下來要做什麼？" }),
          !isCustomChoiceActive ? /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "grid grid-cols-1 gap-4", children: [
            choices.map((choice, index) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "button",
              {
                onClick: () => onMakeChoice(choice.text),
                className: "w-full text-left bg-slate-700/70 p-4 rounded-lg border border-slate-600 hover:bg-cyan-800/50 hover:border-cyan-600 transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-cyan-500 disabled:opacity-50 transform hover:-translate-y-1 active:scale-95",
                disabled: isLoading,
                children: choice.text
              },
              index
            )),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "button",
              {
                onClick: () => setIsCustomChoiceActive(true),
                className: "w-full text-center bg-transparent p-4 rounded-lg border-2 border-dashed border-slate-600 text-slate-400 hover:border-cyan-600 hover:text-cyan-400 transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-cyan-500",
                disabled: isLoading,
                children: "其他... (自行輸入行動)"
              }
            )
          ] }) : /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("form", { onSubmit: handleCustomChoiceSubmit, className: "space-y-4 animate-fade-in-fast", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "input",
              {
                type: "text",
                value: customChoice,
                onChange: (e) => setCustomChoice(e.target.value),
                placeholder: "輸入你的行動...",
                className: "w-full bg-slate-900 border border-slate-600 rounded-md p-3 text-lg text-slate-200 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition duration-300 placeholder-slate-500",
                autoFocus: true
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex gap-4", children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                "button",
                {
                  type: "submit",
                  className: "flex-1 bg-cyan-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-cyan-500 disabled:bg-slate-600 disabled:cursor-not-allowed transition-all duration-300",
                  disabled: !customChoice.trim() || isLoading,
                  children: "送出"
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                "button",
                {
                  type: "button",
                  onClick: () => setIsCustomChoiceActive(false),
                  className: "flex-1 bg-slate-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-500 transition-all duration-300",
                  disabled: isLoading,
                  children: "取消"
                }
              )
            ] })
          ] })
        ] }),
        isGameOver && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "text-center my-6 animate-fade-in", children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-2xl text-cyan-400 font-bold mb-4", children: gameOverMessage }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
            "button",
            {
              onClick: onRestart,
              className: "bg-cyan-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-cyan-500 transition-all duration-300 transform hover:scale-105 active:scale-95 shadow-lg",
              children: "開啟新冒險"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "md:col-span-1", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "sticky top-8 space-y-6", children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(PlayerStatus_default, { playerState }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(NpcStatus_default, { npcs }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(MonsterStatus_default, { monsters }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
          "button",
          {
            onClick: onOpenHistory,
            className: "w-full bg-slate-700/70 text-slate-300 font-bold py-3 px-6 rounded-lg hover:bg-slate-600/70 transition-all duration-300 shadow-lg",
            children: "查看冒險日誌"
          }
        ) })
      ] }) })
    ] });
  };
  var GameScreen_default = GameScreen;

  // components/HistoryModal.tsx
  var import_react6 = __toESM(require_react());
  var import_jsx_runtime9 = __toESM(require_jsx_runtime());
  var HistoryModal = ({ isOpen, onClose, storyLog }) => {
    const modalContentRef = (0, import_react6.useRef)(null);
    (0, import_react6.useEffect)(() => {
      if (isOpen) {
        const animationFrameId = requestAnimationFrame(() => {
          if (modalContentRef.current) {
            modalContentRef.current.scrollTop = modalContentRef.current.scrollHeight;
          }
        });
        return () => cancelAnimationFrame(animationFrameId);
      }
    }, [isOpen]);
    if (!isOpen) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      "div",
      {
        className: "fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4 animate-fade-in-fast",
        onClick: onClose,
        children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
          "div",
          {
            className: "bg-slate-800 w-full max-w-2xl max-h-[80vh] rounded-lg shadow-2xl border border-slate-700 flex flex-col",
            onClick: (e) => e.stopPropagation(),
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("header", { className: "p-4 border-b border-slate-600 flex justify-between items-center sticky top-0 bg-slate-800", children: [
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h2", { className: "text-2xl font-bold text-cyan-300", children: "冒險日誌" }),
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: onClose, className: "text-slate-400 hover:text-white transition-colors", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { ref: modalContentRef, className: "p-6 overflow-y-auto space-y-6", children: storyLog.map((step, index) => {
                if (step.type === "scene") {
                  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "text-slate-300 text-lg leading-relaxed whitespace-pre-wrap", children: step.content }, index);
                }
                if (step.type === "choice") {
                  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(import_react6.default.Fragment, { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "text-right", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { className: "inline-block bg-cyan-900/50 text-cyan-200 italic px-4 py-2 rounded-lg border border-cyan-800", children: [
                      "> ",
                      step.content
                    ] }) }),
                    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("hr", { className: "thematic-divider" })
                  ] }, index);
                }
                return null;
              }) })
            ]
          }
        )
      }
    );
  };
  var HistoryModal_default = HistoryModal;

  // components/ApiKeyInput.tsx
  var import_react7 = __toESM(require_react());
  var import_jsx_runtime10 = __toESM(require_jsx_runtime());
  var ApiKeyInput = ({ onKeySubmit, isVerifying, error }) => {
    const [key, setKey] = (0, import_react7.useState)("");
    const handleSubmit = (e) => {
      e.preventDefault();
      if (key.trim() && !isVerifying) {
        onKeySubmit(key.trim());
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: "bg-slate-800/50 p-8 rounded-lg shadow-2xl border border-slate-700 animate-fade-in-up backdrop-blur-sm", children: [
      /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("h2", { className: "text-2xl font-semibold text-cyan-300 mb-4 text-center", children: "輸入您的 API 金鑰" }),
      /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("p", { className: "text-slate-400 mb-6 text-center", children: [
        "要遊玩此遊戲，您需要一個 Google AI API 金鑰。您可以從",
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("a", { href: "https://aistudio.google.com/app/apikey", target: "_blank", rel: "noopener noreferrer", className: "text-cyan-400 underline hover:text-cyan-300", children: "Google AI Studio" }),
        "免費取得。"
      ] }),
      error && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "my-4 p-3 bg-red-900/50 border border-red-700 rounded-md text-red-300 text-center", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("p", { children: error }) }),
      /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("form", { onSubmit: handleSubmit, children: [
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
          "input",
          {
            type: "password",
            value: key,
            onChange: (e) => setKey(e.target.value),
            placeholder: "請在此貼上您的 API 金鑰",
            className: "w-full bg-slate-900 border border-slate-600 rounded-md p-3 text-lg text-slate-200 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition duration-300 placeholder-slate-500",
            disabled: isVerifying
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("p", { className: "text-xs text-slate-500 text-center mt-2", children: "您的金鑰將會安全地儲存在您的瀏覽器中。" }),
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "mt-6 text-center", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(
          "button",
          {
            type: "submit",
            disabled: !key.trim() || isVerifying,
            className: "bg-cyan-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-cyan-500 disabled:bg-slate-600 disabled:cursor-not-allowed transition-all duration-300 transform hover:scale-105 active:scale-95 shadow-lg w-full md:w-auto flex items-center justify-center mx-auto",
            children: [
              isVerifying && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(LoadingIcon_default, {}),
              isVerifying ? "驗證中..." : "儲存並開始"
            ]
          }
        ) })
      ] })
    ] });
  };
  var ApiKeyInput_default = ApiKeyInput;

  // components/HomePage.tsx
  var import_react8 = __toESM(require_react());
  var import_jsx_runtime11 = __toESM(require_jsx_runtime());
  var HomePage = ({ saveSlots, onStartNewGame, onLoadGame, onDeleteSave, onUploadSave }) => {
    const fileInputRef = (0, import_react8.useRef)(null);
    const [uploadSlotIndex, setUploadSlotIndex] = (0, import_react8.useState)(null);
    const handleDownload = (slotIndex) => {
      const saveData = saveSlots[slotIndex];
      if (!saveData) return;
      const jsonString = JSON.stringify(saveData, null, 2);
      const blob = new Blob([jsonString], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `gemini-adventure-save-slot-${slotIndex + 1}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };
    const handleUploadClick = (slotIndex) => {
      setUploadSlotIndex(slotIndex);
      fileInputRef.current?.click();
    };
    const handleFileChange = (event) => {
      const file = event.target.files?.[0];
      if (!file || uploadSlotIndex === null) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const text = e.target?.result;
          if (typeof text !== "string") {
            throw new Error("無法讀取檔案內容。");
          }
          const parsedData = JSON.parse(text);
          if (parsedData.storyLog && parsedData.playerState && parsedData.theme && parsedData.timestamp) {
            onUploadSave(uploadSlotIndex, parsedData);
          } else {
            alert("無效的存檔檔案格式。");
          }
        } catch (error) {
          console.error("解析存檔檔案時出錯:", error);
          alert("讀取存檔檔案失敗。請確認檔案為有效的 JSON 格式。");
        } finally {
          if (event.target) {
            event.target.value = "";
          }
          setUploadSlotIndex(null);
        }
      };
      reader.onerror = () => {
        alert("讀取檔案時發生錯誤。");
      };
      reader.readAsText(file);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "bg-slate-800/50 p-8 rounded-lg shadow-2xl border border-slate-700 animate-fade-in-up backdrop-blur-sm", children: [
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
        "input",
        {
          type: "file",
          ref: fileInputRef,
          onChange: handleFileChange,
          accept: ".json,application/json",
          className: "hidden"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("h2", { className: "text-3xl font-bold text-cyan-300 mb-2 text-center", children: "冒險日誌" }),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("p", { className: "text-slate-400 mb-8 text-center", children: "選擇你的旅程，或開啟一段新的傳說。" }),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: saveSlots.map((save, index) => /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "bg-slate-900/70 p-6 rounded-lg border border-slate-700 flex flex-col justify-between transition-shadow hover:shadow-cyan-500/20", children: [
        /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "flex-grow", children: [
          /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("h3", { className: "text-xl font-semibold text-cyan-400 mb-2", children: [
            "存檔欄位 ",
            index + 1
          ] }),
          save ? /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("p", { className: "text-slate-300 break-all", children: [
              /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("strong", { children: "主題：" }),
              " ",
              save.theme
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("p", { className: "text-slate-400 text-sm mt-1", children: [
              /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("strong", { children: "上次遊玩：" }),
              " ",
              new Date(save.timestamp).toLocaleString()
            ] })
          ] }) : /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("p", { className: "text-slate-500 italic", children: "空的欄位" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "mt-6 flex flex-col sm:flex-row gap-3", children: save ? /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
            "button",
            {
              onClick: () => onLoadGame(index),
              className: "flex-1 bg-cyan-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-cyan-500 transition-all duration-300 transform hover:scale-105 active:scale-95 shadow-lg text-base",
              children: "載入冒險"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
            "button",
            {
              onClick: () => handleDownload(index),
              className: "flex-shrink-0 bg-blue-800/80 text-white font-bold p-2 rounded-lg hover:bg-blue-700/80 transition-all duration-300",
              title: "下載存檔",
              children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("path", { fillRule: "evenodd", d: "M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z", clipRule: "evenodd" }) })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
            "button",
            {
              onClick: () => onDeleteSave(index),
              className: "flex-shrink-0 bg-red-800/80 text-white font-bold p-2 rounded-lg hover:bg-red-700/80 transition-all duration-300",
              title: "刪除存檔",
              children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("path", { fillRule: "evenodd", d: "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z", clipRule: "evenodd" }) })
            }
          )
        ] }) : /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "w-full flex gap-3", children: [
          /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
            "button",
            {
              onClick: () => onStartNewGame(index),
              className: "flex-1 bg-slate-700/70 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-600/70 transition-all duration-300 transform hover:scale-105 active:scale-95 shadow-lg text-base",
              children: "開啟新冒險"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
            "button",
            {
              onClick: () => handleUploadClick(index),
              className: "flex-shrink-0 bg-teal-800/80 text-white font-bold p-2 rounded-lg hover:bg-teal-700/80 transition-all duration-300",
              title: "上傳存檔",
              children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("path", { fillRule: "evenodd", d: "M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z", clipRule: "evenodd" }) })
            }
          )
        ] }) })
      ] }, index)) })
    ] });
  };
  var HomePage_default = HomePage;

  // components/CharacterCreation.tsx
  var import_react10 = __toESM(require_react());

  // node_modules/react-image-crop/dist/index.js
  var import_react9 = __toESM(require_react(), 1);
  var _ = Object.defineProperty;
  var $ = (a, h, e) => h in a ? _(a, h, { enumerable: true, configurable: true, writable: true, value: e }) : a[h] = e;
  var m = (a, h, e) => $(a, typeof h != "symbol" ? h + "" : h, e);
  var E = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    unit: "px"
  };
  var b = (a, h, e) => Math.min(Math.max(a, h), e);
  var H = (...a) => a.filter((h) => h && typeof h == "string").join(" ");
  var X = (a, h) => a === h || a.width === h.width && a.height === h.height && a.x === h.x && a.y === h.y && a.unit === h.unit;
  function B(a, h, e, n) {
    const t = D(a, e, n);
    return a.width && (t.height = t.width / h), a.height && (t.width = t.height * h), t.y + t.height > n && (t.height = n - t.y, t.width = t.height * h), t.x + t.width > e && (t.width = e - t.x, t.height = t.width / h), a.unit === "%" ? v(t, e, n) : t;
  }
  function L(a, h, e) {
    const n = D(a, h, e);
    return n.x = (h - n.width) / 2, n.y = (e - n.height) / 2, a.unit === "%" ? v(n, h, e) : n;
  }
  function v(a, h, e) {
    return a.unit === "%" ? { ...E, ...a, unit: "%" } : {
      unit: "%",
      x: a.x ? a.x / h * 100 : 0,
      y: a.y ? a.y / e * 100 : 0,
      width: a.width ? a.width / h * 100 : 0,
      height: a.height ? a.height / e * 100 : 0
    };
  }
  function D(a, h, e) {
    return a.unit ? a.unit === "px" ? { ...E, ...a, unit: "px" } : {
      unit: "px",
      x: a.x ? a.x * h / 100 : 0,
      y: a.y ? a.y * e / 100 : 0,
      width: a.width ? a.width * h / 100 : 0,
      height: a.height ? a.height * e / 100 : 0
    } : { ...E, ...a, unit: "px" };
  }
  function k(a, h, e, n, t, d = 0, r = 0, o = n, w = t) {
    const i = { ...a };
    let s = Math.min(d, n), c = Math.min(r, t), g = Math.min(o, n), p = Math.min(w, t);
    h && (h > 1 ? (s = r ? r * h : s, c = s / h, g = o * h) : (c = d ? d / h : c, s = c * h, p = w / h)), i.y < 0 && (i.height = Math.max(i.height + i.y, c), i.y = 0), i.x < 0 && (i.width = Math.max(i.width + i.x, s), i.x = 0);
    const l = n - (i.x + i.width);
    l < 0 && (i.x = Math.min(i.x, n - s), i.width += l);
    const C = t - (i.y + i.height);
    if (C < 0 && (i.y = Math.min(i.y, t - c), i.height += C), i.width < s && ((e === "sw" || e == "nw") && (i.x -= s - i.width), i.width = s), i.height < c && ((e === "nw" || e == "ne") && (i.y -= c - i.height), i.height = c), i.width > g && ((e === "sw" || e == "nw") && (i.x -= g - i.width), i.width = g), i.height > p && ((e === "nw" || e == "ne") && (i.y -= p - i.height), i.height = p), h) {
      const y = i.width / i.height;
      if (y < h) {
        const f = Math.max(i.width / h, c);
        (e === "nw" || e == "ne") && (i.y -= f - i.height), i.height = f;
      } else if (y > h) {
        const f = Math.max(i.height * h, s);
        (e === "sw" || e == "nw") && (i.x -= f - i.width), i.width = f;
      }
    }
    return i;
  }
  function I(a, h, e, n) {
    const t = { ...a };
    return h === "ArrowLeft" ? n === "nw" ? (t.x -= e, t.y -= e, t.width += e, t.height += e) : n === "w" ? (t.x -= e, t.width += e) : n === "sw" ? (t.x -= e, t.width += e, t.height += e) : n === "ne" ? (t.y += e, t.width -= e, t.height -= e) : n === "e" ? t.width -= e : n === "se" && (t.width -= e, t.height -= e) : h === "ArrowRight" && (n === "nw" ? (t.x += e, t.y += e, t.width -= e, t.height -= e) : n === "w" ? (t.x += e, t.width -= e) : n === "sw" ? (t.x += e, t.width -= e, t.height -= e) : n === "ne" ? (t.y -= e, t.width += e, t.height += e) : n === "e" ? t.width += e : n === "se" && (t.width += e, t.height += e)), h === "ArrowUp" ? n === "nw" ? (t.x -= e, t.y -= e, t.width += e, t.height += e) : n === "n" ? (t.y -= e, t.height += e) : n === "ne" ? (t.y -= e, t.width += e, t.height += e) : n === "sw" ? (t.x += e, t.width -= e, t.height -= e) : n === "s" ? t.height -= e : n === "se" && (t.width -= e, t.height -= e) : h === "ArrowDown" && (n === "nw" ? (t.x += e, t.y += e, t.width -= e, t.height -= e) : n === "n" ? (t.y += e, t.height -= e) : n === "ne" ? (t.y += e, t.width -= e, t.height -= e) : n === "sw" ? (t.x -= e, t.width += e, t.height += e) : n === "s" ? t.height += e : n === "se" && (t.width += e, t.height += e)), t;
  }
  var M = { capture: true, passive: false };
  var N = 0;
  var x = class x2 extends import_react9.PureComponent {
    constructor() {
      super(...arguments);
      m(this, "docMoveBound", false);
      m(this, "mouseDownOnCrop", false);
      m(this, "dragStarted", false);
      m(this, "evData", {
        startClientX: 0,
        startClientY: 0,
        startCropX: 0,
        startCropY: 0,
        clientX: 0,
        clientY: 0,
        isResize: true
      });
      m(this, "componentRef", (0, import_react9.createRef)());
      m(this, "mediaRef", (0, import_react9.createRef)());
      m(this, "resizeObserver");
      m(this, "initChangeCalled", false);
      m(this, "instanceId", `rc-${N++}`);
      m(this, "state", {
        cropIsActive: false,
        newCropIsBeingDrawn: false
      });
      m(this, "onCropPointerDown", (e) => {
        const { crop: n, disabled: t } = this.props, d = this.getBox();
        if (!n)
          return;
        const r = D(n, d.width, d.height);
        if (t)
          return;
        e.cancelable && e.preventDefault(), this.bindDocMove(), this.componentRef.current.focus({ preventScroll: true });
        const o = e.target.dataset.ord, w = !!o;
        let i = e.clientX, s = e.clientY, c = r.x, g = r.y;
        if (o) {
          const p = e.clientX - d.x, l = e.clientY - d.y;
          let C = 0, y = 0;
          o === "ne" || o == "e" ? (C = p - (r.x + r.width), y = l - r.y, c = r.x, g = r.y + r.height) : o === "se" || o === "s" ? (C = p - (r.x + r.width), y = l - (r.y + r.height), c = r.x, g = r.y) : o === "sw" || o == "w" ? (C = p - r.x, y = l - (r.y + r.height), c = r.x + r.width, g = r.y) : (o === "nw" || o == "n") && (C = p - r.x, y = l - r.y, c = r.x + r.width, g = r.y + r.height), i = c + d.x + C, s = g + d.y + y;
        }
        this.evData = {
          startClientX: i,
          startClientY: s,
          startCropX: c,
          startCropY: g,
          clientX: e.clientX,
          clientY: e.clientY,
          isResize: w,
          ord: o
        }, this.mouseDownOnCrop = true, this.setState({ cropIsActive: true });
      });
      m(this, "onComponentPointerDown", (e) => {
        const { crop: n, disabled: t, locked: d, keepSelection: r, onChange: o } = this.props, w = this.getBox();
        if (t || d || r && n)
          return;
        e.cancelable && e.preventDefault(), this.bindDocMove(), this.componentRef.current.focus({ preventScroll: true });
        const i = e.clientX - w.x, s = e.clientY - w.y, c = {
          unit: "px",
          x: i,
          y: s,
          width: 0,
          height: 0
        };
        this.evData = {
          startClientX: e.clientX,
          startClientY: e.clientY,
          startCropX: i,
          startCropY: s,
          clientX: e.clientX,
          clientY: e.clientY,
          isResize: true
        }, this.mouseDownOnCrop = true, o(D(c, w.width, w.height), v(c, w.width, w.height)), this.setState({ cropIsActive: true, newCropIsBeingDrawn: true });
      });
      m(this, "onDocPointerMove", (e) => {
        const { crop: n, disabled: t, onChange: d, onDragStart: r } = this.props, o = this.getBox();
        if (t || !n || !this.mouseDownOnCrop)
          return;
        e.cancelable && e.preventDefault(), this.dragStarted || (this.dragStarted = true, r && r(e));
        const { evData: w } = this;
        w.clientX = e.clientX, w.clientY = e.clientY;
        let i;
        w.isResize ? i = this.resizeCrop() : i = this.dragCrop(), X(n, i) || d(
          D(i, o.width, o.height),
          v(i, o.width, o.height)
        );
      });
      m(this, "onComponentKeyDown", (e) => {
        const { crop: n, disabled: t, onChange: d, onComplete: r } = this.props;
        if (t)
          return;
        const o = e.key;
        let w = false;
        if (!n)
          return;
        const i = this.getBox(), s = this.makePixelCrop(i), g = (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey) ? x2.nudgeStepLarge : e.shiftKey ? x2.nudgeStepMedium : x2.nudgeStep;
        if (o === "ArrowLeft" ? (s.x -= g, w = true) : o === "ArrowRight" ? (s.x += g, w = true) : o === "ArrowUp" ? (s.y -= g, w = true) : o === "ArrowDown" && (s.y += g, w = true), w) {
          e.cancelable && e.preventDefault(), s.x = b(s.x, 0, i.width - s.width), s.y = b(s.y, 0, i.height - s.height);
          const p = D(s, i.width, i.height), l = v(s, i.width, i.height);
          d(p, l), r && r(p, l);
        }
      });
      m(this, "onHandlerKeyDown", (e, n) => {
        const {
          aspect: t = 0,
          crop: d,
          disabled: r,
          minWidth: o = 0,
          minHeight: w = 0,
          maxWidth: i,
          maxHeight: s,
          onChange: c,
          onComplete: g
        } = this.props, p = this.getBox();
        if (r || !d)
          return;
        if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight")
          e.stopPropagation(), e.preventDefault();
        else
          return;
        const C = (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey) ? x2.nudgeStepLarge : e.shiftKey ? x2.nudgeStepMedium : x2.nudgeStep, y = D(d, p.width, p.height), f = I(y, e.key, C, n), R = k(
          f,
          t,
          n,
          p.width,
          p.height,
          o,
          w,
          i,
          s
        );
        if (!X(d, R)) {
          const Y = v(R, p.width, p.height);
          c(R, Y), g && g(R, Y);
        }
      });
      m(this, "onDocPointerDone", (e) => {
        const { crop: n, disabled: t, onComplete: d, onDragEnd: r } = this.props, o = this.getBox();
        this.unbindDocMove(), !(t || !n) && this.mouseDownOnCrop && (this.mouseDownOnCrop = false, this.dragStarted = false, r && r(e), d && d(D(n, o.width, o.height), v(n, o.width, o.height)), this.setState({ cropIsActive: false, newCropIsBeingDrawn: false }));
      });
      m(this, "onDragFocus", () => {
        var e;
        (e = this.componentRef.current) == null || e.scrollTo(0, 0);
      });
    }
    get document() {
      return document;
    }
    // We unfortunately get the bounding box every time as x+y changes
    // due to scrolling.
    getBox() {
      const e = this.mediaRef.current;
      if (!e)
        return { x: 0, y: 0, width: 0, height: 0 };
      const { x: n, y: t, width: d, height: r } = e.getBoundingClientRect();
      return { x: n, y: t, width: d, height: r };
    }
    componentDidUpdate(e) {
      const { crop: n, onComplete: t } = this.props;
      if (t && !e.crop && n) {
        const { width: d, height: r } = this.getBox();
        d && r && t(D(n, d, r), v(n, d, r));
      }
    }
    componentWillUnmount() {
      this.resizeObserver && this.resizeObserver.disconnect(), this.unbindDocMove();
    }
    bindDocMove() {
      this.docMoveBound || (this.document.addEventListener("pointermove", this.onDocPointerMove, M), this.document.addEventListener("pointerup", this.onDocPointerDone, M), this.document.addEventListener("pointercancel", this.onDocPointerDone, M), this.docMoveBound = true);
    }
    unbindDocMove() {
      this.docMoveBound && (this.document.removeEventListener("pointermove", this.onDocPointerMove, M), this.document.removeEventListener("pointerup", this.onDocPointerDone, M), this.document.removeEventListener("pointercancel", this.onDocPointerDone, M), this.docMoveBound = false);
    }
    getCropStyle() {
      const { crop: e } = this.props;
      if (e)
        return {
          top: `${e.y}${e.unit}`,
          left: `${e.x}${e.unit}`,
          width: `${e.width}${e.unit}`,
          height: `${e.height}${e.unit}`
        };
    }
    dragCrop() {
      const { evData: e } = this, n = this.getBox(), t = this.makePixelCrop(n), d = e.clientX - e.startClientX, r = e.clientY - e.startClientY;
      return t.x = b(e.startCropX + d, 0, n.width - t.width), t.y = b(e.startCropY + r, 0, n.height - t.height), t;
    }
    getPointRegion(e, n, t, d) {
      const { evData: r } = this, o = r.clientX - e.x, w = r.clientY - e.y;
      let i;
      d && n ? i = n === "nw" || n === "n" || n === "ne" : i = w < r.startCropY;
      let s;
      return t && n ? s = n === "nw" || n === "w" || n === "sw" : s = o < r.startCropX, s ? i ? "nw" : "sw" : i ? "ne" : "se";
    }
    resolveMinDimensions(e, n, t = 0, d = 0) {
      const r = Math.min(t, e.width), o = Math.min(d, e.height);
      return !n || !r && !o ? [r, o] : n > 1 ? r ? [r, r / n] : [o * n, o] : o ? [o * n, o] : [r, r / n];
    }
    resizeCrop() {
      const { evData: e } = this, { aspect: n = 0, maxWidth: t, maxHeight: d } = this.props, r = this.getBox(), [o, w] = this.resolveMinDimensions(r, n, this.props.minWidth, this.props.minHeight);
      let i = this.makePixelCrop(r);
      const s = this.getPointRegion(r, e.ord, o, w), c = e.ord || s;
      let g = e.clientX - e.startClientX, p = e.clientY - e.startClientY;
      (o && c === "nw" || c === "w" || c === "sw") && (g = Math.min(g, -o)), (w && c === "nw" || c === "n" || c === "ne") && (p = Math.min(p, -w));
      const l = {
        unit: "px",
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      s === "ne" ? (l.x = e.startCropX, l.width = g, n ? (l.height = l.width / n, l.y = e.startCropY - l.height) : (l.height = Math.abs(p), l.y = e.startCropY - l.height)) : s === "se" ? (l.x = e.startCropX, l.y = e.startCropY, l.width = g, n ? l.height = l.width / n : l.height = p) : s === "sw" ? (l.x = e.startCropX + g, l.y = e.startCropY, l.width = Math.abs(g), n ? l.height = l.width / n : l.height = p) : s === "nw" && (l.x = e.startCropX + g, l.width = Math.abs(g), n ? (l.height = l.width / n, l.y = e.startCropY - l.height) : (l.height = Math.abs(p), l.y = e.startCropY + p));
      const C = k(
        l,
        n,
        s,
        r.width,
        r.height,
        o,
        w,
        t,
        d
      );
      return n || x2.xyOrds.indexOf(c) > -1 ? i = C : x2.xOrds.indexOf(c) > -1 ? (i.x = C.x, i.width = C.width) : x2.yOrds.indexOf(c) > -1 && (i.y = C.y, i.height = C.height), i.x = b(i.x, 0, r.width - i.width), i.y = b(i.y, 0, r.height - i.height), i;
    }
    renderCropSelection() {
      const {
        ariaLabels: e = x2.defaultProps.ariaLabels,
        disabled: n,
        locked: t,
        renderSelectionAddon: d,
        ruleOfThirds: r,
        crop: o
      } = this.props, w = this.getCropStyle();
      if (o)
        return /* @__PURE__ */ import_react9.default.createElement(
          "div",
          {
            style: w,
            className: "ReactCrop__crop-selection",
            onPointerDown: this.onCropPointerDown,
            "aria-label": e.cropArea,
            tabIndex: 0,
            onKeyDown: this.onComponentKeyDown,
            role: "group"
          },
          !n && !t && /* @__PURE__ */ import_react9.default.createElement("div", { className: "ReactCrop__drag-elements", onFocus: this.onDragFocus }, /* @__PURE__ */ import_react9.default.createElement("div", { className: "ReactCrop__drag-bar ord-n", "data-ord": "n" }), /* @__PURE__ */ import_react9.default.createElement("div", { className: "ReactCrop__drag-bar ord-e", "data-ord": "e" }), /* @__PURE__ */ import_react9.default.createElement("div", { className: "ReactCrop__drag-bar ord-s", "data-ord": "s" }), /* @__PURE__ */ import_react9.default.createElement("div", { className: "ReactCrop__drag-bar ord-w", "data-ord": "w" }), /* @__PURE__ */ import_react9.default.createElement(
            "div",
            {
              className: "ReactCrop__drag-handle ord-nw",
              "data-ord": "nw",
              tabIndex: 0,
              "aria-label": e.nwDragHandle,
              onKeyDown: (i) => this.onHandlerKeyDown(i, "nw"),
              role: "button"
            }
          ), /* @__PURE__ */ import_react9.default.createElement(
            "div",
            {
              className: "ReactCrop__drag-handle ord-n",
              "data-ord": "n",
              tabIndex: 0,
              "aria-label": e.nDragHandle,
              onKeyDown: (i) => this.onHandlerKeyDown(i, "n"),
              role: "button"
            }
          ), /* @__PURE__ */ import_react9.default.createElement(
            "div",
            {
              className: "ReactCrop__drag-handle ord-ne",
              "data-ord": "ne",
              tabIndex: 0,
              "aria-label": e.neDragHandle,
              onKeyDown: (i) => this.onHandlerKeyDown(i, "ne"),
              role: "button"
            }
          ), /* @__PURE__ */ import_react9.default.createElement(
            "div",
            {
              className: "ReactCrop__drag-handle ord-e",
              "data-ord": "e",
              tabIndex: 0,
              "aria-label": e.eDragHandle,
              onKeyDown: (i) => this.onHandlerKeyDown(i, "e"),
              role: "button"
            }
          ), /* @__PURE__ */ import_react9.default.createElement(
            "div",
            {
              className: "ReactCrop__drag-handle ord-se",
              "data-ord": "se",
              tabIndex: 0,
              "aria-label": e.seDragHandle,
              onKeyDown: (i) => this.onHandlerKeyDown(i, "se"),
              role: "button"
            }
          ), /* @__PURE__ */ import_react9.default.createElement(
            "div",
            {
              className: "ReactCrop__drag-handle ord-s",
              "data-ord": "s",
              tabIndex: 0,
              "aria-label": e.sDragHandle,
              onKeyDown: (i) => this.onHandlerKeyDown(i, "s"),
              role: "button"
            }
          ), /* @__PURE__ */ import_react9.default.createElement(
            "div",
            {
              className: "ReactCrop__drag-handle ord-sw",
              "data-ord": "sw",
              tabIndex: 0,
              "aria-label": e.swDragHandle,
              onKeyDown: (i) => this.onHandlerKeyDown(i, "sw"),
              role: "button"
            }
          ), /* @__PURE__ */ import_react9.default.createElement(
            "div",
            {
              className: "ReactCrop__drag-handle ord-w",
              "data-ord": "w",
              tabIndex: 0,
              "aria-label": e.wDragHandle,
              onKeyDown: (i) => this.onHandlerKeyDown(i, "w"),
              role: "button"
            }
          )),
          d && /* @__PURE__ */ import_react9.default.createElement("div", { className: "ReactCrop__selection-addon", onPointerDown: (i) => i.stopPropagation() }, d(this.state)),
          r && /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("div", { className: "ReactCrop__rule-of-thirds-hz" }), /* @__PURE__ */ import_react9.default.createElement("div", { className: "ReactCrop__rule-of-thirds-vt" }))
        );
    }
    makePixelCrop(e) {
      const n = { ...E, ...this.props.crop || {} };
      return D(n, e.width, e.height);
    }
    render() {
      const { aspect: e, children: n, circularCrop: t, className: d, crop: r, disabled: o, locked: w, style: i, ruleOfThirds: s } = this.props, { cropIsActive: c, newCropIsBeingDrawn: g } = this.state, p = r ? this.renderCropSelection() : null, l = H(
        "ReactCrop",
        d,
        c && "ReactCrop--active",
        o && "ReactCrop--disabled",
        w && "ReactCrop--locked",
        g && "ReactCrop--new-crop",
        r && e && "ReactCrop--fixed-aspect",
        r && t && "ReactCrop--circular-crop",
        r && s && "ReactCrop--rule-of-thirds",
        !this.dragStarted && r && !r.width && !r.height && "ReactCrop--invisible-crop",
        t && "ReactCrop--no-animate"
      );
      return /* @__PURE__ */ import_react9.default.createElement("div", { ref: this.componentRef, className: l, style: i }, /* @__PURE__ */ import_react9.default.createElement("div", { ref: this.mediaRef, className: "ReactCrop__child-wrapper", onPointerDown: this.onComponentPointerDown }, n), r ? /* @__PURE__ */ import_react9.default.createElement("svg", { className: "ReactCrop__crop-mask", width: "100%", height: "100%" }, /* @__PURE__ */ import_react9.default.createElement("defs", null, /* @__PURE__ */ import_react9.default.createElement("mask", { id: `hole-${this.instanceId}` }, /* @__PURE__ */ import_react9.default.createElement("rect", { width: "100%", height: "100%", fill: "white" }), t ? /* @__PURE__ */ import_react9.default.createElement(
        "ellipse",
        {
          cx: `${r.x + r.width / 2}${r.unit}`,
          cy: `${r.y + r.height / 2}${r.unit}`,
          rx: `${r.width / 2}${r.unit}`,
          ry: `${r.height / 2}${r.unit}`,
          fill: "black"
        }
      ) : /* @__PURE__ */ import_react9.default.createElement(
        "rect",
        {
          x: `${r.x}${r.unit}`,
          y: `${r.y}${r.unit}`,
          width: `${r.width}${r.unit}`,
          height: `${r.height}${r.unit}`,
          fill: "black"
        }
      ))), /* @__PURE__ */ import_react9.default.createElement("rect", { fill: "black", fillOpacity: 0.5, width: "100%", height: "100%", mask: `url(#hole-${this.instanceId})` })) : void 0, p);
    }
  };
  m(x, "xOrds", ["e", "w"]), m(x, "yOrds", ["n", "s"]), m(x, "xyOrds", ["nw", "ne", "se", "sw"]), m(x, "nudgeStep", 1), m(x, "nudgeStepMedium", 10), m(x, "nudgeStepLarge", 100), m(x, "defaultProps", {
    ariaLabels: {
      cropArea: "Use the arrow keys to move the crop selection area",
      nwDragHandle: "Use the arrow keys to move the north west drag handle to change the crop selection area",
      nDragHandle: "Use the up and down arrow keys to move the north drag handle to change the crop selection area",
      neDragHandle: "Use the arrow keys to move the north east drag handle to change the crop selection area",
      eDragHandle: "Use the up and down arrow keys to move the east drag handle to change the crop selection area",
      seDragHandle: "Use the arrow keys to move the south east drag handle to change the crop selection area",
      sDragHandle: "Use the up and down arrow keys to move the south drag handle to change the crop selection area",
      swDragHandle: "Use the arrow keys to move the south west drag handle to change the crop selection area",
      wDragHandle: "Use the up and down arrow keys to move the west drag handle to change the crop selection area"
    }
  });
  var S = x;

  // components/CharacterCreation.tsx
  var import_jsx_runtime12 = __toESM(require_jsx_runtime());
  var randomNames = [
    "艾拉",
    "雷戈",
    "莉娜",
    "卡恩",
    "莎拉",
    "傑斯",
    "諾娃",
    "瑞克",
    "菲歐",
    "洛奇"
  ];
  var resizeImage = (base64Str) => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement("canvas");
        canvas.width = 160;
        canvas.height = 160;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return reject(new Error("無法獲取畫布上下文"));
        }
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, 0, 0, 160, 160);
        const dataUrl = canvas.toDataURL("image/png");
        const resizedBase64 = dataUrl.split(",")[1];
        resolve(resizedBase64);
      };
      img.onerror = () => {
        reject(new Error("讀取生成圖片時發生錯誤"));
      };
      img.src = `data:image/png;base64,${base64Str}`;
    });
  };
  function centerAspectCrop(mediaWidth, mediaHeight, aspect) {
    return L(
      B(
        {
          unit: "%",
          width: 90
        },
        aspect,
        mediaWidth,
        mediaHeight
      ),
      mediaWidth,
      mediaHeight
    );
  }
  async function getCroppedImg(image, crop) {
    const canvas = document.createElement("canvas");
    canvas.width = 160;
    canvas.height = 160;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      throw new Error("無法獲取 2D 上下文");
    }
    const scaleX = image.naturalWidth / image.width;
    const scaleY = image.naturalHeight / image.height;
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(
      image,
      crop.x * scaleX,
      crop.y * scaleY,
      crop.width * scaleX,
      crop.height * scaleY,
      0,
      0,
      160,
      160
    );
    return new Promise((resolve) => {
      const base64 = canvas.toDataURL("image/png").split(",")[1];
      resolve(base64);
    });
  }
  var ImageCropperModal = ({ src, onConfirm, onCancel }) => {
    const [crop, setCrop] = (0, import_react10.useState)();
    const [completedCrop, setCompletedCrop] = (0, import_react10.useState)();
    const [scale, setScale] = (0, import_react10.useState)(1);
    const imgRef = (0, import_react10.useRef)(null);
    function onImageLoad(e) {
      const { width, height } = e.currentTarget;
      setCrop(centerAspectCrop(width, height, 1));
    }
    async function handleConfirmCrop() {
      if (completedCrop && imgRef.current) {
        try {
          const croppedImageBase64 = await getCroppedImg(imgRef.current, completedCrop);
          onConfirm(croppedImageBase64);
        } catch (e) {
          console.error("Cropping failed:", e);
        }
      }
    }
    const handleWheel = (e) => {
      e.preventDefault();
      setScale((prevScale) => Math.min(Math.max(0.5, prevScale - e.deltaY * 5e-3), 4));
    };
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4 animate-fade-in-fast", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(
      "div",
      {
        className: "bg-slate-800 w-full max-w-md rounded-lg shadow-2xl border border-slate-700 flex flex-col",
        onClick: (e) => e.stopPropagation(),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("header", { className: "p-3 border-b border-slate-600", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("h3", { className: "text-lg font-bold text-cyan-300 text-center", children: "裁切你的頭像" }) }),
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "p-4 overflow-hidden flex justify-center items-center bg-slate-900/50", onWheel: handleWheel, children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
            S,
            {
              crop,
              onChange: (_2, percentCrop) => setCrop(percentCrop),
              onComplete: (c) => setCompletedCrop(c),
              aspect: 1,
              minWidth: 50,
              minHeight: 50,
              circularCrop: true,
              children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
                "img",
                {
                  ref: imgRef,
                  alt: "Crop me",
                  src,
                  style: { transform: `scale(${scale})`, transformOrigin: "center center" },
                  onLoad: onImageLoad
                }
              )
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("p", { className: "text-xs text-slate-500 text-center p-2", children: "使用滑鼠滾輪縮放圖片" }),
          /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("footer", { className: "p-3 flex justify-end gap-3 border-t border-slate-600", children: [
            /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("button", { onClick: onCancel, className: "bg-slate-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-500 transition-all duration-300", children: "取消" }),
            /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
              "button",
              {
                onClick: handleConfirmCrop,
                disabled: !completedCrop?.width || !completedCrop?.height,
                className: "bg-cyan-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-cyan-500 disabled:bg-slate-500 disabled:cursor-not-allowed transition-all duration-300",
                children: "確認"
              }
            )
          ] })
        ]
      }
    ) });
  };
  var CharacterCreation = ({
    onConfirm,
    isLoading,
    loadingMessage,
    theme,
    initialIntroduction,
    onGenerateAvatar
  }) => {
    const [name, setName] = (0, import_react10.useState)("");
    const [background, setBackground] = (0, import_react10.useState)("");
    const [avatar, setAvatar] = (0, import_react10.useState)(null);
    const [isGeneratingAvatar, setIsGeneratingAvatar] = (0, import_react10.useState)(false);
    const [uploadError, setUploadError] = (0, import_react10.useState)(null);
    const [base64Input, setBase64Input] = (0, import_react10.useState)("");
    const [copySuccess, setCopySuccess] = (0, import_react10.useState)(false);
    const fileInputRef = (0, import_react10.useRef)(null);
    const [cropImageSrc, setCropImageSrc] = (0, import_react10.useState)(null);
    (0, import_react10.useEffect)(() => {
      if (initialIntroduction) {
        setBackground(initialIntroduction);
      }
    }, [initialIntroduction]);
    const handleSubmit = (e) => {
      e.preventDefault();
      if (!isLoading) {
        let finalName = name.trim();
        if (!finalName) {
          finalName = randomNames[Math.floor(Math.random() * randomNames.length)];
        }
        onConfirm(finalName, background.trim(), avatar);
      }
    };
    const handleGenerateClick = async () => {
      if (!background.trim()) {
        alert("請先填寫或確認腳色介紹，才能生成頭像。");
        return;
      }
      setIsGeneratingAvatar(true);
      setUploadError(null);
      try {
        const generatedAvatar = await onGenerateAvatar(background);
        if (generatedAvatar) {
          const resizedAvatar = await resizeImage(generatedAvatar);
          setAvatar(resizedAvatar);
          setBase64Input("");
        }
      } catch (error) {
        console.error("Avatar generation or resizing failed:", error);
        const errorMessage = error instanceof Error ? error.message : "生成或處理頭像時發生未知錯誤。";
        setUploadError(errorMessage);
      } finally {
        setIsGeneratingAvatar(false);
      }
    };
    const handleUploadClick = () => {
      fileInputRef.current?.click();
    };
    const handleFileChange = (event) => {
      const file = event.target.files?.[0];
      if (!file) return;
      setUploadError(null);
      if (!["image/png", "image/jpeg"].includes(file.type)) {
        setUploadError("檔案格式錯誤，請上傳 PNG 或 JPG 圖片。");
        return;
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        setCropImageSrc(e.target?.result);
      };
      reader.readAsDataURL(file);
      if (event.target) event.target.value = "";
    };
    const handleBase64InputChange = (e) => {
      const value = e.target.value;
      setBase64Input(value);
      setAvatar(value.trim());
    };
    const handleCopyClick = () => {
      if (!avatar) return;
      navigator.clipboard.writeText(avatar).then(() => {
        setCopySuccess(true);
        let start = null;
        const resetAfter2s = (timestamp) => {
          if (start === null) {
            start = timestamp;
          }
          const elapsed = timestamp - start;
          if (elapsed < 2e3) {
            requestAnimationFrame(resetAfter2s);
          } else {
            setCopySuccess(false);
          }
        };
        requestAnimationFrame(resetAfter2s);
      });
    };
    const handleCropConfirm = (croppedBase64) => {
      setAvatar(croppedBase64);
      setCropImageSrc(null);
      setBase64Input("");
    };
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [
      cropImageSrc && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
        ImageCropperModal,
        {
          src: cropImageSrc,
          onConfirm: handleCropConfirm,
          onCancel: () => setCropImageSrc(null)
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "bg-slate-800/50 p-8 rounded-lg shadow-2xl border border-slate-700 animate-fade-in-up backdrop-blur-sm max-w-4xl mx-auto", children: [
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("h2", { className: "text-2xl font-semibold text-cyan-300 mb-2 text-center", children: "創建你的角色" }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("p", { className: "text-slate-400 mb-6 text-center", children: [
          "你的冒險主題是：",
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("strong", { className: "text-cyan-400", children: theme || "未知" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("form", { onSubmit: handleSubmit, children: [
          /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "grid md:grid-cols-2 gap-8", children: [
            /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "space-y-6", children: [
              /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("label", { htmlFor: "character-name", className: "block text-lg font-medium text-slate-300 mb-2", children: "你的名字" }),
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
                  "input",
                  {
                    id: "character-name",
                    type: "text",
                    value: name,
                    onChange: (e) => setName(e.target.value),
                    placeholder: `例如：${randomNames[0]}`,
                    className: "w-full bg-slate-900 border border-slate-600 rounded-md p-3 text-lg text-slate-200 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition duration-300 placeholder-slate-500",
                    disabled: isLoading,
                    autoFocus: true
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("p", { className: "text-xs text-slate-500 text-center mt-2", children: "若留白，將會隨機產生一個名字。" })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("label", { htmlFor: "character-introduction", className: "block text-lg font-medium text-slate-300 mb-2", children: "你的腳色介紹" }),
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
                  "textarea",
                  {
                    id: "character-introduction",
                    value: background,
                    onChange: (e) => setBackground(e.target.value),
                    placeholder: initialIntroduction ? "" : "正在生成腳色介紹...",
                    className: "w-full bg-slate-900 border border-slate-600 rounded-md p-3 text-lg text-slate-200 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition duration-300 placeholder-slate-500 h-48 resize-y",
                    disabled: isLoading || !initialIntroduction
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("p", { className: "text-xs text-slate-500 text-center mt-2", children: "這是 AI 為你生成的腳色介紹，你可以自由修改它。" })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "space-y-4 flex flex-col", children: [
              /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("label", { className: "block text-lg font-medium text-slate-300", children: "角色頭像" }),
              /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "w-[160px] h-[160px] mx-auto bg-slate-900/50 rounded-lg border-2 border-slate-700 flex items-center justify-center p-1", children: avatar ? /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("img", { src: `data:image/png;base64,${avatar}`, alt: "角色頭像預覽", className: "w-full h-full object-contain pixelated-image" }) : /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "text-slate-500 text-center text-xs", children: "預覽" }) }),
              uploadError && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("p", { className: "text-red-400 text-xs text-center", children: uploadError }),
              /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "space-y-3", children: [
                /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("button", { type: "button", onClick: handleGenerateClick, disabled: isLoading || isGeneratingAvatar || !background.trim(), className: "w-full bg-cyan-700 text-white font-bold py-2 px-4 rounded-lg hover:bg-cyan-600 disabled:bg-slate-600 disabled:cursor-not-allowed transition-all duration-300 flex items-center justify-center", children: [
                  isGeneratingAvatar && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(LoadingIcon_default, {}),
                  isGeneratingAvatar ? "生成中..." : "依介紹生成頭像"
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("input", { type: "file", ref: fileInputRef, onChange: handleFileChange, accept: "image/png,image/jpeg", className: "hidden" }),
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("button", { type: "button", onClick: handleUploadClick, disabled: isLoading, className: "w-full bg-slate-700 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-600 disabled:bg-slate-600 disabled:cursor-not-allowed transition-all duration-300", children: "上傳圖片 (PNG / JPG)" })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "flex-grow flex flex-col", children: [
                /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "flex justify-between items-center mb-1", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("label", { htmlFor: "avatar-base64", className: "text-sm text-slate-400", children: "或貼上 Base64" }),
                  avatar && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("button", { type: "button", onClick: handleCopyClick, className: "text-xs bg-slate-600 hover:bg-slate-500 text-white font-bold py-1 px-2 rounded transition-colors duration-200", children: copySuccess ? "已複製！" : "複製目前頭像" })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
                  "textarea",
                  {
                    id: "avatar-base64",
                    value: base64Input,
                    onChange: handleBase64InputChange,
                    placeholder: "在此貼上圖片的 Base64 字串...",
                    className: "w-full flex-grow bg-slate-900 border border-slate-600 rounded-md p-2 text-xs text-slate-200 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition duration-300 placeholder-slate-500 resize-y",
                    disabled: isLoading
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "mt-8 pt-6 border-t border-slate-700 text-center", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
            "button",
            {
              type: "submit",
              disabled: isLoading || !background.trim(),
              className: "bg-cyan-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-cyan-500 disabled:bg-slate-600 disabled:cursor-not-allowed transition-all duration-300 transform hover:scale-105 active:scale-95 shadow-lg w-full md:w-auto flex items-center justify-center mx-auto",
              children: isLoading ? /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(LoadingIcon_default, {}),
                loadingMessage || "處理中..."
              ] }) : "開始冒險"
            }
          ) })
        ] })
      ] })
    ] });
  };
  var CharacterCreation_default = CharacterCreation;

  // components/InspirationLoadingModal.tsx
  var import_jsx_runtime13 = __toESM(require_jsx_runtime());
  var InspirationLoadingModal = ({ isOpen }) => {
    if (!isOpen) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { className: "fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4 animate-fade-in-fast backdrop-blur-sm", children: /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)("div", { className: "bg-slate-800/80 p-6 rounded-lg shadow-2xl border border-slate-700 flex items-center justify-center", children: [
      /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(LoadingIcon_default, {}),
      /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("span", { className: "ml-4 text-lg text-slate-300", children: "靈感生成中..." })
    ] }) });
  };
  var InspirationLoadingModal_default = InspirationLoadingModal;

  // App.tsx
  var import_jsx_runtime14 = __toESM(require_jsx_runtime());
  var applyPlayerStateUpdate = (currentState, update) => {
    const newState = {
      ...currentState,
      attributes: { ...currentState.attributes },
      inventory: [...currentState.inventory]
    };
    if (update.setAttributes) {
      update.setAttributes.forEach((attr) => {
        const numValue = Number(attr.value);
        newState.attributes[attr.key] = isNaN(numValue) ? attr.value : numValue;
      });
    }
    if (update.addItems) {
      newState.inventory.push(...update.addItems);
    }
    if (update.removeItems) {
      const itemsToRemove = new Set(update.removeItems);
      newState.inventory = newState.inventory.filter((item) => !itemsToRemove.has(item.name));
    }
    return newState;
  };
  var transformNpcsFromResponse = (npcsResponse) => {
    if (!npcsResponse) {
      return [];
    }
    return npcsResponse.map((npcData) => ({
      name: npcData.name,
      description: npcData.description,
      affinity: npcData.affinity,
      inventory: npcData.inventory,
      unknownItemCount: npcData.unknownItemCount,
      attributes: npcData.attributes.reduce((acc, attr) => {
        const numValue = Number(attr.value);
        acc[attr.key] = isNaN(numValue) ? attr.value : numValue;
        return acc;
      }, {})
    }));
  };
  var transformMonstersFromResponse = (monstersResponse) => {
    if (!monstersResponse) {
      return [];
    }
    return monstersResponse.map((monsterData) => ({
      name: monsterData.name,
      description: monsterData.description,
      attributes: monsterData.attributes.reduce((acc, attr) => {
        const numValue = Number(attr.value);
        acc[attr.key] = isNaN(numValue) ? attr.value : numValue;
        return acc;
      }, {})
    }));
  };
  var App = () => {
    const [apiKey, setApiKey] = (0, import_react11.useState)(null);
    const [gameState, setGameState] = (0, import_react11.useState)(0 /* HOME */);
    const [storyLog, setStoryLog] = (0, import_react11.useState)([]);
    const [playerState, setPlayerState] = (0, import_react11.useState)(null);
    const [npcs, setNpcs] = (0, import_react11.useState)([]);
    const [monsters, setMonsters] = (0, import_react11.useState)([]);
    const [currentChoices, setCurrentChoices] = (0, import_react11.useState)([]);
    const [isLoading, setIsLoading] = (0, import_react11.useState)(false);
    const [loadingMessage, setLoadingMessage] = (0, import_react11.useState)("");
    const [error, setError] = (0, import_react11.useState)(null);
    const [warnings, setWarnings] = (0, import_react11.useState)([]);
    const [isGameOver, setIsGameOver] = (0, import_react11.useState)(false);
    const [gameOverMessage, setGameOverMessage] = (0, import_react11.useState)("");
    const [isHistoryModalOpen, setIsHistoryModalOpen] = (0, import_react11.useState)(false);
    const [saveSlots, setSaveSlots] = (0, import_react11.useState)([]);
    const [activeSlot, setActiveSlot] = (0, import_react11.useState)(null);
    const [selectedTheme, setSelectedTheme] = (0, import_react11.useState)(null);
    const [generatedIntroduction, setGeneratedIntroduction] = (0, import_react11.useState)(null);
    const [isGeneratingInspiration, setIsGeneratingInspiration] = (0, import_react11.useState)(false);
    const [isVerifyingKey, setIsVerifyingKey] = (0, import_react11.useState)(false);
    const [keyError, setKeyError] = (0, import_react11.useState)(null);
    const [typewriterSpeed, setTypewriterSpeed] = (0, import_react11.useState)(25);
    const [isSpeedMenuOpen, setIsSpeedMenuOpen] = (0, import_react11.useState)(false);
    const speedMenuRef = (0, import_react11.useRef)(null);
    const speedOptions = {
      "慢": 50,
      "中": 25,
      "快": 10,
      "無": 0
    };
    const getCurrentSpeedLabel = () => {
      return Object.keys(speedOptions).find((key) => speedOptions[key] === typewriterSpeed) || "中";
    };
    (0, import_react11.useEffect)(() => {
      const handleClickOutside = (event) => {
        if (speedMenuRef.current && !speedMenuRef.current.contains(event.target)) {
          setIsSpeedMenuOpen(false);
        }
      };
      document.addEventListener("mousedown", handleClickOutside);
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
      };
    }, []);
    (0, import_react11.useEffect)(() => {
      const storedKey = localStorage.getItem("gemini-api-key");
      if (storedKey) {
        setApiKey(storedKey);
      }
      setSaveSlots(getAllSaves());
    }, []);
    const resetState = (0, import_react11.useCallback)((isFullReset = false) => {
      if (isFullReset) {
        setGameState(0 /* HOME */);
        setSaveSlots(getAllSaves());
      }
      setStoryLog([]);
      setCurrentChoices([]);
      setPlayerState(null);
      setNpcs([]);
      setMonsters([]);
      setIsLoading(false);
      setLoadingMessage("");
      setError(null);
      setWarnings([]);
      setIsGameOver(false);
      setGameOverMessage("");
      setIsHistoryModalOpen(false);
      setActiveSlot(null);
      setSelectedTheme(null);
      setGeneratedIntroduction(null);
    }, []);
    const handleKeySubmit = (0, import_react11.useCallback)(async (key) => {
      setIsVerifyingKey(true);
      setKeyError(null);
      const isValid = await validateApiKey(key);
      setIsVerifyingKey(false);
      if (isValid) {
        localStorage.setItem("gemini-api-key", key);
        setApiKey(key);
        resetState(true);
      } else {
        setKeyError("API 金鑰無效或無法驗證。請檢查金鑰並重試。");
      }
    }, [resetState]);
    const handleChangeKey = (0, import_react11.useCallback)((errorMessage) => {
      localStorage.removeItem("gemini-api-key");
      setApiKey(null);
      resetState(true);
      if (errorMessage) {
        setKeyError(errorMessage);
      }
    }, [resetState]);
    const handleStartNewGame = (slotIndex) => {
      resetState();
      setActiveSlot(slotIndex);
      setGameState(2 /* THEME_SELECTION */);
    };
    const handleThemeSelected = (0, import_react11.useCallback)(async (theme) => {
      if (!apiKey) {
        setError("API 金鑰未設定。");
        return;
      }
      setIsLoading(true);
      setLoadingMessage("正在生成專屬腳色介紹...");
      setError(null);
      setSelectedTheme(theme);
      try {
        const introduction = await generateCharacterIntroduction(theme, apiKey);
        setGeneratedIntroduction(introduction);
        setGameState(1 /* CHARACTER_CREATION */);
      } catch (error2) {
        console.error("Failed to generate introduction:", error2);
        if (error2 instanceof ApiKeyError) {
          handleChangeKey("API 金鑰已失效，請提供新的金鑰。");
        } else {
          setError(error2 instanceof Error ? error2.message : "生成腳色介紹時發生錯誤。");
          setGameState(2 /* THEME_SELECTION */);
        }
      } finally {
        setIsLoading(false);
        setLoadingMessage("");
      }
    }, [apiKey, handleChangeKey]);
    const handleGenerateThemeInspiration = (0, import_react11.useCallback)(async () => {
      if (!apiKey) {
        console.warn("Attempted to generate inspiration without an API key.");
        return null;
      }
      setIsGeneratingInspiration(true);
      try {
        const inspiration = await generateThemeInspiration(apiKey);
        return inspiration;
      } catch (error2) {
        console.error("Failed to generate theme inspiration:", error2);
        if (error2 instanceof ApiKeyError) {
          handleChangeKey("API 金鑰已失效，請提供新的金鑰。");
        }
        throw error2;
      } finally {
        setIsGeneratingInspiration(false);
      }
    }, [apiKey, handleChangeKey]);
    const handleGenerateAvatarRequest = (0, import_react11.useCallback)(async (introduction) => {
      if (!apiKey) {
        setWarnings((prev) => [...prev, "API 金鑰未設定，無法生成頭像。"]);
        return null;
      }
      try {
        const generatedAvatar = await generateCharacterAvatar(introduction, apiKey);
        return generatedAvatar;
      } catch (err) {
        if (err instanceof QuotaError) {
          setWarnings((prev) => [...prev, err.message]);
        } else {
          console.error("An unexpected error occurred during avatar generation:", err);
          setWarnings((prev) => [...prev, "生成角色頭像時發生未知錯誤。"]);
        }
        return null;
      }
    }, [apiKey]);
    const handleCharacterConfirm = (0, import_react11.useCallback)(async (name, background, avatar) => {
      if (!apiKey || activeSlot === null || !selectedTheme) {
        setError("API 金鑰、存檔欄位或主題未設定。");
        return;
      }
      setIsLoading(true);
      setLoadingMessage("分析角色設定並分配屬性...");
      setError(null);
      setWarnings([]);
      clearSave(activeSlot);
      setStoryLog([]);
      setNpcs([]);
      setMonsters([]);
      setIsGameOver(false);
      setGameOverMessage("");
      try {
        const generatedAttributes = await generateInitialAttributes(background, selectedTheme, apiKey);
        const newPlayerState = {
          name,
          background,
          avatar,
          // 使用從創建畫面傳來的頭像
          attributes: {
            "生命值": 100,
            "體力值": 100,
            ...generatedAttributes
          },
          inventory: []
        };
        setPlayerState(newPlayerState);
        setLoadingMessage("構築世界中...");
        const initialHistory = [{ type: "theme", content: selectedTheme }];
        const response = await generateAdventureStep(initialHistory, newPlayerState, [], [], apiKey);
        const newStoryLog = [
          ...initialHistory,
          { type: "scene", content: response.sceneDescription }
        ];
        let updatedPlayerState = newPlayerState;
        if (response.playerStateUpdate) {
          updatedPlayerState = applyPlayerStateUpdate(newPlayerState, response.playerStateUpdate);
        }
        const transformedNpcs = transformNpcsFromResponse(response.npcs);
        const transformedMonsters = transformMonstersFromResponse(response.monsters);
        setStoryLog(newStoryLog);
        setCurrentChoices(response.choices);
        setPlayerState(updatedPlayerState);
        setNpcs(transformedNpcs);
        setMonsters(transformedMonsters);
        setGameState(3 /* PLAYING */);
        if (response.isGameOver) {
          setIsGameOver(true);
          setGameOverMessage(response.gameOverMessage || "遊戲結束。");
        }
        saveGame({
          storyLog: newStoryLog,
          playerState: updatedPlayerState,
          currentChoices: response.choices,
          isGameOver: response.isGameOver,
          gameOverMessage: response.gameOverMessage || "",
          theme: selectedTheme,
          timestamp: Date.now(),
          npcs: transformedNpcs,
          monsters: transformedMonsters
        }, activeSlot);
      } catch (error2) {
        console.error("Failed to start game:", error2);
        if (error2 instanceof ApiKeyError) {
          handleChangeKey("API 金鑰已失效，請提供新的金鑰。");
        } else {
          setError(error2 instanceof Error ? error2.message : "開始新遊戲時發生未知錯誤。");
          setGameState(1 /* CHARACTER_CREATION */);
        }
      } finally {
        setIsLoading(false);
        setLoadingMessage("");
      }
    }, [apiKey, activeSlot, selectedTheme, handleChangeKey]);
    const handleLoadGame = (slotIndex) => {
      const savedData = loadGame(slotIndex);
      if (savedData) {
        const loadedPlayerState = savedData.playerState ? {
          ...savedData.playerState,
          name: savedData.playerState.name || "冒險者",
          background: savedData.playerState.background || "一位身世不明的冒險者。",
          avatar: savedData.playerState.avatar || null
          // 向後相容
        } : null;
        setStoryLog(savedData.storyLog);
        setPlayerState(loadedPlayerState);
        setCurrentChoices(savedData.currentChoices);
        setIsGameOver(savedData.isGameOver);
        setGameOverMessage(savedData.gameOverMessage);
        const loadedNpcs = (savedData.npcs || []).map((npc) => ({
          ...npc,
          description: npc.description || "",
          // 向後相容
          unknownItemCount: npc.unknownItemCount || 0
        }));
        setNpcs(loadedNpcs);
        const loadedMonsters = (savedData.monsters || []).map((monster) => ({
          ...monster,
          description: monster.description || ""
          // 向後相容
        }));
        setMonsters(loadedMonsters);
        setActiveSlot(slotIndex);
        setGameState(3 /* PLAYING */);
      }
    };
    const handleDeleteSave = (0, import_react11.useCallback)((slotIndex) => {
      if (window.confirm("你確定要刪除這個冒險紀錄嗎？此操作無法復原。")) {
        clearSave(slotIndex);
        setSaveSlots((prevSlots) => {
          const newSlots = [...prevSlots];
          newSlots[slotIndex] = null;
          return newSlots;
        });
      }
    }, []);
    const handleUploadSave = (slotIndex, saveData) => {
      saveGame(saveData, slotIndex);
      setSaveSlots(getAllSaves());
    };
    const handleReturnToHome = () => {
      resetState(true);
    };
    const handleMakeChoice = (0, import_react11.useCallback)(async (choiceText) => {
      if (!apiKey || activeSlot === null || !playerState) {
        setError("遊戲狀態無效，無法繼續。");
        return;
      }
      setIsLoading(true);
      setError(null);
      const newHistory = [
        ...storyLog,
        { type: "choice", content: choiceText }
      ];
      setStoryLog(newHistory);
      setCurrentChoices([]);
      try {
        const response = await generateAdventureStep(newHistory, playerState, npcs, monsters, apiKey);
        const newStoryLogWithScene = [
          ...newHistory,
          { type: "scene", content: response.sceneDescription }
        ];
        let updatedPlayerState = playerState;
        if (response.playerStateUpdate) {
          updatedPlayerState = applyPlayerStateUpdate(playerState, response.playerStateUpdate);
        }
        const transformedNpcs = transformNpcsFromResponse(response.npcs);
        const transformedMonsters = transformMonstersFromResponse(response.monsters);
        setStoryLog(newStoryLogWithScene);
        setCurrentChoices(response.choices);
        setPlayerState(updatedPlayerState);
        setNpcs(transformedNpcs);
        setMonsters(transformedMonsters);
        if (response.isGameOver) {
          setIsGameOver(true);
          setGameOverMessage(response.gameOverMessage || "遊戲結束。");
        }
        const theme = storyLog.find((s) => s.type === "theme")?.content;
        if (theme) {
          saveGame({
            storyLog: newStoryLogWithScene,
            playerState: updatedPlayerState,
            currentChoices: response.choices,
            isGameOver: response.isGameOver,
            gameOverMessage: response.gameOverMessage || "",
            theme,
            timestamp: Date.now(),
            npcs: transformedNpcs,
            monsters: transformedMonsters
          }, activeSlot);
        }
      } catch (error2) {
        console.error("Failed to process choice:", error2);
        if (error2 instanceof ApiKeyError) {
          handleChangeKey("API 金鑰已失效，請提供新的金鑰。");
        } else {
          setError(error2 instanceof Error ? error2.message : "處理您的選擇時發生未知錯誤。");
          setStoryLog(storyLog);
          setCurrentChoices(currentChoices);
        }
      } finally {
        setIsLoading(false);
      }
    }, [apiKey, activeSlot, playerState, storyLog, currentChoices, npcs, monsters, handleChangeKey]);
    const handleClearWarning = (indexToRemove) => {
      setWarnings((prev) => prev.filter((_2, index) => index !== indexToRemove));
    };
    const renderContent = () => {
      if (!apiKey) {
        return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(ApiKeyInput_default, { onKeySubmit: handleKeySubmit, isVerifying: isVerifyingKey, error: keyError });
      }
      if (isLoading && (gameState === 2 /* THEME_SELECTION */ || gameState === 1 /* CHARACTER_CREATION */ && !generatedIntroduction)) {
        return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "bg-slate-800/50 p-8 rounded-lg shadow-2xl border border-slate-700 animate-fade-in-up backdrop-blur-sm text-center", children: /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "flex items-center justify-center text-slate-400 my-4 p-4 text-lg", children: [
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(LoadingIcon_default, {}),
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: "ml-3", children: loadingMessage || "載入中..." })
        ] }) });
      }
      switch (gameState) {
        case 0 /* HOME */:
          return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(HomePage_default, { saveSlots, onStartNewGame: handleStartNewGame, onLoadGame: handleLoadGame, onDeleteSave: handleDeleteSave, onUploadSave: handleUploadSave });
        case 2 /* THEME_SELECTION */:
          return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(ThemeSelector_default, { onThemeSelected: handleThemeSelected, onGenerateInspiration: handleGenerateThemeInspiration });
        case 1 /* CHARACTER_CREATION */:
          return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
            CharacterCreation_default,
            {
              onConfirm: handleCharacterConfirm,
              isLoading,
              loadingMessage,
              theme: selectedTheme,
              initialIntroduction: generatedIntroduction,
              onGenerateAvatar: handleGenerateAvatarRequest
            }
          );
        case 3 /* PLAYING */:
          return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
            GameScreen_default,
            {
              storyLog,
              choices: currentChoices,
              playerState,
              npcs,
              monsters,
              isLoading,
              isGameOver,
              gameOverMessage,
              error,
              warnings,
              onMakeChoice: handleMakeChoice,
              onRestart: handleReturnToHome,
              onOpenHistory: () => setIsHistoryModalOpen(true),
              onClearWarning: handleClearWarning,
              typewriterSpeed
            }
          );
        default:
          return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("p", { children: "未知的遊戲狀態。" });
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("main", { className: "container mx-auto p-4 md:p-8 text-slate-200 relative min-h-screen", children: [
      /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "absolute top-4 right-4 md:top-8 md:right-8 z-10 flex items-center gap-4", children: [
        apiKey && gameState === 3 /* PLAYING */ && /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "relative", ref: speedMenuRef, children: [
          /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "relative group flex items-center", children: [
            /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
              "button",
              {
                onClick: () => setIsSpeedMenuOpen(!isSpeedMenuOpen),
                "aria-label": "調整文字速度",
                className: "bg-slate-700/80 text-slate-300 p-2 rounded-full hover:bg-slate-600/90 transition-all duration-300 shadow-md backdrop-blur-sm border border-slate-600",
                children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M13 10V3L4 14h7v7l9-11h-7z" }) })
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("span", { className: "absolute right-full mr-3 px-2 py-1 bg-slate-900 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none whitespace-nowrap", children: [
              "文字速度: ",
              getCurrentSpeedLabel()
            ] })
          ] }),
          isSpeedMenuOpen && /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "absolute right-0 mt-2 w-28 bg-slate-800 border border-slate-600 rounded-md shadow-lg py-1 z-20 animate-fade-in-fast", children: Object.entries(speedOptions).map(([label, speed]) => /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(
            "button",
            {
              onClick: () => {
                setTypewriterSpeed(speed);
                setIsSpeedMenuOpen(false);
              },
              className: "w-full text-left px-4 py-2 text-sm text-slate-300 hover:bg-slate-700 flex items-center justify-between",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { children: label }),
                typewriterSpeed === speed && /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4 text-cyan-400", viewBox: "0 0 20 20", fill: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("path", { fillRule: "evenodd", d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z", clipRule: "evenodd" }) })
              ]
            },
            label
          )) })
        ] }),
        apiKey && gameState !== 0 /* HOME */ && /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "relative group flex items-center", children: [
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
            "button",
            {
              onClick: handleReturnToHome,
              "aria-label": "返回主選單",
              className: "bg-slate-700/80 text-slate-300 p-2 rounded-full hover:bg-slate-600/90 transition-all duration-300 shadow-md backdrop-blur-sm border border-slate-600",
              children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" }) })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: "absolute right-full mr-3 px-2 py-1 bg-slate-900 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none whitespace-nowrap", children: "返回主選單" })
        ] }),
        apiKey && /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "relative group flex items-center", children: [
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
            "button",
            {
              onClick: () => handleChangeKey(),
              "aria-label": "更換 API 金鑰",
              className: "bg-slate-700/80 text-slate-300 p-2 rounded-full hover:bg-slate-600/90 transition-all duration-300 shadow-md backdrop-blur-sm border border-slate-600",
              children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 0121 7z" }) })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: "absolute right-full mr-3 px-2 py-1 bg-slate-900 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none whitespace-nowrap", children: "更換 API 金鑰" })
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("header", { className: "text-center mb-8 pt-16 md:pt-0", children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("h1", { className: "text-4xl md:text-5xl font-bold text-cyan-300 drop-shadow-[0_2px_2px_rgba(0,0,0,0.5)]", children: "Gemini 冒險紀元" }) }),
      renderContent(),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(HistoryModal_default, { isOpen: isHistoryModalOpen, onClose: () => setIsHistoryModalOpen(false), storyLog }),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(InspirationLoadingModal_default, { isOpen: isGeneratingInspiration })
    ] });
  };
  var App_default = App;

  // index.tsx
  var import_jsx_runtime15 = __toESM(require_jsx_runtime());
  var rootElement = document.getElementById("root");
  if (!rootElement) {
    throw new Error("Could not find root element to mount to");
  }
  var root = import_client.default.createRoot(rootElement);
  root.render(
    /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(import_react12.default.StrictMode, { children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(App_default, {}) })
  );
})();
/*! Bundled license information:

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.js:
  (**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.js:
  (**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.production.js:
  (**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@google/genai/dist/web/index.mjs:
@google/genai/dist/web/index.mjs:
@google/genai/dist/web/index.mjs:
@google/genai/dist/web/index.mjs:
@google/genai/dist/web/index.mjs:
  (**
   * @license
   * Copyright 2025 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
